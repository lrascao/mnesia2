<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>/home/travis/build/lrascao/mnesia2/logs/ct_run.test1128@testing-worker-linux-docker-26d6cbdf-3358-linux-2.2016-04-10_22.41.27/lrascao.mnesia2.mnesia2_extra_light_SUITE.logs/run.2016-04-10_22.41.50/mnesia2_schema.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/lrascao/mnesia2/ebin/mnesia2_schema.erl by COVER 2016-04-10 at 22:42:52

****************************************************************************

        |  %%
        |  %% %CopyrightBegin%
        |  %%
        |  %% Copyright Ericsson AB 1996-2016. All Rights Reserved.
        |  %%
        |  %% Licensed under the Apache License, Version 2.0 (the "License");
        |  %% you may not use this file except in compliance with the License.
        |  %% You may obtain a copy of the License at
        |  %%
        |  %%     http://www.apache.org/licenses/LICENSE-2.0
        |  %%
        |  %% Unless required by applicable law or agreed to in writing, software
        |  %% distributed under the License is distributed on an "AS IS" BASIS,
        |  %% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        |  %% See the License for the specific language governing permissions and
        |  %% limitations under the License.
        |  %%
        |  %% %CopyrightEnd%
        |  %%
        |  
        |  %%
        |  %% In this module we provide a number of explicit functions
        |  %% to maninpulate the schema. All these functions are called
        |  %% within a special schema transaction.
        |  %%
        |  %% We also have an init/1 function defined here, this func is
        |  %% used by mnesia:start() to initialize the entire schema.
        |  
        |  -module(mnesia2_schema).
        |  
        |  -export([
        |           add_snmp/2,
        |           add_table_copy/3,
        |           add_table_index/2,
        |  	 arrange_restore/3,
        |           attr_tab_to_pos/2,
        |           attr_to_pos/2,
        |           change_table_copy_type/3,
        |           change_table_access_mode/2,
        |           change_table_load_order/2,
        |  	 change_table_majority/2,
        |  	 change_table_frag/2,
        |  %%	 clear_table/1,  %% removed since it is not a schema op anymore
        |           create_table/1,
        |  	 cs2list/1,
        |  	 vsn_cs2list/1,
        |           del_snmp/1,
        |           del_table_copy/2,
        |           del_table_index/2,
        |           delete_cstruct/2,
        |           delete_schema/1,
        |           delete_schema2/0,
        |           delete_table/1,
        |           delete_table_property/2,
        |           dump_tables/1,
        |           ensure_no_schema/1,
        |  	 get_create_list/1,
        |           get_initial_schema/2,
        |  	 get_table_properties/1,
        |           info/0,
        |           info/1,
        |           init/1,
        |           insert_cstruct/3,
        |  	 is_remote_member/1,
        |           list2cs/1,
        |           lock_schema/0,
        |           merge_schema/0,
        |           merge_schema/1,
        |           move_table/3,
        |  	 normalize_cs/2,
        |           opt_create_dir/2,
        |           prepare_commit/3,
        |           purge_dir/2,
        |           purge_tmp_files/0,
        |           ram_delete_table/2,
        |  %         ram_delete_table/3,
        |  	 read_cstructs_from_disc/0,
        |           read_nodes/0,
        |           remote_read_schema/0,
        |  	 restore/1,
        |           restore/2,
        |           restore/3,
        |  	 schema_coordinator/3,
        |  	 set_where_to_read/3,
        |           transform_table/4,
        |           undo_prepare_commit/2,
        |           unlock_schema/0,
        |           version/0,
        |           write_table_property/2
        |          ]).
        |  
        |  %% Exports for mnesia2_frag
        |  -export([
        |  	 get_tid_ts_and_lock/2,
        |  	 make_create_table/1,
        |           ensure_active/1,
        |  	 pick/4,
        |  	 verify/3,
        |  	 incr_version/1,
        |  	 check_keys/3,
        |  	 check_duplicates/2,
        |  	 make_delete_table/2
        |  	]).
        |  
        |  %% Needed outside to be able to use/set table_properties
        |  %% from user (not supported)
        |  -export([schema_transaction/1,
        |  	 insert_schema_ops/2,
        |  	 do_create_table/1,
        |  	 do_delete_table/1,
        |  	 do_read_table_property/2,
        |  	 do_delete_table_property/2,
        |   	 do_write_table_property/2]).
        |  
        |  -include("mnesia2.hrl").
        |  -include_lib("kernel/include/file.hrl").
        |  
        |  -import(mnesia2_lib, [set/2, del/2, verbose/2, dbg_out/2]).
        |  
        |  -dialyzer({no_improper_lists, make_delete_table/2}).
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Here comes the init function which also resides in
        |  %% this module, it is called upon by the trans server
        |  %% at startup of the system
        |  %%
        |  %% We have a meta table which looks like
        |  %% {table, schema,
        |  %%    {type, set},
        |  %%    {disc_copies, all},
        |  %%    {arity, 2}
        |  %%    {attributes, [key, val]}
        |  %%
        |  %% This means that we have a series of {schema, Name, Cs} tuples
        |  %% in a table called schema !!
        |  
        |  init(IgnoreFallback) -&gt;
<font color=red>     0..|      Res = read_schema(true, IgnoreFallback),</font>
<font color=red>     0..|      {ok, Source, _CreateList} = exit_on_error(Res),</font>
<font color=red>     0..|      verbose("Schema initiated from: ~p~n", [Source]),</font>
<font color=red>     0..|      set({schema, tables}, []),</font>
<font color=red>     0..|      set({schema, local_tables}, []),</font>
<font color=red>     0..|      Tabs = set_schema(?ets_first(schema)),</font>
<font color=red>     0..|      lists:foreach(fun(Tab) -&gt; clear_whereabouts(Tab) end, Tabs),</font>
<font color=red>     0..|      set({schema, where_to_read}, node()),</font>
<font color=red>     0..|      set({schema, load_node}, node()),</font>
<font color=red>     0..|      set({schema, load_reason}, initial),</font>
<font color=red>     0..|      mnesia2_controller:add_active_replica(schema, node()).</font>
        |  
        |  exit_on_error({error, Reason}) -&gt;
<font color=red>     0..|      exit(Reason);</font>
        |  exit_on_error(GoodRes) -&gt;
<font color=red>     0..|      GoodRes.</font>
        |  
        |  val(Var) -&gt;
<font color=red>     0..|      case ?catch_val(Var) of</font>
<font color=red>     0..|  	{'EXIT', _} -&gt; mnesia2_lib:other_val(Var);</font>
<font color=red>     0..|  	Value -&gt; Value</font>
        |      end.
        |  
        |  %% This function traverses all cstructs in the schema and
        |  %% sets all values in mnesia2_gvar accordingly for each table/cstruct
        |  
        |  set_schema('$end_of_table') -&gt;
<font color=red>     0..|      [];</font>
        |  set_schema(Tab) -&gt;
<font color=red>     0..|      do_set_schema(Tab),</font>
<font color=red>     0..|      [Tab | set_schema(?ets_next(schema, Tab))].</font>
        |  
        |  get_create_list(Tab) -&gt;
<font color=red>     0..|      ?ets_lookup_element(schema, Tab, 3).</font>
        |  
        |  do_set_schema(Tab) -&gt;
<font color=red>     0..|      List = get_create_list(Tab),</font>
<font color=red>     0..|      Cs = list2cs(List),</font>
<font color=red>     0..|      do_set_schema(Tab, Cs).</font>
        |  
        |  do_set_schema(Tab, Cs) -&gt;
<font color=red>     0..|      Type = Cs#cstruct.type,</font>
<font color=red>     0..|      set({Tab, setorbag}, Type),</font>
<font color=red>     0..|      set({Tab, local_content}, Cs#cstruct.local_content),</font>
<font color=red>     0..|      set({Tab, ram_copies}, Cs#cstruct.ram_copies),</font>
<font color=red>     0..|      set({Tab, disc_copies}, Cs#cstruct.disc_copies),</font>
<font color=red>     0..|      set({Tab, disc_only_copies}, Cs#cstruct.disc_only_copies),</font>
<font color=red>     0..|      set({Tab, load_order}, Cs#cstruct.load_order),</font>
<font color=red>     0..|      set({Tab, access_mode}, Cs#cstruct.access_mode),</font>
<font color=red>     0..|      set({Tab, majority}, Cs#cstruct.majority),</font>
<font color=red>     0..|      set({Tab, all_nodes}, mnesia2_lib:cs_to_nodes(Cs)),</font>
<font color=red>     0..|      set({Tab, snmp}, Cs#cstruct.snmp),</font>
<font color=red>     0..|      set({Tab, user_properties}, Cs#cstruct.user_properties),</font>
<font color=red>     0..|      [set({Tab, user_property, element(1, P)}, P) || P &lt;- Cs#cstruct.user_properties],</font>
<font color=red>     0..|      set({Tab, frag_properties}, Cs#cstruct.frag_properties),</font>
<font color=red>     0..|      mnesia2_frag:set_frag_hash(Tab, Cs#cstruct.frag_properties),</font>
<font color=red>     0..|      set({Tab, storage_properties}, Cs#cstruct.storage_properties),</font>
<font color=red>     0..|      set({Tab, attributes}, Cs#cstruct.attributes),</font>
<font color=red>     0..|      Arity = length(Cs#cstruct.attributes) + 1,</font>
<font color=red>     0..|      set({Tab, arity}, Arity),</font>
<font color=red>     0..|      RecName =  Cs#cstruct.record_name,</font>
<font color=red>     0..|      set({Tab, record_name}, RecName),</font>
<font color=red>     0..|      set({Tab, record_validation}, {RecName, Arity, Type}),</font>
<font color=red>     0..|      set({Tab, wild_pattern}, wild(RecName, Arity)),</font>
<font color=red>     0..|      set({Tab, index}, Cs#cstruct.index),</font>
        |      %% create actual index tabs later
<font color=red>     0..|      set({Tab, cookie}, Cs#cstruct.cookie),</font>
<font color=red>     0..|      set({Tab, version}, Cs#cstruct.version),</font>
<font color=red>     0..|      set({Tab, cstruct}, Cs),</font>
<font color=red>     0..|      Storage = mnesia2_lib:schema_cs_to_storage_type(node(), Cs),</font>
<font color=red>     0..|      set({Tab, storage_type}, Storage),</font>
<font color=red>     0..|      mnesia2_lib:add({schema, tables}, Tab),</font>
<font color=red>     0..|      Ns = mnesia2_lib:cs_to_nodes(Cs),</font>
<font color=red>     0..|      case lists:member(node(), Ns) of</font>
        |          true -&gt;
<font color=red>     0..|              mnesia2_lib:add({schema, local_tables}, Tab);</font>
        |          false when Tab == schema -&gt;
<font color=red>     0..|              mnesia2_lib:add({schema, local_tables}, Tab);</font>
        |          false -&gt;
<font color=red>     0..|              ignore</font>
        |      end.
        |  
        |  wild(RecName, Arity) -&gt;
<font color=red>     0..|      Wp0 = list_to_tuple(lists:duplicate(Arity, '_')),</font>
<font color=red>     0..|      setelement(1, Wp0, RecName).</font>
        |  
        |  %% Temporarily read the local schema and return a list
        |  %% of all nodes mentioned in the schema.DAT file
        |  read_nodes() -&gt;
        |      %% Ensure that we access the intended Mnesia2
        |      %% directory. This function may not be called
        |      %% during startup since it will cause the
        |      %% application_controller to get into deadlock
<font color=red>     0..|      case mnesia2_lib:ensure_loaded(?APPLICATION) of</font>
        |  	ok -&gt;
<font color=red>     0..|  	    case read_schema(false) of</font>
        |  		{ok, _Source, CreateList} -&gt;
<font color=red>     0..|  		    Cs = list2cs(CreateList),</font>
<font color=red>     0..|  		    {ok, Cs#cstruct.disc_copies ++ Cs#cstruct.ram_copies};</font>
        |  		{error, Reason} -&gt;
<font color=red>     0..|  		    {error, Reason}</font>
        |  	    end;
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    {error, Reason}</font>
        |      end.
        |  
        |  %% Returns Version from the tuple {Version,MasterNodes}
        |  version() -&gt;
<font color=red>     0..|      case read_schema(false) of</font>
        |          {ok, Source, CreateList} when Source /= default -&gt;
<font color=red>     0..|  	    Cs = list2cs(CreateList),</font>
<font color=red>     0..|              {Version, _Details} = Cs#cstruct.version,</font>
<font color=red>     0..|              Version;</font>
        |          _ -&gt;
<font color=red>     0..|              case dir_exists(mnesia2_lib:dir()) of</font>
<font color=red>     0..|                  true -&gt; {1,0};</font>
<font color=red>     0..|                  false -&gt; {0,0}</font>
        |              end
        |      end.
        |  
        |  %% Calculate next table version from old cstruct
        |  incr_version(Cs) -&gt;
<font color=red>     0..|      {{Major, Minor}, _} = Cs#cstruct.version,</font>
<font color=red>     0..|      Nodes = mnesia2_lib:intersect(val({schema, disc_copies}),</font>
        |                                   mnesia2_lib:cs_to_nodes(Cs)),
<font color=red>     0..|      V =</font>
        |          case Nodes -- val({Cs#cstruct.name, active_replicas}) of
<font color=red>     0..|              [] -&gt; {Major + 1, 0};    % All replicas are active</font>
<font color=red>     0..|              _ -&gt; {Major, Minor + 1}  % Some replicas are inactive</font>
        |          end,
<font color=red>     0..|      Cs#cstruct{version = {V, {node(), mnesia2_time:timestamp()}}}.</font>
        |  
        |  %% Returns table name
        |  insert_cstruct(Tid, Cs, KeepWhereabouts) -&gt;
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      TabDef = cs2list(Cs),</font>
<font color=red>     0..|      Val = {schema, Tab, TabDef},</font>
<font color=red>     0..|      mnesia2_checkpoint:tm_retain(Tid, schema, Tab, write),</font>
<font color=red>     0..|      mnesia2_subscr:report_table_event(schema, Tid, Val, write),</font>
<font color=red>     0..|      Active = val({Tab, active_replicas}),</font>
        |  
<font color=red>     0..|      case KeepWhereabouts of</font>
        |          true -&gt;
<font color=red>     0..|              ignore;</font>
        |          false when Active == [] -&gt;
<font color=red>     0..|              clear_whereabouts(Tab);</font>
        |          false -&gt;
        |              %% Someone else has initiated table
<font color=red>     0..|              ignore</font>
        |      end,
<font color=red>     0..|      set({Tab, cstruct}, Cs),</font>
<font color=red>     0..|      ?ets_insert(schema, Val),</font>
<font color=red>     0..|      do_set_schema(Tab, Cs),</font>
<font color=red>     0..|      Val.</font>
        |  
        |  clear_whereabouts(Tab) -&gt;
<font color=red>     0..|      set({Tab, checkpoints}, []),</font>
<font color=red>     0..|      set({Tab, subscribers}, []),</font>
<font color=red>     0..|      set({Tab, where_to_read}, nowhere),</font>
<font color=red>     0..|      set({Tab, active_replicas}, []),</font>
<font color=red>     0..|      set({Tab, commit_work}, []),</font>
<font color=red>     0..|      set({Tab, where_to_write}, []),</font>
<font color=red>     0..|      set({Tab, where_to_commit}, []),</font>
<font color=red>     0..|      set({Tab, load_by_force}, false),</font>
<font color=red>     0..|      set({Tab, load_node}, unknown),</font>
<font color=red>     0..|      set({Tab, load_reason}, unknown).</font>
        |  
        |  %% Returns table name
        |  delete_cstruct(Tid, Cs) -&gt;
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      TabDef = cs2list(Cs),</font>
<font color=red>     0..|      Val = {schema, Tab, TabDef},</font>
<font color=red>     0..|      mnesia2_checkpoint:tm_retain(Tid, schema, Tab, delete),</font>
<font color=red>     0..|      mnesia2_subscr:report_table_event(schema, Tid, Val, delete),</font>
<font color=red>     0..|      mnesia2_controller:update(</font>
        |        fun() -&gt;
<font color=red>     0..|  	      ?ets_match_delete(mnesia2_gvar, {{Tab, '_'}, '_'}),</font>
<font color=red>     0..|  	      ?ets_match_delete(mnesia2_gvar, {{Tab, '_', '_'}, '_'}),</font>
<font color=red>     0..|  	      del({schema, local_tables}, Tab),</font>
<font color=red>     0..|  	      del({schema, tables}, Tab),</font>
<font color=red>     0..|  	      ?ets_delete(schema, Tab)</font>
        |        end),
<font color=red>     0..|      Val.</font>
        |  
        |  %% Delete the Mnesia2 directory on all given nodes
        |  %% Requires that Mnesia2 is not running anywhere
        |  %% Returns ok | {error,Reason}
        |  delete_schema(Ns) when is_list(Ns), Ns /= [] -&gt;
   123..|      RunningNs = mnesia2_lib:running_nodes(Ns),
   123..|      Reason = "Cannot delete schema on all nodes",
   123..|      if
        |          RunningNs == [] -&gt;
   123..|  	    case rpc:multicall(Ns, ?MODULE, delete_schema2, []) of
        |  		{Replies, []} -&gt;
   123..|  		    case [R || R &lt;- Replies, R /= ok]  of
        |  			[] -&gt;
   123..|  			    ok;
        |  			BadReplies -&gt;
<font color=red>     0..|  			    verbose("~s: ~p~n", [Reason, BadReplies]),</font>
<font color=red>     0..|  			    {error, {"All nodes not running", BadReplies}}</font>
        |  		    end;
        |  		{_Replies, BadNs} -&gt;
<font color=red>     0..|                      verbose("~s: ~p~n", [Reason, BadNs]),</font>
<font color=red>     0..|                      {error, {"All nodes not running", BadNs}}</font>
        |              end;
        |          true -&gt;
<font color=red>     0..|              verbose("~s: ~p~n", [Reason, RunningNs]),</font>
<font color=red>     0..|              {error, {"Mnesia2 is not stopped everywhere", RunningNs}}</font>
        |      end;
        |  delete_schema(Ns) -&gt;
<font color=red>     0..|      {error, {badarg, Ns}}.</font>
        |  
        |  delete_schema2() -&gt;
        |      %% Ensure that we access the intended Mnesia2
        |      %% directory. This function may not be called
        |      %% during startup since it will cause the
        |      %% application_controller to get into deadlock
    58..|      case mnesia2_lib:ensure_loaded(?APPLICATION) of
        |  	ok -&gt;
    58..|  	    case mnesia2_lib:is_running() of
        |  		no -&gt;
    58..|  		    Dir = mnesia2_lib:dir(),
    58..|  		    purge_dir(Dir, []),
    58..|  		    ok;
        |  		_ -&gt;
<font color=red>     0..|  		    {error, {"Mnesia2 still running", node()}}</font>
        |  	    end;
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    {error, Reason}</font>
        |      end.
        |  
        |  ensure_no_schema([H|T]) when is_atom(H) -&gt;
    80..|      case rpc:call(H, ?MODULE, remote_read_schema, []) of
        |          {badrpc, Reason} -&gt;
<font color=red>     0..|              {H, {"All nodes not running", H, Reason}};</font>
        |          {ok,Source, _} when Source /= default -&gt;
<font color=red>     0..|              {H, {already_exists, H}};</font>
        |          _ -&gt;
    80..|              ensure_no_schema(T)
        |      end;
        |  ensure_no_schema([H|_]) -&gt;
<font color=red>     0..|      {error,{badarg, H}};</font>
        |  ensure_no_schema([]) -&gt;
    42..|      ok.
        |  
        |  remote_read_schema() -&gt;
        |      %% Ensure that we access the intended Mnesia2
        |      %% directory. This function may not be called
        |      %% during startup since it will cause the
        |      %% application_controller to get into deadlock
    42..|      case mnesia2_lib:ensure_loaded(?APPLICATION) of
        |  	ok -&gt;
    42..|  	    case mnesia2_monitor:get_env(schema_location) of
        |  		opt_disc -&gt;
    42..|  		    read_schema(false);
        |  		_ -&gt;
<font color=red>     0..|  		    read_schema(false)</font>
        |  	    end;
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    {error, Reason}</font>
        |      end.
        |  
        |  dir_exists(Dir) -&gt;
    58..|      dir_exists(Dir, mnesia2_monitor:use_dir()).
        |  dir_exists(Dir, true) -&gt;
   125..|      case file:read_file_info(Dir) of
   124..|          {ok, _} -&gt; true;
     1..|          _ -&gt; false
        |      end;
        |  dir_exists(_Dir, false) -&gt;
    17..|      false.
        |  
        |  opt_create_dir(UseDir, Dir) when UseDir == true-&gt;
    84..|      case dir_exists(Dir, UseDir) of
        |          true -&gt;
    83..|              check_can_write(Dir);
        |          false -&gt;
     1..|              case file:make_dir(Dir) of
        |                  ok -&gt;
     1..|                      verbose("Create Directory ~p~n", [Dir]),
     1..|                      ok;
        |                  {error, Reason} -&gt;
<font color=red>     0..|                      verbose("Cannot create mnesia2 dir ~p~n", [Reason]),</font>
<font color=red>     0..|                      {error, {"Cannot create Mnesia2 dir", Dir, Reason}}</font>
        |              end
        |      end;
        |  opt_create_dir(false, _) -&gt;
<font color=red>     0..|      {error, {has_no_disc, node()}}.</font>
        |  
        |  check_can_write(Dir) -&gt;
    83..|      case file:read_file_info(Dir) of
        |          {ok, FI} when FI#file_info.type == directory,
        |  		      FI#file_info.access == read_write -&gt;
    83..|              ok;
        |          {ok, _} -&gt;
<font color=red>     0..|              {error, "Not allowed to write in Mnesia2 dir", Dir};</font>
        |          _ -&gt;
<font color=red>     0..|              {error, "Non existent Mnesia2 dir", Dir}</font>
        |      end.
        |  
        |  lock_schema() -&gt;
    42..|      mnesia2_lib:lock_table(schema).
        |  
        |  unlock_schema() -&gt;
    42..|      mnesia2_lib:unlock_table(schema).
        |  
        |  read_schema(Keep) -&gt;
    42..|      read_schema(Keep, false).
        |  
        |  %% The schema may be read for several reasons.
        |  %% If Mnesia2 is not already started the read intention
        |  %% we normally do not want the ets table named schema
        |  %% be left around.
        |  %% If Keep == true, the ets table schema is kept
        |  %% If Keep == false, the ets table schema is removed
        |  %%
        |  %% Returns {ok, Source, SchemaCstruct} or {error, Reason}
        |  %% Source may be: default | ram | disc | fallback
        |  
        |  read_schema(Keep, IgnoreFallback) -&gt;
    42..|      lock_schema(),
    42..|      Res =
        |          case mnesia2:system_info(is_running) of
        |              yes -&gt;
<font color=red>     0..|                  {ok, ram, get_create_list(schema)};</font>
        |              _IsRunning -&gt;
    42..|                      case mnesia2_monitor:use_dir() of
        |                          true -&gt;
<font color=red>     0..|                              read_disc_schema(Keep, IgnoreFallback);</font>
        |                          false when Keep == true -&gt;
<font color=red>     0..|                              Args = [{keypos, 2}, public, named_table, set],</font>
<font color=red>     0..|                              mnesia2_monitor:mktab(schema, Args),</font>
<font color=red>     0..|                              CreateList = get_initial_schema(ram_copies, []),</font>
<font color=red>     0..|                              ?ets_insert(schema,{schema, schema, CreateList}),</font>
<font color=red>     0..|                              {ok, default, CreateList};</font>
        |                          false when Keep == false -&gt;
    42..|  			    CreateList = get_initial_schema(ram_copies, []),
    42..|                              {ok, default, CreateList}
        |                      end
        |          end,
    42..|      unlock_schema(),
    42..|      Res.
        |  
        |  read_disc_schema(Keep, IgnoreFallback) -&gt;
<font color=red>     0..|      Running = mnesia2:system_info(is_running),</font>
<font color=red>     0..|      case mnesia2_bup:fallback_exists() of</font>
        |          true when IgnoreFallback == false, Running /= yes -&gt;
<font color=red>     0..|               mnesia2_bup:fallback_to_schema();</font>
        |          _ -&gt;
        |              %% If we're running, we read the schema file even
        |              %% if fallback exists
<font color=red>     0..|              Dat = mnesia2_lib:tab2dat(schema),</font>
<font color=red>     0..|              case mnesia2_lib:exists(Dat) of</font>
        |                  true -&gt;
<font color=red>     0..|                      do_read_disc_schema(Dat, Keep);</font>
        |                  false -&gt;
<font color=red>     0..|  		    Dmp = mnesia2_lib:tab2dmp(schema),</font>
<font color=red>     0..|  		    case mnesia2_lib:exists(Dmp) of</font>
        |  			true -&gt;
        |  			    %% May only happen when toggling of
        |  			    %% schema storage type has been
        |  			    %% interrupted
<font color=red>     0..|  			    do_read_disc_schema(Dmp, Keep);</font>
        |  			false -&gt;
<font color=red>     0..|  			    {error, "No schema file exists"}</font>
        |  		    end
        |              end
        |      end.
        |  
        |  do_read_disc_schema(Fname, Keep) -&gt;
<font color=red>     0..|      T =</font>
        |          case Keep of
        |              false -&gt;
<font color=red>     0..|                  Args = [{keypos, 2}, public, set],</font>
<font color=red>     0..|                  ?ets_new_table(schema, Args);</font>
        |              true -&gt;
<font color=red>     0..|                  Args = [{keypos, 2}, public, named_table, set],</font>
<font color=red>     0..|                  mnesia2_monitor:mktab(schema, Args)</font>
        |          end,
<font color=red>     0..|      Repair = mnesia2_monitor:get_env(auto_repair),</font>
<font color=red>     0..|      Res =  % BUGBUG Fixa till dcl!</font>
        |          case mnesia2_lib:dets_to_ets(schema, T, Fname, set, Repair, no) of
<font color=red>     0..|              loaded -&gt; {ok, disc, ?ets_lookup_element(T, schema, 3)};</font>
<font color=red>     0..|              Other -&gt; {error, {"Cannot read schema", Fname, Other}}</font>
        |          end,
<font color=red>     0..|      case Keep of</font>
<font color=red>     0..|          true -&gt; ignore;</font>
<font color=red>     0..|          false -&gt; ?ets_delete_table(T)</font>
        |      end,
<font color=red>     0..|      Res.</font>
        |  
        |  get_initial_schema(SchemaStorage, Nodes) -&gt;
    84..|      Cs = #cstruct{name = schema,
        |  		  record_name = schema,
        |  		  attributes = [table, cstruct]},
    84..|      Cs2 =
        |  	case SchemaStorage of
    42..|          ram_copies -&gt; Cs#cstruct{ram_copies = Nodes};
    42..|          disc_copies -&gt; Cs#cstruct{disc_copies = Nodes}
        |      end,
    84..|      cs2list(Cs2).
        |  
        |  read_cstructs_from_disc() -&gt;
        |      %% Assumptions:
        |      %% - local schema lock in global
        |      %% - use_dir is true
        |      %% - Mnesia2 is not running
        |      %% - Ignore fallback
        |  
<font color=red>     0..|      Fname = mnesia2_lib:tab2dat(schema),</font>
<font color=red>     0..|      case mnesia2_lib:exists(Fname) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    Args = [{file, Fname},</font>
        |  		    {keypos, 2},
        |  		    {repair, mnesia2_monitor:get_env(auto_repair)},
        |  		    {type, set}],
<font color=red>     0..|  	    case dets:open_file(make_ref(), Args) of</font>
        |  		{ok, Tab} -&gt;
<font color=red>     0..|  		    Fun = fun({_, _, List}) -&gt;</font>
<font color=red>     0..|  				  {continue, list2cs(List)}</font>
        |  			  end,
<font color=red>     0..|  		    Cstructs = dets:traverse(Tab, Fun),</font>
<font color=red>     0..|  		    dets:close(Tab),</font>
<font color=red>     0..|  		    {ok, Cstructs};</font>
        |  		{error, Reason} -&gt;
<font color=red>     0..|  		    {error, Reason}</font>
        |  	    end;
        |  	false -&gt;
<font color=red>     0..|  	    {error, "No schema file exists"}</font>
        |      end.
        |  
        |  %% We run a very special type of transactions when we
        |  %% we want to manipulate the schema.
        |  
        |  get_tid_ts_and_lock(Tab, Intent) -&gt;
<font color=red>     0..|      TidTs = get(mnesia2_activity_state),</font>
<font color=red>     0..|      case TidTs of</font>
        |  	{_Mod, Tid, Ts} when is_record(Ts, tidstore)-&gt;
<font color=red>     0..|  	    Store = Ts#tidstore.store,</font>
<font color=red>     0..|  	    case Intent of</font>
<font color=red>     0..|  		read -&gt; mnesia2_locker:rlock_table(Tid, Store, Tab);</font>
<font color=red>     0..|  		write -&gt; mnesia2_locker:wlock_table(Tid, Store, Tab);</font>
<font color=red>     0..|  		none -&gt; ignore</font>
        |  	    end,
<font color=red>     0..|  	    TidTs;</font>
        |  	_ -&gt;
<font color=red>     0..|  	    mnesia2:abort(no_transaction)</font>
        |      end.
        |  
        |  schema_transaction(Fun) -&gt;
    17..|      case get(mnesia2_activity_state) of
        |  	undefined -&gt;
    17..|  	    Args = [self(), Fun, whereis(mnesia2_controller)],
    17..|  	    Pid = spawn_link(?MODULE, schema_coordinator, Args),
    17..|  	    receive
    17..|  		{transaction_done, Res, Pid} -&gt; Res;
<font color=red>     0..|  		{'EXIT', Pid, R} -&gt; {aborted, {transaction_crashed, R}}</font>
        |  	    end;
        |  	_ -&gt;
<font color=red>     0..|              {aborted, nested_transaction}</font>
        |      end.
        |  
        |  %% This process may dump the transaction log, and should
        |  %% therefore not be run in an application process
        |  %%
        |  schema_coordinator(Client, _Fun, undefined) -&gt;
    17..|      Res = {aborted, {node_not_running, node()}},
    17..|      Client ! {transaction_done, Res, self()},
    17..|      unlink(Client);
        |  
        |  schema_coordinator(Client, Fun, Controller) when is_pid(Controller) -&gt;
        |      %% Do not trap exit in order to automatically die
        |      %% when the controller dies
        |  
<font color=red>     0..|      link(Controller),</font>
<font color=red>     0..|      unlink(Client),</font>
        |  
        |      %% Fulfull the transaction even if the client dies
<font color=red>     0..|      Res = mnesia2:transaction(Fun),</font>
<font color=red>     0..|      Client ! {transaction_done, Res, self()},</font>
<font color=red>     0..|      unlink(Controller),         % Avoids spurious exit message</font>
<font color=red>     0..|      unlink(whereis(mnesia2_tm)), % Avoids spurious exit message</font>
<font color=red>     0..|      exit(normal).</font>
        |  
        |  %% The make* rotines return a list of ops, this function
        |  %% inserts em all in the Store and maintains the local order
        |  %% of ops.
        |  
        |  insert_schema_ops({_Mod, _Tid, Ts}, SchemaIOps) -&gt;
<font color=red>     0..|      do_insert_schema_ops(Ts#tidstore.store, SchemaIOps).</font>
        |  
        |  do_insert_schema_ops(Store, [Head | Tail]) -&gt;
<font color=red>     0..|      ?ets_insert(Store, Head),</font>
<font color=red>     0..|      do_insert_schema_ops(Store, Tail);</font>
        |  do_insert_schema_ops(_Store, []) -&gt;
<font color=red>     0..|      ok.</font>
        |  
        |  api_list2cs(List) when is_list(List) -&gt;
<font color=red>     0..|      Name = pick(unknown, name, List, must),</font>
<font color=red>     0..|      Keys = check_keys(Name, List, record_info(fields, cstruct)),</font>
<font color=red>     0..|      check_duplicates(Name, Keys),</font>
<font color=red>     0..|      list2cs(List);</font>
        |  api_list2cs(Other) -&gt;
<font color=red>     0..|      mnesia2:abort({badarg, Other}).</font>
        |  
        |  vsn_cs2list(Cs) -&gt;
<font color=red>     0..|      cs2list(need_old_cstructs(), Cs).</font>
        |  
        |  cs2list(Cs) when is_record(Cs, cstruct) -&gt;
    84..|      Tags = record_info(fields, cstruct),
    84..|      rec2list(Tags, Tags, 2, Cs);
        |  cs2list(CreateList) when is_list(CreateList) -&gt;
    42..|      CreateList;
        |  %% 4.6
        |  cs2list(Cs) when element(1, Cs) == cstruct, tuple_size(Cs) == 19 -&gt;
<font color=red>     0..|      Tags = [name,type,ram_copies,disc_copies,disc_only_copies,</font>
        |  	    load_order,access_mode,majority,index,snmp,local_content,
        |  	    record_name,attributes,
        |  	    user_properties,frag_properties,storage_properties,
        |  	    cookie,version],
<font color=red>     0..|      rec2list(Tags, Tags, 2, Cs);</font>
        |  %% 4.4.19
        |  cs2list(Cs) when element(1, Cs) == cstruct, tuple_size(Cs) == 18 -&gt;
<font color=red>     0..|      Tags = [name,type,ram_copies,disc_copies,disc_only_copies,</font>
        |  	    load_order,access_mode,majority,index,snmp,local_content,
        |  	    record_name,attributes,user_properties,frag_properties,
        |  	    cookie,version],
<font color=red>     0..|      rec2list(Tags, Tags, 2, Cs);</font>
        |  %% 4.4.18 and earlier
        |  cs2list(Cs) when element(1, Cs) == cstruct, tuple_size(Cs) == 17 -&gt;
<font color=red>     0..|      Tags = [name,type,ram_copies,disc_copies,disc_only_copies,</font>
        |  	    load_order,access_mode,index,snmp,local_content,
        |  	    record_name,attributes,user_properties,frag_properties,
        |  	    cookie,version],
<font color=red>     0..|      rec2list(Tags, Tags, 2, Cs).</font>
        |  
        |  cs2list(false, Cs) -&gt;
<font color=red>     0..|      cs2list(Cs);</font>
        |  cs2list(ver4_4_18, Cs) -&gt; %% Or earlier
<font color=red>     0..|      Orig = record_info(fields, cstruct),</font>
<font color=red>     0..|      Tags = [name,type,ram_copies,disc_copies,disc_only_copies,</font>
        |  	    load_order,access_mode,index,snmp,local_content,
        |  	    record_name,attributes,user_properties,frag_properties,
        |  	    cookie,version],
<font color=red>     0..|      rec2list(Tags, Orig, 2, Cs);</font>
        |  cs2list(ver4_4_19, Cs) -&gt;
<font color=red>     0..|      Orig = record_info(fields, cstruct),</font>
<font color=red>     0..|      Tags = [name,type,ram_copies,disc_copies,disc_only_copies,</font>
        |  	    load_order,access_mode,majority,index,snmp,local_content,
        |  	    record_name,attributes,user_properties,frag_properties,
        |  	    cookie,version],
<font color=red>     0..|      rec2list(Tags, Orig, 2, Cs);</font>
        |  cs2list(ver4_6, Cs) -&gt;
<font color=red>     0..|      Orig = record_info(fields, cstruct),</font>
<font color=red>     0..|      Tags = [name,type,ram_copies,disc_copies,disc_only_copies,</font>
        |  	    load_order,access_mode,majority,index,snmp,local_content,
        |  	    record_name,attributes,
        |  	    user_properties,frag_properties,storage_properties,
        |  	    cookie,version],
<font color=red>     0..|      rec2list(Tags, Orig, 2, Cs).</font>
        |  
        |  
        |  rec2list([Tag | Tags], [Tag | Orig], Pos, Rec) -&gt;
  1512..|      Val = element(Pos, Rec),
  1512..|      [{Tag, Val} | rec2list(Tags, Orig, Pos + 1, Rec)];
        |  rec2list([], _, _Pos, _Rec) -&gt;
    84..|      [];
        |  rec2list(Tags, [_|Orig], Pos, Rec) -&gt;
<font color=red>     0..|      rec2list(Tags, Orig, Pos+1, Rec).</font>
        |  
        |  normalize_cs(Cstructs, Node) -&gt;
        |      %% backward-compatibility hack; normalize before returning
<font color=red>     0..|      case need_old_cstructs([Node]) of</font>
        |  	false -&gt;
<font color=red>     0..|  	    Cstructs;</font>
        |  	Version -&gt;
        |  	    %% some other format
<font color=red>     0..|  	    [convert_cs(Version, Cs) || Cs &lt;- Cstructs]</font>
        |      end.
        |  
        |  convert_cs(Version, Cs) -&gt;
<font color=red>     0..|      Fields = [Value || {_, Value} &lt;- cs2list(Version, Cs)],</font>
<font color=red>     0..|      list_to_tuple([cstruct|Fields]).</font>
        |  
        |  list2cs(List) when is_list(List) -&gt;
    42..|      Name = pick(unknown, name, List, must),
    42..|      Type = pick(Name, type, List, set),
    42..|      Rc0 = pick(Name, ram_copies, List, []),
    42..|      Dc = pick(Name, disc_copies, List, []),
    42..|      Doc = pick(Name, disc_only_copies, List, []),
    42..|      Rc = case {Rc0, Dc, Doc} of
<font color=red>     0..|               {[], [], []} -&gt; [node()];</font>
    42..|               _ -&gt; Rc0
        |           end,
    42..|      LC = pick(Name, local_content, List, false),
    42..|      RecName = pick(Name, record_name, List, Name),
    42..|      Attrs = pick(Name, attributes, List, [key, val]),
    42..|      Snmp = pick(Name, snmp, List, []),
    42..|      LoadOrder = pick(Name, load_order, List, 0),
    42..|      AccessMode = pick(Name, access_mode, List, read_write),
    42..|      Majority = pick(Name, majority, List, false),
    42..|      UserProps = pick(Name, user_properties, List, []),
    42..|      verify({alt, [nil, list]}, mnesia2_lib:etype(UserProps),
        |  	   {bad_type, Name, {user_properties, UserProps}}),
    42..|      Cookie = pick(Name, cookie, List, ?unique_cookie),
    42..|      Version = pick(Name, version, List, {{2, 0}, []}),
    42..|      Ix = pick(Name, index, List, []),
    42..|      verify({alt, [nil, list]}, mnesia2_lib:etype(Ix),
        |  	   {bad_type, Name, {index, [Ix]}}),
    42..|      Ix2 = [attr_to_pos(I, Attrs) || I &lt;- Ix],
        |  
    42..|      Frag = pick(Name, frag_properties, List, []),
    42..|      verify({alt, [nil, list]}, mnesia2_lib:etype(Frag),
        |  	   {badarg, Name, {frag_properties, Frag}}),
        |  
    42..|      BEProps = pick(Name, storage_properties, List, []),
    42..|      verify({alt, [nil, list]}, mnesia2_lib:etype(Ix),
        |  	   {badarg, Name, {storage_properties, BEProps}}),
    42..|      CheckProp = fun(Opt, Opts) when is_atom(Opt) -&gt;
<font color=red>     0..|  			lists:member(Opt, Opts)</font>
<font color=red>     0..|  			    andalso mnesia2:abort({badarg, Name, Opt});</font>
        |  		   (Tuple, Opts) when is_tuple(Tuple) -&gt;
<font color=red>     0..|  			lists:member(element(1,Tuple), Opts)</font>
<font color=red>     0..|  			    andalso mnesia2:abort({badarg, Name, Tuple});</font>
        |  		   (What,_) -&gt;
<font color=red>     0..|  			mnesia2:abort({badarg, Name, What})</font>
        |  		end,
    42..|      BadEtsOpts = [set, ordered_set, bag, duplicate_bag,
        |  		  public, private, protected,
        |  		  keypos, named_table],
    42..|      EtsOpts = proplists:get_value(ets, BEProps, []),
    42..|      is_list(EtsOpts) orelse mnesia2:abort({badarg, Name, {ets, EtsOpts}}),
    42..|      [CheckProp(Prop, BadEtsOpts) || Prop &lt;- EtsOpts],
    42..|      BadDetsOpts = [type, keypos, repair, access, file],
    42..|      DetsOpts = proplists:get_value(dets, BEProps, []),
    42..|      is_list(DetsOpts) orelse mnesia2:abort({badarg, Name, {dets, DetsOpts}}),
    42..|      [CheckProp(Prop, BadDetsOpts) || Prop &lt;- DetsOpts],
    42..|      #cstruct{name = Name,
        |               ram_copies = Rc,
        |               disc_copies = Dc,
        |               disc_only_copies = Doc,
        |               type = Type,
        |               index = Ix2,
        |               snmp = Snmp,
        |               load_order = LoadOrder,
        |               access_mode = AccessMode,
        |  	     majority = Majority,
        |               local_content = LC,
        |  	     record_name = RecName,
        |               attributes = Attrs,
        |               user_properties = lists:sort(UserProps),
        |  	     frag_properties = lists:sort(Frag),
        |  	     storage_properties = lists:sort(BEProps),
        |               cookie = Cookie,
        |               version = Version}.
        |  
        |  pick(Tab, Key, List, Default) -&gt;
   756..|      case lists:keysearch(Key, 1, List) of
        |          false  when Default == must -&gt;
<font color=red>     0..|              mnesia2:abort({badarg, Tab, "Missing key", Key, List});</font>
        |          false -&gt;
    84..|              Default;
        |          {value, {Key, Value}} -&gt;
   672..|              Value;
        |  	{value, BadArg} -&gt;
<font color=red>     0..|  	    mnesia2:abort({bad_type, Tab, BadArg})</font>
        |      end.
        |  
        |  %% Convert attribute name to integer if neccessary
        |  attr_tab_to_pos(_Tab, Pos) when is_integer(Pos) -&gt;
<font color=red>     0..|      Pos;</font>
        |  attr_tab_to_pos(Tab, Attr) -&gt;
<font color=red>     0..|      attr_to_pos(Attr, val({Tab, attributes})).</font>
        |  
        |  %% Convert attribute name to integer if neccessary
        |  attr_to_pos(Pos, _Attrs) when is_integer(Pos) -&gt;
<font color=red>     0..|      Pos;</font>
        |  attr_to_pos(Attr, Attrs) when is_atom(Attr) -&gt;
<font color=red>     0..|      attr_to_pos(Attr, Attrs, 2);</font>
        |  attr_to_pos(Attr, _) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, Attr}).</font>
        |  
        |  attr_to_pos(Attr, [Attr | _Attrs], Pos) -&gt;
<font color=red>     0..|      Pos;</font>
        |  attr_to_pos(Attr, [_ | Attrs], Pos) -&gt;
<font color=red>     0..|      attr_to_pos(Attr, Attrs, Pos + 1);</font>
        |  attr_to_pos(Attr, _, _) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, Attr}).</font>
        |  
        |  check_keys(Tab, [{Key, _Val} | Tail], Items) -&gt;
<font color=red>     0..|      case lists:member(Key, Items) of</font>
<font color=red>     0..|          true -&gt;  [Key | check_keys(Tab, Tail, Items)];</font>
<font color=red>     0..|          false -&gt; mnesia2:abort({badarg, Tab, Key})</font>
        |      end;
        |  check_keys(_, [], _) -&gt;
<font color=red>     0..|      [];</font>
        |  check_keys(Tab, Arg, _) -&gt;
<font color=red>     0..|      mnesia2:abort({badarg, Tab, Arg}).</font>
        |  
        |  check_duplicates(Tab, Keys) -&gt;
<font color=red>     0..|      case has_duplicates(Keys) of</font>
<font color=red>     0..|          false -&gt; ok;</font>
<font color=red>     0..|          true -&gt; mnesia2:abort({badarg, Tab, "Duplicate keys", Keys})</font>
        |      end.
        |  
        |  has_duplicates([H | T]) -&gt;
<font color=red>     0..|      case lists:member(H, T) of</font>
<font color=red>     0..|          true -&gt; true;</font>
<font color=red>     0..|          false -&gt; has_duplicates(T)</font>
        |      end;
        |  has_duplicates([]) -&gt;
<font color=red>     0..|      false.</font>
        |  
        |  %% This is the only place where we check the validity of data
        |  verify_cstruct(Cs) when is_record(Cs, cstruct) -&gt;
<font color=red>     0..|      verify_nodes(Cs),</font>
        |  
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      verify(atom, mnesia2_lib:etype(Tab), {bad_type, Tab}),</font>
<font color=red>     0..|      Type = Cs#cstruct.type,</font>
<font color=red>     0..|      verify(true, lists:member(Type, [set, bag, ordered_set]),</font>
        |  	   {bad_type, Tab, {type, Type}}),
        |  
        |      %% Currently ordered_set is not supported for disk_only_copies.
<font color=red>     0..|      if</font>
        |   	Type == ordered_set, Cs#cstruct.disc_only_copies /= [] -&gt;
<font color=red>     0..|  	    mnesia2:abort({bad_type, Tab, {not_supported, Type, disc_only_copies}});</font>
        |  	true -&gt;
<font color=red>     0..|  	    ok</font>
        |      end,
        |  
<font color=red>     0..|      RecName = Cs#cstruct.record_name,</font>
<font color=red>     0..|      verify(atom, mnesia2_lib:etype(RecName),</font>
        |  	   {bad_type, Tab, {record_name, RecName}}),
        |  
<font color=red>     0..|      Attrs = Cs#cstruct.attributes,</font>
<font color=red>     0..|      verify(list, mnesia2_lib:etype(Attrs),</font>
        |  	   {bad_type, Tab, {attributes, Attrs}}),
        |  
<font color=red>     0..|      Arity = length(Attrs) + 1,</font>
<font color=red>     0..|      verify(true, Arity &gt; 2, {bad_type, Tab, {attributes, Attrs}}),</font>
        |  
<font color=red>     0..|      lists:foldl(fun(Attr,_Other) when Attr == snmp -&gt;</font>
<font color=red>     0..|                          mnesia2:abort({bad_type, Tab, {attributes, [Attr]}});</font>
        |                     (Attr,Other) -&gt;
<font color=red>     0..|                          verify(atom, mnesia2_lib:etype(Attr),</font>
        |                                 {bad_type, Tab, {attributes, [Attr]}}),
<font color=red>     0..|                          verify(false, lists:member(Attr, Other),</font>
        |                                 {combine_error, Tab, {attributes, [Attr | Other]}}),
<font color=red>     0..|                          [Attr | Other]</font>
        |                  end,
        |                  [],
        |                  Attrs),
        |  
<font color=red>     0..|      Index = Cs#cstruct.index,</font>
<font color=red>     0..|      verify({alt, [nil, list]}, mnesia2_lib:etype(Index),</font>
        |  	   {bad_type, Tab, {index, Index}}),
        |  
<font color=red>     0..|      IxFun =</font>
        |          fun(Pos) -&gt;
<font color=red>     0..|                  verify(true, fun() -&gt;</font>
<font color=red>     0..|                                       if</font>
        |  					 is_integer(Pos),
        |                                           Pos &gt; 2,
        |                                           Pos =&lt; Arity -&gt;
<font color=red>     0..|                                               true;</font>
<font color=red>     0..|                                           true -&gt; false</font>
        |                                       end
        |                               end,
        |                         {bad_type, Tab, {index, [Pos]}})
        |          end,
<font color=red>     0..|      lists:foreach(IxFun, Index),</font>
        |  
<font color=red>     0..|      LC = Cs#cstruct.local_content,</font>
<font color=red>     0..|      verify({alt, [true, false]}, LC,</font>
        |  	   {bad_type, Tab, {local_content, LC}}),
<font color=red>     0..|      Access = Cs#cstruct.access_mode,</font>
<font color=red>     0..|      verify({alt, [read_write, read_only]}, Access,</font>
        |  	   {bad_type, Tab, {access_mode, Access}}),
<font color=red>     0..|      Majority = Cs#cstruct.majority,</font>
<font color=red>     0..|      verify({alt, [true, false]}, Majority,</font>
        |  	   {bad_type, Tab, {majority, Majority}}),
<font color=red>     0..|      case Majority of</font>
        |  	true -&gt;
<font color=red>     0..|  	    verify(false, LC,</font>
        |  		   {combine_error, Tab, [{local_content,true},{majority,true}]});
        |  	false -&gt;
<font color=red>     0..|  	    ok</font>
        |      end,
<font color=red>     0..|      Snmp = Cs#cstruct.snmp,</font>
<font color=red>     0..|      verify(true, mnesia2_snmp_hook:check_ustruct(Snmp),</font>
        |  	   {badarg, Tab, {snmp, Snmp}}),
        |  
<font color=red>     0..|      CheckProp = fun(Prop) when is_tuple(Prop), size(Prop) &gt;= 1 -&gt; ok;</font>
<font color=red>     0..|  		   (Prop) -&gt; mnesia2:abort({bad_type, Tab, {user_properties, [Prop]}})</font>
        |  		end,
<font color=red>     0..|      lists:foreach(CheckProp, Cs#cstruct.user_properties),</font>
        |  
<font color=red>     0..|      case Cs#cstruct.cookie of</font>
        |  	{{MegaSecs, Secs, MicroSecs}, _Node}
        |  	when is_integer(MegaSecs), is_integer(Secs),
        |  	     is_integer(MicroSecs), is_atom(node) -&gt;
<font color=red>     0..|              ok;</font>
        |          Cookie -&gt;
<font color=red>     0..|              mnesia2:abort({bad_type, Tab, {cookie, Cookie}})</font>
        |      end,
<font color=red>     0..|      case Cs#cstruct.version of</font>
        |          {{Major, Minor}, _Detail}
        |                  when is_integer(Major), is_integer(Minor) -&gt;
<font color=red>     0..|              ok;</font>
        |          Version -&gt;
<font color=red>     0..|              mnesia2:abort({bad_type, Tab, {version, Version}})</font>
        |      end.
        |  
        |  verify_nodes(Cs) -&gt;
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      Ram = Cs#cstruct.ram_copies,</font>
<font color=red>     0..|      Disc = Cs#cstruct.disc_copies,</font>
<font color=red>     0..|      DiscOnly = Cs#cstruct.disc_only_copies,</font>
<font color=red>     0..|      LoadOrder = Cs#cstruct.load_order,</font>
        |  
<font color=red>     0..|      verify({alt, [nil, list]}, mnesia2_lib:etype(Ram),</font>
        |  	   {bad_type, Tab, {ram_copies, Ram}}),
<font color=red>     0..|      verify({alt, [nil, list]}, mnesia2_lib:etype(Disc),</font>
        |  	   {bad_type, Tab, {disc_copies, Disc}}),
<font color=red>     0..|      case Tab of</font>
        |  	schema -&gt;
<font color=red>     0..|  	    verify([], DiscOnly, {bad_type, Tab, {disc_only_copies, DiscOnly}});</font>
        |  	_ -&gt;
<font color=red>     0..|  	    verify({alt, [nil, list]},</font>
        |  		   mnesia2_lib:etype(DiscOnly),
        |  		   {bad_type, Tab, {disc_only_copies, DiscOnly}})
        |      end,
<font color=red>     0..|      verify(integer, mnesia2_lib:etype(LoadOrder),</font>
        |  	   {bad_type, Tab, {load_order, LoadOrder}}),
        |  
<font color=red>     0..|      Nodes = Ram ++ Disc ++ DiscOnly,</font>
<font color=red>     0..|      verify(list, mnesia2_lib:etype(Nodes),</font>
        |  	   {combine_error, Tab,
        |  	    [{ram_copies, []}, {disc_copies, []}, {disc_only_copies, []}]}),
<font color=red>     0..|      verify(false, has_duplicates(Nodes), {combine_error, Tab, Nodes}),</font>
<font color=red>     0..|      AtomCheck = fun(N) -&gt; verify(atom, mnesia2_lib:etype(N), {bad_type, Tab, N}) end,</font>
<font color=red>     0..|      lists:foreach(AtomCheck, Nodes).</font>
        |  
        |  verify(Expected, Fun, Error) when is_function(Fun) -&gt;
<font color=red>     0..|      do_verify(Expected, catch Fun(), Error);</font>
        |  verify(Expected, Actual, Error) -&gt;
   168..|      do_verify(Expected, Actual, Error).
        |  
        |  do_verify({alt, Values}, Value, Error) -&gt;
   168..|      case lists:member(Value, Values) of
   168..|          true -&gt; ok;
<font color=red>     0..|          false -&gt; mnesia2:abort(Error)</font>
        |      end;
        |  do_verify(Value, Value, _) -&gt;
<font color=red>     0..|      ok;</font>
        |  do_verify(_Value, _, Error) -&gt;
<font color=red>     0..|       mnesia2:abort(Error).</font>
        |  
        |  ensure_writable(Tab) -&gt;
<font color=red>     0..|      case val({Tab, where_to_write}) of</font>
<font color=red>     0..|          [] -&gt; mnesia2:abort({read_only, Tab});</font>
<font color=red>     0..|          _ -&gt; ok</font>
        |      end.
        |  
        |  %% Ensure that all replicas on disk full nodes are active
        |  ensure_active(Cs) -&gt;
<font color=red>     0..|      ensure_active(Cs, active_replicas).</font>
        |  
        |  ensure_active(Cs, What) -&gt;
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      W = {Tab, What},</font>
<font color=red>     0..|      ensure_non_empty(W),</font>
<font color=red>     0..|      Nodes = mnesia2_lib:intersect(val({schema, disc_copies}),</font>
        |                                   mnesia2_lib:cs_to_nodes(Cs)),
<font color=red>     0..|      case Nodes -- val(W) of</font>
        |          [] -&gt;
<font color=red>     0..|              ok;</font>
        |          Ns -&gt;
<font color=red>     0..|              Expl = "All replicas on diskfull nodes are not active yet",</font>
<font color=red>     0..|              case val({Tab, local_content}) of</font>
        |                  true -&gt;
<font color=red>     0..|  		    case rpc:multicall(Ns, ?MODULE, is_remote_member, [W]) of</font>
        |  			{Replies, []} -&gt;
<font color=red>     0..|  			    check_active(Replies, Expl, Tab);</font>
        |  			{_Replies, BadNs} -&gt;
<font color=red>     0..|  			    mnesia2:abort({not_active, Expl, Tab, BadNs})</font>
        |                      end;
        |                  false -&gt;
<font color=red>     0..|                      mnesia2:abort({not_active, Expl, Tab, Ns})</font>
        |              end
        |      end.
        |  
        |  ensure_non_empty({Tab, Vhat}) -&gt;
<font color=red>     0..|         case val({Tab, Vhat}) of</font>
<font color=red>     0..|          [] -&gt; mnesia2:abort({no_exists, Tab});</font>
<font color=red>     0..|          _ -&gt; ok</font>
        |      end.
        |  
        |  ensure_not_active(Tab = schema, Node) -&gt;
<font color=red>     0..|      Active = val({Tab, active_replicas}),</font>
<font color=red>     0..|      case lists:member(Node, Active) of</font>
        |  	false when Active =/= [] -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	false -&gt;
<font color=red>     0..|  	    mnesia2:abort({no_exists, Tab});</font>
        |  	true -&gt;
<font color=red>     0..|  	    Expl = "Mnesia2 is running",</font>
<font color=red>     0..|  	    mnesia2:abort({active, Expl, Node})</font>
        |      end.
        |  
        |  is_remote_member(Key) -&gt;
<font color=red>     0..|      IsActive = lists:member(node(), val(Key)),</font>
<font color=red>     0..|      {IsActive, node()}.</font>
        |  
        |  check_active([{true, _Node} | Replies], Expl, Tab) -&gt;
<font color=red>     0..|      check_active(Replies, Expl, Tab);</font>
        |  check_active([{false, Node} | _Replies], Expl, Tab) -&gt;
<font color=red>     0..|      mnesia2:abort({not_active, Expl, Tab, [Node]});</font>
        |  check_active([{badrpc, Reason} | _Replies], Expl, Tab) -&gt;
<font color=red>     0..|      mnesia2:abort({not_active, Expl, Tab, Reason});</font>
        |  check_active([], _Expl, _Tab) -&gt;
<font color=red>     0..|      ok.</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Here's the real interface function to create a table
        |  
        |  create_table(TabDef) -&gt;
    11..|      schema_transaction(fun() -&gt; do_multi_create_table(TabDef) end).
        |  
        |  %% And the corresponding do routines ....
        |  
        |  do_multi_create_table(TabDef) -&gt;
<font color=red>     0..|      get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = api_list2cs(TabDef),</font>
<font color=red>     0..|      case Cs#cstruct.frag_properties of</font>
        |  	[] -&gt;
<font color=red>     0..|  	    do_create_table(Cs);</font>
        |  	_Props -&gt;
<font color=red>     0..|  	    CsList = mnesia2_frag:expand_cstruct(Cs),</font>
<font color=red>     0..|  	    lists:foreach(fun do_create_table/1, CsList)</font>
        |      end,
<font color=red>     0..|      ok.</font>
        |  
        |  do_create_table(Cs) -&gt;
<font color=red>     0..|      {_Mod, _Tid, Ts} =  get_tid_ts_and_lock(schema, none),</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
<font color=red>     0..|      do_insert_schema_ops(Store, make_create_table(Cs)).</font>
        |  
        |  make_create_table(Cs) -&gt;
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      verify(false, check_if_exists(Tab), {already_exists, Tab}),</font>
<font color=red>     0..|      unsafe_make_create_table(Cs).</font>
        |  
        |  % unsafe_do_create_table(Cs) -&gt;
        |  %     {_Mod, Tid, Ts} =  get_tid_ts_and_lock(schema, none),
        |  %     Store = Ts#tidstore.store,
        |  %     do_insert_schema_ops(Store, unsafe_make_create_table(Cs)).
        |  
        |  unsafe_make_create_table(Cs) -&gt;
<font color=red>     0..|      {_Mod, Tid, Ts} =  get_tid_ts_and_lock(schema, none),</font>
<font color=red>     0..|      verify_cstruct(Cs),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
        |  
        |      %% Check that we have all disc replica nodes running
<font color=red>     0..|      DiscNodes = Cs#cstruct.disc_copies ++ Cs#cstruct.disc_only_copies,</font>
<font color=red>     0..|      RunningNodes = val({current, db_nodes}),</font>
<font color=red>     0..|      CheckDisc = fun(N) -&gt;</font>
<font color=red>     0..|  			verify(true, lists:member(N, RunningNodes),</font>
        |  			       {not_active, Tab, N})
        |  		end,
<font color=red>     0..|      lists:foreach(CheckDisc, DiscNodes),</font>
        |  
<font color=red>     0..|      Nodes = mnesia2_lib:intersect(mnesia2_lib:cs_to_nodes(Cs), RunningNodes),</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
<font color=red>     0..|      mnesia2_locker:wlock_no_exist(Tid, Store, Tab, Nodes),</font>
<font color=red>     0..|      [{op, create_table, vsn_cs2list(Cs)}].</font>
        |  
        |  check_if_exists(Tab) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      {_, _, Ts} = TidTs,</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
<font color=red>     0..|      ets:foldl(</font>
        |        fun({op, create_table, [{name, T}|_]}, _Acc) when T==Tab -&gt;
<font color=red>     0..|  	      true;</font>
        |  	 ({op, delete_table, [{name,T}|_]}, _Acc) when T==Tab -&gt;
<font color=red>     0..|  	      false;</font>
        |  	 (_Other, Acc) -&gt;
<font color=red>     0..|  	      Acc</font>
        |        end, existed_before(Tab), Store).
        |  
        |  existed_before(Tab) -&gt;
<font color=red>     0..|      ('EXIT' =/= element(1, ?catch_val({Tab,cstruct}))).</font>
        |  
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Delete a table entirely on all nodes.
        |  
        |  delete_table(Tab) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_delete_table(Tab) end).</font>
        |  
        |  do_delete_table(schema) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_delete_table(Tab) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_delete_table(Tab, whole_table)).</font>
        |  
        |  make_delete_table(Tab, Mode) -&gt;
<font color=red>     0..|      case existed_before(Tab) of</font>
        |  	false -&gt;
        |  	    %% Deleting a table that was created in this very
        |  	    %% schema transaction. Delete all ops in the Store
        |  	    %% that operate on this table. We cannot run a normal
        |  	    %% delete operation, since that involves checking live
        |  	    %% nodes etc.
<font color=red>     0..|  	    TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|  	    {_, _, Ts} = TidTs,</font>
<font color=red>     0..|  	    Store = Ts#tidstore.store,</font>
<font color=red>     0..|  	    Deleted = ets:select_delete(</font>
        |  			Store, [{{op,'$1',[{name,Tab}|'_']},
        |  				 [{'or',
        |  				   {'==','$1',create_table},
        |  				   {'==','$1',delete_table}}], [true]}]),
<font color=red>     0..|  	    ets:select_delete(</font>
        |  	      Store, [{{op,'$1',[{name,Tab}|'_'],'_'},
        |  		       [{'or',
        |  			 {'==','$1',write_table_property},
        |  			 {'==','$1',delete_table_property}}],
        |  		       [true]}]),
<font color=red>     0..|  	    case Deleted of</font>
<font color=red>     0..|  		0 -&gt; mnesia2:abort({no_exists, Tab});</font>
<font color=red>     0..|  		_ -&gt; []</font>
        |  	    end;
        |  	true -&gt;
<font color=red>     0..|  	    case Mode of</font>
        |  		whole_table -&gt;
<font color=red>     0..|  		    case val({Tab, frag_properties}) of</font>
        |  			[] -&gt;
<font color=red>     0..|  			    [make_delete_table2(Tab)];</font>
        |  			_Props -&gt;
        |  			    %% Check if it is a base table
<font color=red>     0..|  			    mnesia2_frag:lookup_frag_hash(Tab),</font>
        |  
        |  			    %% Check for foreigners
<font color=red>     0..|  			    F = mnesia2_frag:lookup_foreigners(Tab),</font>
<font color=red>     0..|  			    verify([], F, {combine_error,</font>
        |  					   Tab, "Too many foreigners", F}),
<font color=red>     0..|  			    [make_delete_table2(T) ||</font>
<font color=red>     0..|  				T &lt;- mnesia2_frag:frag_names(Tab)]</font>
        |  		    end;
        |  		single_frag -&gt;
<font color=red>     0..|  		    [make_delete_table2(Tab)]</font>
        |  	    end
        |      end.
        |  
        |  make_delete_table2(Tab) -&gt;
<font color=red>     0..|      get_tid_ts_and_lock(Tab, write),</font>
<font color=red>     0..|      Cs = val({Tab, cstruct}),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      ensure_writable(Tab),</font>
<font color=red>     0..|      {op, delete_table, vsn_cs2list(Cs)}.</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Change fragmentation of a table
        |  
        |  change_table_frag(Tab, Change) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_change_table_frag(Tab, Change) end).</font>
        |  
        |  do_change_table_frag(Tab, Change) when is_atom(Tab), Tab /= schema -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      Ops = mnesia2_frag:change_table_frag(Tab, Change),</font>
<font color=red>     0..|      [insert_schema_ops(TidTs, Op) || Op &lt;- Ops],</font>
<font color=red>     0..|      ok;</font>
        |  do_change_table_frag(Tab, _Change) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, Tab}).</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Clear a table
        |  
        |  do_clear_table(schema) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_clear_table(Tab) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, write),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_clear_table(Tab)).</font>
        |  
        |  make_clear_table(Tab) -&gt;
<font color=red>     0..|      Cs = val({Tab, cstruct}),</font>
<font color=red>     0..|      ensure_writable(Tab),</font>
<font color=red>     0..|      [{op, clear_table, vsn_cs2list(Cs)}].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  add_table_copy(Tab, Node, Storage) -&gt;
     6..|      schema_transaction(fun() -&gt; do_add_table_copy(Tab, Node, Storage) end).
        |  
        |  do_add_table_copy(Tab, Node, Storage) when is_atom(Tab), is_atom(Node) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_add_table_copy(Tab, Node, Storage));</font>
        |  do_add_table_copy(Tab,Node,_) -&gt;
<font color=red>     0..|      mnesia2:abort({badarg, Tab, Node}).</font>
        |  
        |  make_add_table_copy(Tab, Node, Storage) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      Ns = mnesia2_lib:cs_to_nodes(Cs),</font>
<font color=red>     0..|      verify(false, lists:member(Node, Ns), {already_exists, Tab, Node}),</font>
<font color=red>     0..|      Cs2 = new_cs(Cs, Node, Storage, add),</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
        |  
        |      %% Check storage and if node is running
<font color=red>     0..|      IsRunning = lists:member(Node, val({current, db_nodes})),</font>
<font color=red>     0..|      if</font>
        |  	Tab == schema -&gt;
<font color=red>     0..|  	    if</font>
        |  		Storage /= ram_copies -&gt;
<font color=red>     0..|  		    mnesia2:abort({badarg, Tab, Storage});</font>
        |  		IsRunning == true -&gt;
<font color=red>     0..|  		    mnesia2:abort({already_exists, Tab, Node});</font>
        |  		true -&gt;
<font color=red>     0..|  		    ignore</font>
        |  	    end;
        |  	Storage == ram_copies -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	IsRunning == true -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	IsRunning == false -&gt;
<font color=red>     0..|  	    mnesia2:abort({not_active, schema, Node})</font>
        |      end,
<font color=red>     0..|      [{op, add_table_copy, Storage, Node, vsn_cs2list(Cs2)}].</font>
        |  
        |  del_table_copy(Tab, Node) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_del_table_copy(Tab, Node) end).</font>
        |  
        |  do_del_table_copy(Tab, Node) when is_atom(Node)  -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
        |  %%    get_tid_ts_and_lock(Tab, write),
<font color=red>     0..|      insert_schema_ops(TidTs, make_del_table_copy(Tab, Node));</font>
        |  do_del_table_copy(Tab, Node) -&gt;
<font color=red>     0..|      mnesia2:abort({badarg, Tab, Node}).</font>
        |  
        |  make_del_table_copy(Tab, Node) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      Storage = mnesia2_lib:schema_cs_to_storage_type(Node, Cs),</font>
<font color=red>     0..|      Cs2 = new_cs(Cs, Node, Storage, del),</font>
<font color=red>     0..|      case mnesia2_lib:cs_to_nodes(Cs2) of</font>
        |          [] when Tab == schema -&gt;
<font color=red>     0..|              mnesia2:abort({combine_error, Tab, "Last replica"});</font>
        |          [] -&gt;
<font color=red>     0..|  	    ensure_active(Cs),</font>
<font color=red>     0..|              dbg_out("Last replica deleted in table ~p~n",  [Tab]),</font>
<font color=red>     0..|              make_delete_table(Tab,  whole_table);</font>
        |          _ when Tab == schema -&gt;
        |  	    %% ensure_active(Cs2),
<font color=red>     0..|  	    ensure_not_active(Tab, Node),</font>
<font color=red>     0..|              verify_cstruct(Cs2),</font>
<font color=red>     0..|  	    Ops = remove_node_from_tabs(val({schema, tables}), Node),</font>
<font color=red>     0..|  	    [{op, del_table_copy, ram_copies, Node, vsn_cs2list(Cs2)} | Ops];</font>
        |          _ -&gt;
<font color=red>     0..|  	    ensure_active(Cs),</font>
<font color=red>     0..|              verify_cstruct(Cs2),</font>
<font color=red>     0..|          get_tid_ts_and_lock(Tab, write),</font>
<font color=red>     0..|              [{op, del_table_copy, Storage, Node, vsn_cs2list(Cs2)}]</font>
        |      end.
        |  
        |  remove_node_from_tabs([], _Node) -&gt;
<font color=red>     0..|      [];</font>
        |  remove_node_from_tabs([schema|Rest], Node) -&gt;
<font color=red>     0..|      remove_node_from_tabs(Rest, Node);</font>
        |  remove_node_from_tabs([Tab|Rest], Node) -&gt;
<font color=red>     0..|      {Cs, IsFragModified} =</font>
        |  	mnesia2_frag:remove_node(Node, incr_version(val({Tab, cstruct}))),
<font color=red>     0..|      case mnesia2_lib:schema_cs_to_storage_type(Node, Cs)  of</font>
        |  	unknown -&gt;
<font color=red>     0..|  	    case IsFragModified of</font>
        |  		true -&gt;
<font color=red>     0..|  		    [{op, change_table_frag, {del_node, Node}, vsn_cs2list(Cs)} |</font>
        |  		     remove_node_from_tabs(Rest, Node)];
        |  		false -&gt;
<font color=red>     0..|  		    remove_node_from_tabs(Rest, Node)</font>
        |  	    end;
        |  	Storage -&gt;
<font color=red>     0..|  	    Cs2 = new_cs(Cs, Node, Storage, del),</font>
<font color=red>     0..|  	    case mnesia2_lib:cs_to_nodes(Cs2) of</font>
        |  		[] -&gt;
<font color=red>     0..|  		    [{op, delete_table, vsn_cs2list(Cs)} |</font>
        |  		     remove_node_from_tabs(Rest, Node)];
        |  		_Ns -&gt;
<font color=red>     0..|  		    verify_cstruct(Cs2),</font>
<font color=red>     0..|              get_tid_ts_and_lock(Tab, write),</font>
<font color=red>     0..|  		    [{op, del_table_copy, ram_copies, Node, vsn_cs2list(Cs2)}|</font>
        |  		     remove_node_from_tabs(Rest, Node)]
        |  	    end
        |      end.
        |  
        |  new_cs(Cs, Node, ram_copies, add) -&gt;
<font color=red>     0..|      Cs#cstruct{ram_copies = opt_add(Node, Cs#cstruct.ram_copies)};</font>
        |  new_cs(Cs, Node, disc_copies, add) -&gt;
<font color=red>     0..|      Cs#cstruct{disc_copies = opt_add(Node, Cs#cstruct.disc_copies)};</font>
        |  new_cs(Cs, Node, disc_only_copies, add) -&gt;
<font color=red>     0..|      Cs#cstruct{disc_only_copies = opt_add(Node, Cs#cstruct.disc_only_copies)};</font>
        |  new_cs(Cs, Node, ram_copies, del) -&gt;
<font color=red>     0..|      Cs#cstruct{ram_copies = lists:delete(Node , Cs#cstruct.ram_copies)};</font>
        |  new_cs(Cs, Node, disc_copies, del) -&gt;
<font color=red>     0..|      Cs#cstruct{disc_copies = lists:delete(Node , Cs#cstruct.disc_copies)};</font>
        |  new_cs(Cs, Node, disc_only_copies, del) -&gt;
<font color=red>     0..|      Cs#cstruct{disc_only_copies =</font>
        |                 lists:delete(Node , Cs#cstruct.disc_only_copies)};
        |  new_cs(Cs, _Node, Storage, _Op) -&gt;
<font color=red>     0..|      mnesia2:abort({badarg, Cs#cstruct.name, Storage}).</font>
        |  
        |  
<font color=red>     0..|  opt_add(N, L) -&gt; [N | lists:delete(N, L)].</font>
        |  
        |  move_table(Tab, FromNode, ToNode) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_move_table(Tab, FromNode, ToNode) end).</font>
        |  
        |  do_move_table(schema, _FromNode, _ToNode) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_move_table(Tab, FromNode, ToNode) when is_atom(FromNode), is_atom(ToNode) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
        |      %% get_tid_ts_and_lock(Tab, write), write locked by load_table in mnesia2_loader
<font color=red>     0..|      insert_schema_ops(TidTs, make_move_table(Tab, FromNode, ToNode));</font>
        |  do_move_table(Tab, FromNode, ToNode) -&gt;
<font color=red>     0..|      mnesia2:abort({badarg, Tab, FromNode, ToNode}).</font>
        |  
        |  make_move_table(Tab, FromNode, ToNode) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      Ns = mnesia2_lib:cs_to_nodes(Cs),</font>
<font color=red>     0..|      verify(false, lists:member(ToNode, Ns), {already_exists, Tab, ToNode}),</font>
<font color=red>     0..|      verify(true, lists:member(FromNode, val({Tab, where_to_write})),</font>
        |             {not_active, Tab, FromNode}),
<font color=red>     0..|      verify(false, val({Tab,local_content}),</font>
        |             {"Cannot move table with local content", Tab}),
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      Running = val({current, db_nodes}),</font>
<font color=red>     0..|      Storage = mnesia2_lib:schema_cs_to_storage_type(FromNode, Cs),</font>
<font color=red>     0..|      verify(true, lists:member(ToNode, Running), {not_active, schema, ToNode}),</font>
        |  
<font color=red>     0..|      Cs2 = new_cs(Cs, ToNode, Storage, add),</font>
<font color=red>     0..|      Cs3 = new_cs(Cs2, FromNode, Storage, del),</font>
<font color=red>     0..|      verify_cstruct(Cs3),</font>
<font color=red>     0..|      [{op, add_table_copy, Storage, ToNode, vsn_cs2list(Cs2)},</font>
        |       {op, sync_trans},
        |       {op, del_table_copy, Storage, FromNode, vsn_cs2list(Cs3)}].
        |  
        |  %% end of functions to add and delete nodes to tables
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%
        |  
        |  change_table_copy_type(Tab, Node, ToS) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_change_table_copy_type(Tab, Node, ToS) end).</font>
        |  
        |  do_change_table_copy_type(Tab, Node, ToS) when is_atom(Node) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, write), % ensure global sync</font>
        |      %% get_tid_ts_and_lock(Tab, read),
<font color=red>     0..|      insert_schema_ops(TidTs, make_change_table_copy_type(Tab, Node, ToS));</font>
        |  do_change_table_copy_type(Tab, Node, _ToS) -&gt;
<font color=red>     0..|      mnesia2:abort({badarg, Tab, Node}).</font>
        |  
        |  make_change_table_copy_type(Tab, Node, unknown) -&gt;
<font color=red>     0..|      make_del_table_copy(Tab, Node);</font>
        |  make_change_table_copy_type(Tab, Node, ToS) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      FromS = mnesia2_lib:storage_type_at_node(Node, Tab),</font>
        |  
<font color=red>     0..|      case compare_storage_type(false, FromS, ToS) of</font>
        |  	{same, _} -&gt;
<font color=red>     0..|  	    mnesia2:abort({already_exists, Tab, Node, ToS});</font>
        |  	{diff, _} -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	incompatible -&gt;
<font color=red>     0..|  	    ensure_active(Cs)</font>
        |      end,
        |  
<font color=red>     0..|      Cs2 = new_cs(Cs, Node, FromS, del),</font>
<font color=red>     0..|      Cs3 = new_cs(Cs2, Node, ToS, add),</font>
<font color=red>     0..|      verify_cstruct(Cs3),</font>
        |  
<font color=red>     0..|      [{op, change_table_copy_type, Node, FromS, ToS, vsn_cs2list(Cs3)}].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% change index functions ....
        |  %% Pos is allready added by 1 in both of these functions
        |  
        |  add_table_index(Tab, Pos) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_add_table_index(Tab, Pos) end).</font>
        |  
        |  do_add_table_index(schema, _Attr) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_add_table_index(Tab, Attr) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, read),</font>
<font color=red>     0..|      Pos = attr_tab_to_pos(Tab, Attr),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_add_table_index(Tab, Pos)).</font>
        |  
        |  make_add_table_index(Tab, Pos) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      Ix = Cs#cstruct.index,</font>
<font color=red>     0..|      verify(false, lists:member(Pos, Ix), {already_exists, Tab, Pos}),</font>
<font color=red>     0..|      Ix2 = lists:sort([Pos | Ix]),</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{index = Ix2},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, add_index, Pos, vsn_cs2list(Cs2)}].</font>
        |  
        |  del_table_index(Tab, Pos) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_del_table_index(Tab, Pos) end).</font>
        |  
        |  do_del_table_index(schema, _Attr) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_del_table_index(Tab, Attr) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, read),</font>
<font color=red>     0..|      Pos = attr_tab_to_pos(Tab, Attr),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_del_table_index(Tab, Pos)).</font>
        |  
        |  make_del_table_index(Tab, Pos) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      Ix = Cs#cstruct.index,</font>
<font color=red>     0..|      verify(true, lists:member(Pos, Ix), {no_exists, Tab, Pos}),</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{index = lists:delete(Pos, Ix)},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, del_index, Pos, vsn_cs2list(Cs2)}].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  add_snmp(Tab, Ustruct) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_add_snmp(Tab, Ustruct) end).</font>
        |  
        |  do_add_snmp(schema, _Ustruct) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_add_snmp(Tab, Ustruct) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, read),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_add_snmp(Tab, Ustruct)).</font>
        |  
        |  make_add_snmp(Tab, Ustruct) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      verify([], Cs#cstruct.snmp, {already_exists, Tab, snmp}),</font>
<font color=red>     0..|      Error = {badarg, Tab, snmp, Ustruct},</font>
<font color=red>     0..|      verify(true, mnesia2_snmp_hook:check_ustruct(Ustruct), Error),</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{snmp = Ustruct},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, add_snmp, Ustruct, vsn_cs2list(Cs2)}].</font>
        |  
        |  del_snmp(Tab) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_del_snmp(Tab) end).</font>
        |  
        |  do_del_snmp(schema) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_del_snmp(Tab) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, read),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_del_snmp(Tab)).</font>
        |  
        |  make_del_snmp(Tab) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{snmp = []},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, del_snmp, vsn_cs2list(Cs2)}].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%
        |  
        |  transform_table(Tab, Fun, NewAttrs, NewRecName)
        |    when is_function(Fun), is_list(NewAttrs), is_atom(NewRecName) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_transform_table(Tab, Fun, NewAttrs, NewRecName) end);</font>
        |  
        |  transform_table(Tab, ignore, NewAttrs, NewRecName)
        |    when is_list(NewAttrs), is_atom(NewRecName) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_transform_table(Tab, ignore, NewAttrs, NewRecName) end);</font>
        |  
        |  transform_table(Tab, Fun, NewAttrs, NewRecName) -&gt;
<font color=red>     0..|      {aborted,{bad_type, Tab, Fun, NewAttrs, NewRecName}}.</font>
        |  
        |  do_transform_table(schema, _Fun, _NewAttrs, _NewRecName) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_transform_table(Tab, Fun, NewAttrs, NewRecName) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, write),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_transform(Tab, Fun, NewAttrs, NewRecName)).</font>
        |  
        |  make_transform(Tab, Fun, NewAttrs, NewRecName) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      ensure_writable(Tab),</font>
<font color=red>     0..|      case mnesia2_lib:val({Tab, index}) of</font>
        |  	[] -&gt;
<font color=red>     0..|  	    Cs2 = Cs#cstruct{attributes = NewAttrs, record_name = NewRecName},</font>
<font color=red>     0..|  	    verify_cstruct(Cs2),</font>
<font color=red>     0..|  	    [{op, transform, Fun, vsn_cs2list(Cs2)}];</font>
        |  	PosList -&gt;
<font color=red>     0..|  	    DelIdx = fun(Pos, Ncs) -&gt;</font>
<font color=red>     0..|  			     Ix = Ncs#cstruct.index,</font>
<font color=red>     0..|  			     Ncs1 = Ncs#cstruct{index = lists:delete(Pos, Ix)},</font>
<font color=red>     0..|  			     Op = {op, del_index, Pos, vsn_cs2list(Ncs1)},</font>
<font color=red>     0..|  			     {Op, Ncs1}</font>
        |  		     end,
<font color=red>     0..|  	    AddIdx = fun(Pos, Ncs) -&gt;</font>
<font color=red>     0..|  			     Ix = Ncs#cstruct.index,</font>
<font color=red>     0..|  			     Ix2 = lists:sort([Pos | Ix]),</font>
<font color=red>     0..|  			     Ncs1 = Ncs#cstruct{index = Ix2},</font>
<font color=red>     0..|  			     Op = {op, add_index, Pos, vsn_cs2list(Ncs1)},</font>
<font color=red>     0..|  			     {Op, Ncs1}</font>
        |  		     end,
<font color=red>     0..|              {DelOps, Cs1} = lists:mapfoldl(DelIdx, Cs, PosList),</font>
<font color=red>     0..|  	    Cs2 = Cs1#cstruct{attributes = NewAttrs, record_name = NewRecName},</font>
<font color=red>     0..|              {AddOps, Cs3} = lists:mapfoldl(AddIdx, Cs2, PosList),</font>
<font color=red>     0..|  	    verify_cstruct(Cs3),</font>
<font color=red>     0..|  	    lists:flatten([DelOps, {op, transform, Fun, vsn_cs2list(Cs2)}, AddOps])</font>
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%
        |  
        |  change_table_access_mode(Tab, Mode) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_change_table_access_mode(Tab, Mode) end).</font>
        |  
        |  do_change_table_access_mode(Tab, Mode) -&gt;
<font color=red>     0..|      {_Mod, Tid, Ts} = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
<font color=red>     0..|      mnesia2_locker:wlock_no_exist(Tid, Store, schema, val({schema, active_replicas})),</font>
<font color=red>     0..|      mnesia2_locker:wlock_no_exist(Tid, Store, Tab, val({Tab, active_replicas})),</font>
<font color=red>     0..|      do_insert_schema_ops(Store, make_change_table_access_mode(Tab, Mode)).</font>
        |  
        |  make_change_table_access_mode(Tab, Mode) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      OldMode = Cs#cstruct.access_mode,</font>
<font color=red>     0..|      verify(false, OldMode ==  Mode, {already_exists, Tab, Mode}),</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{access_mode = Mode},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, change_table_access_mode, vsn_cs2list(Cs2), OldMode, Mode}].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  change_table_load_order(Tab, LoadOrder) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_change_table_load_order(Tab, LoadOrder) end).</font>
        |  
        |  do_change_table_load_order(schema, _LoadOrder) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_change_table_load_order(Tab, LoadOrder) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, none),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_change_table_load_order(Tab, LoadOrder)).</font>
        |  
        |  make_change_table_load_order(Tab, LoadOrder) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      OldLoadOrder = Cs#cstruct.load_order,</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{load_order = LoadOrder},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, change_table_load_order, vsn_cs2list(Cs2), OldLoadOrder, LoadOrder}].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  change_table_majority(Tab, Majority) when is_boolean(Majority) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_change_table_majority(Tab, Majority) end).</font>
        |  
        |  do_change_table_majority(schema, _Majority) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  do_change_table_majority(Tab, Majority) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      get_tid_ts_and_lock(Tab, none),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_change_table_majority(Tab, Majority)).</font>
        |  
        |  make_change_table_majority(Tab, Majority) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      OldMajority = Cs#cstruct.majority,</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{majority = Majority},</font>
<font color=red>     0..|      FragOps = case lists:keyfind(base_table, 1, Cs#cstruct.frag_properties) of</font>
        |  		  {_, Tab} -&gt;
<font color=red>     0..|  		      FragNames = mnesia2_frag:frag_names(Tab) -- [Tab],</font>
<font color=red>     0..|  		      lists:map(</font>
        |  			fun(T) -&gt;
<font color=red>     0..|  				get_tid_ts_and_lock(Tab, none),</font>
<font color=red>     0..|  				CsT = incr_version(val({T, cstruct})),</font>
<font color=red>     0..|  				ensure_active(CsT),</font>
<font color=red>     0..|  				CsT2 = CsT#cstruct{majority = Majority},</font>
<font color=red>     0..|  				verify_cstruct(CsT2),</font>
<font color=red>     0..|  				{op, change_table_majority, vsn_cs2list(CsT2),</font>
        |  				 OldMajority, Majority}
        |  			end, FragNames);
<font color=red>     0..|  		  false    -&gt; [];</font>
<font color=red>     0..|  		  {_, _}   -&gt; mnesia2:abort({bad_type, Tab})</font>
        |  	      end,
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, change_table_majority, vsn_cs2list(Cs2), OldMajority, Majority} | FragOps].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  write_table_property(Tab, Prop) when is_tuple(Prop), size(Prop) &gt;= 1 -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_write_table_property(Tab, Prop) end);</font>
        |  write_table_property(Tab, Prop) -&gt;
<font color=red>     0..|      {aborted, {bad_type, Tab, Prop}}.</font>
        |  do_write_table_property(Tab, Prop) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      {_, _, Ts} = TidTs,</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
<font color=red>     0..|      case change_prop_in_existing_op(Tab, Prop, write_property, Store) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    dbg_out("change_prop_in_existing_op"</font>
        |  		    "(~p,~p,write_property,Store) -&gt; true~n",
        |  		    [Tab,Prop]),
        |  	    %% we have merged the table prop into the create_table op
<font color=red>     0..|  	    ok;</font>
        |  	false -&gt;
<font color=red>     0..|  	    dbg_out("change_prop_in_existing_op"</font>
        |  		    "(~p,~p,write_property,Store) -&gt; false~n",
        |  		    [Tab,Prop]),
        |  	    %% this must be an existing table
<font color=red>     0..|  	    get_tid_ts_and_lock(Tab, none),</font>
<font color=red>     0..|  	    insert_schema_ops(TidTs, make_write_table_properties(Tab, [Prop]))</font>
        |      end.
        |  
        |  make_write_table_properties(Tab, Props) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      make_write_table_properties(Tab, Props, Cs).</font>
        |  
        |  make_write_table_properties(Tab, [Prop | Props], Cs) -&gt;
<font color=red>     0..|      OldProps = Cs#cstruct.user_properties,</font>
<font color=red>     0..|      PropKey = element(1, Prop),</font>
<font color=red>     0..|      DelProps = lists:keydelete(PropKey, 1, OldProps),</font>
<font color=red>     0..|      MergedProps = lists:merge(DelProps, [Prop]),</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{user_properties = MergedProps},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, write_property, vsn_cs2list(Cs2), Prop} |</font>
        |       make_write_table_properties(Tab, Props, Cs2)];
        |  make_write_table_properties(_Tab, [], _Cs) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  change_prop_in_existing_op(Tab, Prop, How, Store) -&gt;
<font color=red>     0..|      Ops = ets:match_object(Store, '_'),</font>
<font color=red>     0..|      case update_existing_op(Ops, Tab, Prop, How, []) of</font>
        |  	{true, Ops1} -&gt;
<font color=red>     0..|  	    ets:match_delete(Store, '_'),</font>
<font color=red>     0..|  	    [ets:insert(Store, Op) || Op &lt;- Ops1],</font>
<font color=red>     0..|  	    true;</font>
        |  	false -&gt;
<font color=red>     0..|  	    false</font>
        |      end.
        |  
        |  update_existing_op([{op, Op, L = [{name,Tab}|_], _OldProp}|Ops],
        |  		   Tab, Prop, How, Acc) when Op == write_property;
        |  					     Op == delete_property -&gt;
        |      %% Apparently, mnesia2_dumper doesn't care about OldProp here -- just L,
        |      %% so we will throw away OldProp (not that it matters...) and insert Prop.
        |      %% as element 3.
<font color=red>     0..|      L1 = insert_prop(Prop, L, How),</font>
<font color=red>     0..|      NewOp = {op, How, L1, Prop},</font>
<font color=red>     0..|      {true, lists:reverse(Acc) ++ [NewOp|Ops]};</font>
        |  update_existing_op([Op = {op, create_table, L}|Ops], Tab, Prop, How, Acc) -&gt;
<font color=red>     0..|      case lists:keysearch(name, 1, L) of</font>
        |  	{value, {_, Tab}} -&gt;
        |  	    %% Tab is being created here -- insert Prop into L
<font color=red>     0..|  	    L1 = insert_prop(Prop, L, How),</font>
<font color=red>     0..|  	    {true, lists:reverse(Acc) ++ [{op, create_table, L1}|Ops]};</font>
        |  	_ -&gt;
<font color=red>     0..|  	    update_existing_op(Ops, Tab, Prop, How, [Op|Acc])</font>
        |      end;
        |  update_existing_op([Op|Ops], Tab, Prop, How, Acc) -&gt;
<font color=red>     0..|      update_existing_op(Ops, Tab, Prop, How, [Op|Acc]);</font>
        |  update_existing_op([], _, _, _, _) -&gt;
<font color=red>     0..|      false.</font>
        |  
        |  do_read_table_property(Tab, Key) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, read),</font>
<font color=red>     0..|      {_, _, Ts} = TidTs,</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
<font color=red>     0..|      Props = ets:foldl(</font>
        |  	      fun({op, create_table, [{name, T}|Opts]}, _Acc)
        |  		 when T==Tab -&gt;
<font color=red>     0..|  		      find_props(Opts);</font>
        |  		 ({op, Op, [{name,T}|Opts], _Prop}, _Acc)
        |  		 when T==Tab, Op==write_property; Op==delete_property -&gt;
<font color=red>     0..|  		      find_props(Opts);</font>
        |  		 ({op, delete_table, [{name,T}|_]}, _Acc)
        |  		 when T==Tab -&gt;
<font color=red>     0..|  		      [];</font>
        |  		 (_Other, Acc) -&gt;
<font color=red>     0..|  		      Acc</font>
        |  	      end, [], Store),
<font color=red>     0..|      case lists:keysearch(Key, 1, Props) of</font>
        |  	{value, Property} -&gt;
<font color=red>     0..|  	    Property;</font>
        |  	false -&gt;
<font color=red>     0..|  	    undefined</font>
        |      end.
        |  
        |  
        |  %% perhaps a misnomer. How could also be delete_property... never mind.
        |  %% Returns the modified L.
        |  insert_prop(Prop, L, How) -&gt;
<font color=red>     0..|      Prev = find_props(L),</font>
<font color=red>     0..|      MergedProps = merge_with_previous(How, Prop, Prev),</font>
<font color=red>     0..|      replace_props(L, MergedProps).</font>
        |  
<font color=red>     0..|  find_props([{user_properties, P}|_]) -&gt; P;</font>
<font color=red>     0..|  find_props([_H|T]) -&gt; find_props(T).</font>
        |  %% we shouldn't reach []
        |  
<font color=red>     0..|  replace_props([{user_properties, _}|T], P) -&gt; [{user_properties, P}|T];</font>
<font color=red>     0..|  replace_props([H|T], P) -&gt; [H|replace_props(T, P)].</font>
        |  %% again, we shouldn't reach []
        |  
        |  merge_with_previous(write_property, Prop, Prev) -&gt;
<font color=red>     0..|      Key = element(1, Prop),</font>
<font color=red>     0..|      Prev1 = lists:keydelete(Key, 1, Prev),</font>
<font color=red>     0..|      lists:sort([Prop|Prev1]);</font>
        |  merge_with_previous(delete_property, PropKey, Prev) -&gt;
<font color=red>     0..|      lists:keydelete(PropKey, 1, Prev).</font>
        |  
        |  delete_table_property(Tab, PropKey) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_delete_table_property(Tab, PropKey) end).</font>
        |  
        |  do_delete_table_property(Tab, PropKey) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      {_, _, Ts} = TidTs,</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
<font color=red>     0..|      case change_prop_in_existing_op(Tab, PropKey, delete_property, Store) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    dbg_out("change_prop_in_existing_op"</font>
        |  		    "(~p,~p,delete_property,Store) -&gt; true~n",
        |  		    [Tab,PropKey]),
        |  	    %% we have merged the table prop into the create_table op
<font color=red>     0..|  	    ok;</font>
        |  	false -&gt;
<font color=red>     0..|  	    dbg_out("change_prop_in_existing_op"</font>
        |  		    "(~p,~p,delete_property,Store) -&gt; false~n",
        |  		    [Tab,PropKey]),
        |  	    %% this must be an existing table
<font color=red>     0..|  	    get_tid_ts_and_lock(Tab, none),</font>
<font color=red>     0..|  	    insert_schema_ops(TidTs,</font>
        |  			      make_delete_table_properties(Tab, [PropKey]))
        |      end.
        |  
        |  make_delete_table_properties(Tab, PropKeys) -&gt;
<font color=red>     0..|      ensure_writable(schema),</font>
<font color=red>     0..|      Cs = incr_version(val({Tab, cstruct})),</font>
<font color=red>     0..|      ensure_active(Cs),</font>
<font color=red>     0..|      make_delete_table_properties(Tab, PropKeys, Cs).</font>
        |  
        |  make_delete_table_properties(Tab, [PropKey | PropKeys], Cs) -&gt;
<font color=red>     0..|      OldProps = Cs#cstruct.user_properties,</font>
<font color=red>     0..|      Props = lists:keydelete(PropKey, 1, OldProps),</font>
<font color=red>     0..|      Cs2 = Cs#cstruct{user_properties = Props},</font>
<font color=red>     0..|      verify_cstruct(Cs2),</font>
<font color=red>     0..|      [{op, delete_property, vsn_cs2list(Cs2), PropKey} |</font>
        |       make_delete_table_properties(Tab, PropKeys, Cs2)];
        |  make_delete_table_properties(_Tab, [], _Cs) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  %% Ensure that the transaction can be committed even
        |  %% if the node crashes and Mnesia2 is restarted
        |  prepare_commit(Tid, Commit, WaitFor) -&gt;
<font color=red>     0..|      case Commit#commit.schema_ops of</font>
        |  	[] -&gt;
<font color=red>     0..|  	    {false, Commit, optional};</font>
        |  	OrigOps -&gt;
<font color=red>     0..|  	    {Modified, Ops, DumperMode} =</font>
        |  		prepare_ops(Tid, OrigOps, WaitFor, false, [], optional),
<font color=red>     0..|  	    InitBy = schema_prepare,</font>
<font color=red>     0..|  	    GoodRes = {Modified,</font>
        |  		       Commit#commit{schema_ops = lists:reverse(Ops)},
        |  		       DumperMode},
<font color=red>     0..|  	    case DumperMode of</font>
        |  		optional -&gt;
<font color=red>     0..|  		    dbg_out("Transaction log dump skipped (~p): ~w~n",</font>
        |  			    [DumperMode, InitBy]);
        |  		mandatory -&gt;
<font color=red>     0..|  		    case mnesia2_controller:sync_dump_log(InitBy) of</font>
        |  			dumped -&gt;
<font color=red>     0..|  			    GoodRes;</font>
        |  			{error, Reason} -&gt;
<font color=red>     0..|  			    mnesia2:abort(Reason)</font>
        |  		    end
        |  	    end,
<font color=red>     0..|  	    case Ops of</font>
        |  		[] -&gt;
<font color=red>     0..|  		    ignore;</font>
        |  		_ -&gt;
        |  		    %% We need to grab a dumper lock here, the log may not
        |  		    %% be dumped by others, during the schema commit phase.
<font color=red>     0..|  		    mnesia2_controller:wait_for_schema_commit_lock()</font>
        |  	    end,
<font color=red>     0..|  	    GoodRes</font>
        |      end.
        |  
        |  prepare_ops(Tid, [Op | Ops], WaitFor, Changed, Acc, DumperMode) -&gt;
<font color=red>     0..|      case prepare_op(Tid, Op, WaitFor) of</font>
        |          {true, mandatory} -&gt;
<font color=red>     0..|  	    prepare_ops(Tid, Ops, WaitFor, Changed, [Op | Acc], mandatory);</font>
        |          {true, optional} -&gt;
<font color=red>     0..|  	    prepare_ops(Tid, Ops, WaitFor, Changed, [Op | Acc], DumperMode);</font>
        |          {true, Ops2, mandatory} -&gt;
<font color=red>     0..|  	    prepare_ops(Tid, Ops, WaitFor, true, Ops2 ++ Acc, mandatory);</font>
        |          {true, Ops2, optional} -&gt;
<font color=red>     0..|  	    prepare_ops(Tid, Ops, WaitFor, true, Ops2 ++ Acc, DumperMode);</font>
        |  	{false, optional} -&gt;
<font color=red>     0..|  	    prepare_ops(Tid, Ops, WaitFor, true, Acc, DumperMode)</font>
        |      end;
        |  prepare_ops(_Tid, [], _WaitFor, Changed, Acc, DumperMode) -&gt;
<font color=red>     0..|      {Changed, Acc, DumperMode}.</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Prepare for commit
        |  %% returns true if Op should be included, i.e. unmodified
        |  %%         {true, Operation} if NewRecs should be included, i.e. modified
        |  %%         false if Op should NOT be included, i.e. modified
        |  %%
        |  prepare_op(_Tid, {op, rec, unknown, Rec}, _WaitFor) -&gt;
<font color=red>     0..|      {{Tab, Key}, Items, _Op} = Rec,</font>
<font color=red>     0..|      case val({Tab, storage_type}) of</font>
        |          unknown -&gt;
<font color=red>     0..|              {false, optional};</font>
        |          Storage -&gt;
<font color=red>     0..|              mnesia2_tm:prepare_snmp(Tab, Key, Items), % May exit</font>
<font color=red>     0..|              {true, [{op, rec, Storage, Rec}], optional}</font>
        |      end;
        |  
        |  prepare_op(_Tid, {op, announce_im_running, Node, SchemaDef, Running, RemoteRunning}, _WaitFor) -&gt;
<font color=red>     0..|      SchemaCs = list2cs(SchemaDef),</font>
<font color=red>     0..|      if</font>
        |  	Node == node() -&gt; %% Announce has already run on local node
<font color=red>     0..|  	    ignore;       %% from do_merge_schema</font>
        |  	true -&gt;
        |  	    %% If a node has restarted it may still linger in db_nodes,
        |  	    %% but have been removed from recover_nodes
<font color=red>     0..|  	    Current  = mnesia2_lib:intersect(val({current,db_nodes}), [node()|val(recover_nodes)]),</font>
<font color=red>     0..|  	    NewNodes = mnesia2_lib:uniq(Running++RemoteRunning) -- Current,</font>
<font color=red>     0..|  	    mnesia2_lib:set(prepare_op, {announce_im_running,NewNodes}),</font>
<font color=red>     0..|  	    announce_im_running(NewNodes, SchemaCs)</font>
        |      end,
<font color=red>     0..|      {false, optional};</font>
        |  
        |  prepare_op(_Tid, {op, sync_trans}, {part, CoordPid}) -&gt;
<font color=red>     0..|      CoordPid ! {sync_trans, self()},</font>
<font color=red>     0..|      receive</font>
        |  	{sync_trans, CoordPid} -&gt;
<font color=red>     0..|  	    {false, optional};</font>
        |  	{mnesia2_down, _Node} = Else -&gt;
<font color=red>     0..|  	    mnesia2_lib:verbose("sync_op terminated due to ~p~n", [Else]),</font>
<font color=red>     0..|  	    mnesia2:abort(Else);</font>
        |  	{'EXIT', _, _} = Else -&gt;
<font color=red>     0..|  	    mnesia2_lib:verbose("sync_op terminated due to ~p~n", [Else]),</font>
<font color=red>     0..|  	    mnesia2:abort(Else)</font>
        |      end;
        |  
        |  prepare_op(_Tid, {op, sync_trans}, {coord, Nodes}) -&gt;
<font color=red>     0..|      case receive_sync(Nodes, []) of</font>
        |  	{abort, Reason} -&gt;
<font color=red>     0..|  	    mnesia2_lib:verbose("sync_op terminated due to ~p~n", [Reason]),</font>
<font color=red>     0..|  	    mnesia2:abort(Reason);</font>
        |  	Pids -&gt;
<font color=red>     0..|  	    [Pid ! {sync_trans, self()} || Pid &lt;- Pids],</font>
<font color=red>     0..|  	    {false, optional}</font>
        |      end;
        |  prepare_op(Tid, {op, create_table, TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Storage = mnesia2_lib:cs_to_storage_type(node(), Cs),</font>
<font color=red>     0..|      UseDir = mnesia2_monitor:use_dir(),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      case Storage of</font>
        |          disc_copies when UseDir == false -&gt;
<font color=red>     0..|  	    UseDirReason = {bad_type, Tab, Storage, node()},</font>
<font color=red>     0..|              mnesia2:abort(UseDirReason);</font>
        |          disc_only_copies when UseDir == false -&gt;
<font color=red>     0..|  	    UseDirReason = {bad_type, Tab, Storage, node()},</font>
<font color=red>     0..|              mnesia2:abort(UseDirReason);</font>
        |  	ram_copies -&gt;
<font color=red>     0..|  	    mnesia2_lib:set({Tab, create_table},true),</font>
<font color=red>     0..|  	    create_ram_table(Tab, Cs),</font>
<font color=red>     0..|  	    insert_cstruct(Tid, Cs, false),</font>
<font color=red>     0..|  	    {true, optional};</font>
        |  	disc_copies -&gt;
<font color=red>     0..|  	    mnesia2_lib:set({Tab, create_table},true),</font>
<font color=red>     0..|  	    create_ram_table(Tab, Cs),</font>
<font color=red>     0..|  	    create_disc_table(Tab),</font>
<font color=red>     0..|  	    insert_cstruct(Tid, Cs, false),</font>
<font color=red>     0..|  	    {true, optional};</font>
        |  	disc_only_copies -&gt;
<font color=red>     0..|  	    mnesia2_lib:set({Tab, create_table},true),</font>
<font color=red>     0..|  	    create_disc_only_table(Tab,Cs),</font>
<font color=red>     0..|  	    insert_cstruct(Tid, Cs, false),</font>
<font color=red>     0..|  	    {true, optional};</font>
        |          unknown -&gt; %% No replica on this node
<font color=red>     0..|  	    mnesia2_lib:set({Tab, create_table},true),</font>
<font color=red>     0..|  	    insert_cstruct(Tid, Cs, false),</font>
<font color=red>     0..|              {true, optional}</font>
        |      end;
        |  
        |  prepare_op(Tid, {op, add_table_copy, Storage, Node, TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
        |  
<font color=red>     0..|      if</font>
        |  	Tab == schema -&gt;
<font color=red>     0..|  	    {true, optional};</font>
        |  
        |  	Node == node() -&gt;
<font color=red>     0..|  	    case mnesia2_lib:val({schema, storage_type}) of</font>
        |  		ram_copies when Storage /= ram_copies -&gt;
<font color=red>     0..|  		    Error = {combine_error, Tab, "has no disc", Node},</font>
<font color=red>     0..|  		    mnesia2:abort(Error);</font>
        |  		_  -&gt;
<font color=red>     0..|  		    ok</font>
        |  	    end,
        |  	    %% Tables are created by mnesia2_loader get_network code
<font color=red>     0..|  	    insert_cstruct(Tid, Cs, true),</font>
<font color=red>     0..|  	    case mnesia2_controller:get_network_copy(Tab, Cs) of</font>
        |  		{loaded, ok} -&gt;
<font color=red>     0..|  		    {true, optional};</font>
        |  		{not_loaded, ErrReason} -&gt;
<font color=red>     0..|  		    Reason = {system_limit, Tab, {Node, ErrReason}},</font>
<font color=red>     0..|  		    mnesia2:abort(Reason)</font>
        |  	    end;
        |  	Node /= node() -&gt;
        |  	    %% Verify that ram table not has been dumped to disc
<font color=red>     0..|  	    if</font>
        |  		Storage /= ram_copies -&gt;
<font color=red>     0..|  		    case mnesia2_lib:schema_cs_to_storage_type(node(), Cs) of</font>
        |  			ram_copies -&gt;
<font color=red>     0..|  			    Dat = mnesia2_lib:tab2dcd(Tab),</font>
<font color=red>     0..|  			    case mnesia2_lib:exists(Dat) of</font>
        |  				true -&gt;
<font color=red>     0..|  				    mnesia2:abort({combine_error, Tab, Storage,</font>
        |  						  "Table dumped to disc", node()});
        |  				false -&gt;
<font color=red>     0..|  				    ok</font>
        |  			    end;
        |  			_ -&gt;
<font color=red>     0..|  			    ok</font>
        |  		    end;
        |  		true -&gt;
<font color=red>     0..|  		    ok</font>
        |  	    end,
<font color=red>     0..|  	    insert_cstruct(Tid, Cs, true),</font>
<font color=red>     0..|  	    {true, optional}</font>
        |      end;
        |  
        |  prepare_op(_Tid, {op, del_table_copy, _Storage, Node, TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
        |  
<font color=red>     0..|      set_where_to_read(Tab, Node, Cs),</font>
<font color=red>     0..|      {true, optional};</font>
        |  
        |  prepare_op(_Tid, {op, change_table_copy_type,  N, FromS, ToS, TabDef}, _WaitFor)
        |    when N == node() -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
        |  
<font color=red>     0..|      NotActive = mnesia2_lib:not_active_here(Tab),</font>
        |  
<font color=red>     0..|      if</font>
        |  	NotActive == true -&gt;
<font color=red>     0..|  	    mnesia2:abort({not_active, Tab, node()});</font>
        |  
        |  	Tab == schema -&gt;
<font color=red>     0..|  	    case {FromS, ToS} of</font>
        |  		{ram_copies, disc_copies} -&gt;
<font color=red>     0..|  		    case mnesia2:system_info(schema_location) of</font>
        |  			opt_disc -&gt;
<font color=red>     0..|  			    ignore;</font>
        |  			_ -&gt;
<font color=red>     0..|  			    mnesia2:abort({combine_error,  Tab, node(),</font>
        |  					  "schema_location must be opt_disc"})
        |  		    end,
<font color=red>     0..|  		    Dir = mnesia2_lib:dir(),</font>
<font color=red>     0..|  		    case opt_create_dir(true, Dir) of</font>
        |  			ok -&gt;
<font color=red>     0..|  			    purge_dir(Dir, []),</font>
<font color=red>     0..|  			    mnesia2_log:purge_all_logs(),</font>
<font color=red>     0..|  			    set(use_dir, true),</font>
<font color=red>     0..|  			    mnesia2_log:init(),</font>
<font color=red>     0..|  			    Ns = val({current, db_nodes}), %mnesia2_lib:running_nodes(),</font>
<font color=red>     0..|  			    F = fun(U) -&gt; mnesia2_recover:log_mnesia2_up(U) end,</font>
<font color=red>     0..|  			    lists:foreach(F, Ns),</font>
        |  
<font color=red>     0..|  			    mnesia2_dumper:raw_named_dump_table(Tab, dmp),</font>
<font color=red>     0..|  			    mnesia2_checkpoint:tm_change_table_copy_type(Tab, FromS, ToS);</font>
        |  			{error, Reason} -&gt;
<font color=red>     0..|  			    mnesia2:abort(Reason)</font>
        |  		    end;
        |  		{disc_copies, ram_copies} -&gt;
<font color=red>     0..|  		    Ltabs = val({schema, local_tables}) -- [schema],</font>
<font color=red>     0..|  		    Dtabs = [L || L &lt;- Ltabs,</font>
<font color=red>     0..|  				  val({L, storage_type}) /= ram_copies],</font>
<font color=red>     0..|  		    verify([], Dtabs, {"Disc resident tables", Dtabs, N});</font>
        |  		_ -&gt;
<font color=red>     0..|  		    mnesia2:abort({combine_error, Tab, ToS})</font>
        |  	    end;
        |  
        |  	FromS == ram_copies -&gt;
<font color=red>     0..|  	    case mnesia2_monitor:use_dir() of</font>
        |  		true -&gt;
<font color=red>     0..|  		    Dat = mnesia2_lib:tab2dcd(Tab),</font>
<font color=red>     0..|  		    case mnesia2_lib:exists(Dat) of</font>
        |  			true -&gt;
<font color=red>     0..|  			    mnesia2:abort({combine_error, Tab, node(),</font>
        |  					  "Table dump exists"});
        |  			false -&gt;
<font color=red>     0..|  			    case ToS of</font>
        |  				disc_copies -&gt;
<font color=red>     0..|  				    mnesia2_log:ets2dcd(Tab, dmp);</font>
        |  				disc_only_copies -&gt;
<font color=red>     0..|  				    mnesia2_dumper:raw_named_dump_table(Tab, dmp)</font>
        |  			    end,
<font color=red>     0..|  			    mnesia2_checkpoint:tm_change_table_copy_type(Tab, FromS, ToS)</font>
        |  		    end;
        |  		false -&gt;
<font color=red>     0..|  		    mnesia2:abort({has_no_disc, node()})</font>
        |  	    end;
        |  
        |  	FromS == disc_copies, ToS == disc_only_copies -&gt;
<font color=red>     0..|  	    mnesia2_dumper:raw_named_dump_table(Tab, dmp);</font>
        |  	FromS == disc_only_copies -&gt;
<font color=red>     0..|  	    Type = Cs#cstruct.type,</font>
<font color=red>     0..|  	    create_ram_table(Tab, Cs),</font>
<font color=red>     0..|  	    Datname = mnesia2_lib:tab2dat(Tab),</font>
<font color=red>     0..|  	    Repair = mnesia2_monitor:get_env(auto_repair),</font>
<font color=red>     0..|  	    case mnesia2_lib:dets_to_ets(Tab, Tab, Datname, Type, Repair, no) of</font>
<font color=red>     0..|  		loaded -&gt; ok;</font>
        |  		Reason -&gt;
<font color=red>     0..|  		    Err = "Failed to copy disc data to ram",</font>
<font color=red>     0..|  		    mnesia2:abort({system_limit, Tab, {Err,Reason}})</font>
        |  	    end;
        |  	true -&gt;
<font color=red>     0..|  	    ignore</font>
        |      end,
<font color=red>     0..|      {true, mandatory};</font>
        |  
        |  prepare_op(_Tid, {op, change_table_copy_type,  N, _FromS, _ToS, _TabDef}, _WaitFor)
        |    when N /= node() -&gt;
<font color=red>     0..|      {true, mandatory};</font>
        |  
        |  prepare_op(_Tid, {op, delete_table, _TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      {true, mandatory};</font>
        |  
        |  prepare_op(_Tid, {op, dump_table, unknown, TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      case lists:member(node(), Cs#cstruct.ram_copies) of</font>
        |          true -&gt;
<font color=red>     0..|  	    case mnesia2_monitor:use_dir() of</font>
        |  		true -&gt;
<font color=red>     0..|  		    mnesia2_log:ets2dcd(Tab, dmp),</font>
<font color=red>     0..|  		    Size = mnesia2:table_info(Tab, size),</font>
<font color=red>     0..|  		    {true, [{op, dump_table, Size, TabDef}], optional};</font>
        |  		false -&gt;
<font color=red>     0..|  		    mnesia2:abort({has_no_disc, node()})</font>
        |  	    end;
        |          false -&gt;
<font color=red>     0..|              {false, optional}</font>
        |      end;
        |  
        |  prepare_op(_Tid, {op, add_snmp, Ustruct, TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      case mnesia2_lib:cs_to_storage_type(node(), Cs) of</font>
        |          unknown -&gt;
<font color=red>     0..|              {true, optional};</font>
        |          Storage -&gt;
<font color=red>     0..|              Tab = Cs#cstruct.name,</font>
<font color=red>     0..|              Stab = mnesia2_snmp_hook:create_table(Ustruct, Tab, Storage),</font>
<font color=red>     0..|              mnesia2_lib:set({Tab, {index, snmp}}, Stab),</font>
<font color=red>     0..|              {true, optional}</font>
        |      end;
        |  
        |  prepare_op(_Tid, {op, transform, ignore, _TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      {true, mandatory};   %% Apply schema changes only.</font>
        |  prepare_op(_Tid, {op, transform, Fun, TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      case mnesia2_lib:cs_to_storage_type(node(), Cs) of</font>
        |          unknown -&gt;
<font color=red>     0..|              {true, mandatory};</font>
        |          Storage -&gt;
<font color=red>     0..|              Tab = Cs#cstruct.name,</font>
<font color=red>     0..|              RecName = Cs#cstruct.record_name,</font>
<font color=red>     0..|  	    Type = Cs#cstruct.type,</font>
<font color=red>     0..|              NewArity = length(Cs#cstruct.attributes) + 1,</font>
<font color=red>     0..|  	    mnesia2_lib:db_fixtable(Storage, Tab, true),</font>
<font color=red>     0..|              Key = mnesia2_lib:db_first(Tab),</font>
<font color=red>     0..|  	    Op = {op, transform, Fun, TabDef},</font>
<font color=red>     0..|              try transform_objs(Fun, Tab, RecName, Key,</font>
        |  			       NewArity, Storage, Type, [Op]) of
        |                  Objs -&gt;
<font color=red>     0..|  		    mnesia2_lib:db_fixtable(Storage, Tab, false),</font>
<font color=red>     0..|                      {true, Objs, mandatory}</font>
        |  	    catch _:Reason -&gt;
<font color=red>     0..|  		    mnesia2_lib:db_fixtable(Storage, Tab, false),</font>
<font color=red>     0..|                      exit({"Bad transform function", Tab, Fun, node(), Reason})</font>
        |              end
        |      end;
        |  
        |  prepare_op(_Tid, {op, merge_schema, TabDef}, _WaitFor) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      case verify_merge(Cs) of</font>
        |  	ok  -&gt;
<font color=red>     0..|  	    {true, optional};</font>
        |  	Error -&gt;
<font color=red>     0..|  	    verbose("Merge_Schema ~p failed on ~p: ~p~n", [_Tid,node(),Error]),</font>
<font color=red>     0..|  	    mnesia2:abort({bad_commit, Error})</font>
        |      end;
        |  prepare_op(_Tid, _Op, _WaitFor) -&gt;
<font color=red>     0..|      {true, optional}.</font>
        |  
        |  create_ram_table(Tab, #cstruct{type=Type, storage_properties=Props}) -&gt;
<font color=red>     0..|      EtsOpts = proplists:get_value(ets, Props, []),</font>
<font color=red>     0..|      Args = [{keypos, 2}, public, named_table, Type | EtsOpts],</font>
<font color=red>     0..|      case mnesia2_monitor:unsafe_mktab(Tab, Args) of</font>
        |  	Tab -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	{error,Reason} -&gt;
<font color=red>     0..|  	    Err = "Failed to create ets table",</font>
<font color=red>     0..|  	    mnesia2:abort({system_limit, Tab, {Err,Reason}})</font>
        |      end.
        |  
        |  create_disc_table(Tab) -&gt;
<font color=red>     0..|      File = mnesia2_lib:tab2dcd(Tab),</font>
<font color=red>     0..|      file:delete(File),</font>
<font color=red>     0..|      FArg = [{file, File}, {name, {mnesia2,create}},</font>
        |  	    {repair, false}, {mode, read_write}],
<font color=red>     0..|      case mnesia2_monitor:open_log(FArg) of</font>
        |  	{ok,Log} -&gt;
<font color=red>     0..|  	    mnesia2_monitor:unsafe_close_log(Log),</font>
<font color=red>     0..|  	    ok;</font>
        |  	{error,Reason} -&gt;
<font color=red>     0..|  	    Err = "Failed to create disc table",</font>
<font color=red>     0..|  	    mnesia2:abort({system_limit, Tab, {Err,Reason}})</font>
        |      end.
        |  create_disc_only_table(Tab, #cstruct{type=Type, storage_properties=Props}) -&gt;
<font color=red>     0..|      File = mnesia2_lib:tab2dat(Tab),</font>
<font color=red>     0..|      file:delete(File),</font>
<font color=red>     0..|      DetsOpts = proplists:get_value(dets, Props, []),</font>
<font color=red>     0..|      Args = [{file, mnesia2_lib:tab2dat(Tab)},</font>
        |  	    {type, mnesia2_lib:disk_type(Tab, Type)},
        |  	    {keypos, 2},
        |  	    {repair, mnesia2_monitor:get_env(auto_repair)}
        |  	    | DetsOpts],
<font color=red>     0..|      case mnesia2_monitor:unsafe_open_dets(Tab, Args) of</font>
        |  	{ok, _} -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	{error,Reason} -&gt;
<font color=red>     0..|  	    Err = "Failed to create disc table",</font>
<font color=red>     0..|  	    mnesia2:abort({system_limit, Tab, {Err,Reason}})</font>
        |      end.
        |  
        |  
        |  receive_sync([], Pids) -&gt;
<font color=red>     0..|      Pids;</font>
        |  receive_sync(Nodes, Pids) -&gt;
<font color=red>     0..|      receive</font>
        |  	{sync_trans, Pid} -&gt;
<font color=red>     0..|  	    Node = node(Pid),</font>
<font color=red>     0..|  	    receive_sync(lists:delete(Node, Nodes), [Pid | Pids]);</font>
        |  	Else -&gt;
<font color=red>     0..|  	    {abort, Else}</font>
        |      end.
        |  
        |  set_where_to_read(Tab, Node, Cs) -&gt;
<font color=red>     0..|      case mnesia2_lib:val({Tab, where_to_read}) of</font>
        |  	Node -&gt;
<font color=red>     0..|  	    case Cs#cstruct.local_content of</font>
        |  		true -&gt;
<font color=red>     0..|  		    ok;</font>
        |  		false -&gt;
<font color=red>     0..|  		    mnesia2_lib:set_remote_where_to_read(Tab, [Node]),</font>
<font color=red>     0..|  		    ok</font>
        |  	    end;
        |  	_ -&gt;
<font color=red>     0..|  	    ok</font>
        |      end.
        |  
        |  %% Build up the list in reverse order.
        |  transform_objs(_Fun, _Tab, _RT, '$end_of_table', _NewArity, _Storage, _Type, Acc) -&gt;
<font color=red>     0..|      Acc;</font>
        |  transform_objs(Fun, Tab, RecName, Key, A, Storage, Type, Acc) -&gt;
<font color=red>     0..|      Objs = mnesia2_lib:db_get(Tab, Key),</font>
<font color=red>     0..|      NextKey = mnesia2_lib:db_next_key(Tab, Key),</font>
<font color=red>     0..|      Oid = {Tab, Key},</font>
<font color=red>     0..|      NewObjs = {Ws, Ds} = transform_obj(Tab, RecName, Key, Fun, Objs, A, Type, [], []),</font>
<font color=red>     0..|      if</font>
        |  	NewObjs == {[], []} -&gt;
<font color=red>     0..|  	    transform_objs(Fun, Tab, RecName, NextKey, A, Storage, Type, Acc);</font>
        |  	Type == bag -&gt;
<font color=red>     0..|  	    transform_objs(Fun, Tab, RecName, NextKey, A, Storage, Type,</font>
        |  			   [{op, rec, Storage, {Oid, Ws, write}},
        |  			    {op, rec, Storage, {Oid, [Oid], delete}} | Acc]);
        |  	Ds == [] -&gt;
        |  	    %% Type is set or ordered_set, no need to delete the record first
<font color=red>     0..|  	    transform_objs(Fun, Tab, RecName, NextKey, A, Storage, Type,</font>
        |  			   [{op, rec, Storage, {Oid, Ws, write}} | Acc]);
        |  	Ws == [] -&gt;
<font color=red>     0..|  	    transform_objs(Fun, Tab, RecName, NextKey, A, Storage, Type,</font>
        |  			   [{op, rec, Storage, {Oid, Ds, write}} | Acc]);
        |  	true -&gt;
<font color=red>     0..|  	    transform_objs(Fun, Tab, RecName, NextKey, A, Storage, Type,</font>
        |  			   [{op, rec, Storage, {Oid, Ws, write}},
        |  			    {op, rec, Storage, {Oid, Ds, delete}} | Acc])
        |      end.
        |  
        |  transform_obj(Tab, RecName, Key, Fun, [Obj|Rest], NewArity, Type, Ws, Ds) -&gt;
<font color=red>     0..|      NewObj = Fun(Obj),</font>
<font color=red>     0..|      if</font>
        |          size(NewObj) /= NewArity -&gt;
<font color=red>     0..|              exit({"Bad arity", Obj, NewObj});</font>
        |  	NewObj == Obj -&gt;
<font color=red>     0..|  	    transform_obj(Tab, RecName, Key, Fun, Rest, NewArity, Type, Ws, Ds);</font>
        |          RecName == element(1, NewObj), Key == element(2, NewObj) -&gt;
<font color=red>     0..|              transform_obj(Tab, RecName, Key, Fun, Rest, NewArity,</font>
        |  			  Type, [NewObj | Ws], Ds);
        |  	NewObj == delete -&gt;
<font color=red>     0..|  	    case Type of</font>
        |  		bag -&gt; %% Just don't write that object
<font color=red>     0..|  		   transform_obj(Tab, RecName, Key, Fun, Rest,</font>
        |  				 NewArity, Type, Ws, Ds);
        |  		_ -&gt;
<font color=red>     0..|  		    transform_obj(Tab, RecName, Key, Fun, Rest, NewArity,</font>
        |  				  Type, Ws, [NewObj | Ds])
        |  	    end;
        |          true -&gt;
<font color=red>     0..|              exit({"Bad key or Record Name", Obj, NewObj})</font>
        |      end;
        |  transform_obj(_Tab, _RecName, _Key, _Fun, [], _NewArity, _Type, Ws, Ds) -&gt;
<font color=red>     0..|      {lists:reverse(Ws), lists:reverse(Ds)}.</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Undo prepare of commit
        |  undo_prepare_commit(Tid, Commit) -&gt;
<font color=red>     0..|      case Commit#commit.schema_ops of</font>
        |  	[] -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	Ops -&gt;
        |  	    %% Catch to allow failure mnesia2_controller may not be started
<font color=red>     0..|  	    ?SAFE(mnesia2_controller:release_schema_commit_lock()),</font>
<font color=red>     0..|  	    undo_prepare_ops(Tid, Ops)</font>
        |      end,
<font color=red>     0..|      Commit.</font>
        |  
        |  %% Undo in reverse order
        |  undo_prepare_ops(Tid, [Op | Ops]) -&gt;
<font color=red>     0..|      case element(1, Op) of</font>
        |  	TheOp when TheOp /= op, TheOp /= restore_op -&gt;
<font color=red>     0..|  	    undo_prepare_ops(Tid, Ops);</font>
        |  	_ -&gt;
<font color=red>     0..|  	    undo_prepare_ops(Tid, Ops),</font>
<font color=red>     0..|  	    undo_prepare_op(Tid, Op)</font>
        |      end;
        |  undo_prepare_ops(_Tid, []) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  undo_prepare_op(_Tid, {op, announce_im_running, _Node, _, _Running, _RemoteRunning}) -&gt;
<font color=red>     0..|      case ?catch_val(prepare_op) of</font>
        |  	{announce_im_running, New} -&gt;
<font color=red>     0..|              unannounce_im_running(New);</font>
        |  	_Else -&gt;
<font color=red>     0..|  	    ok</font>
        |      end;
        |  
        |  undo_prepare_op(_Tid, {op, sync_trans}) -&gt;
<font color=red>     0..|      ok;</font>
        |  
        |  undo_prepare_op(Tid, {op, create_table, TabDef}) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      mnesia2_lib:unset({Tab, create_table}),</font>
<font color=red>     0..|      delete_cstruct(Tid, Cs),</font>
<font color=red>     0..|      case mnesia2_lib:cs_to_storage_type(node(), Cs) of</font>
        |  	unknown -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	ram_copies -&gt;
<font color=red>     0..|  	    ram_delete_table(Tab, ram_copies);</font>
        |  	disc_copies -&gt;
<font color=red>     0..|  	    ram_delete_table(Tab, disc_copies),</font>
<font color=red>     0..|  	    DcdFile = mnesia2_lib:tab2dcd(Tab),</font>
        |  	    %%	    disc_delete_table(Tab, Storage),
<font color=red>     0..|  	    file:delete(DcdFile);</font>
        |  	disc_only_copies -&gt;
<font color=red>     0..|  	    mnesia2_monitor:unsafe_close_dets(Tab),</font>
<font color=red>     0..|  	    Dat = mnesia2_lib:tab2dat(Tab),</font>
        |  	    %%	    disc_delete_table(Tab, Storage),
<font color=red>     0..|  	    file:delete(Dat)</font>
        |      end;
        |  
        |  undo_prepare_op(Tid, {op, add_table_copy, Storage, Node, TabDef}) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      if</font>
        |  	Tab == schema -&gt;
<font color=red>     0..|  	    true; % Nothing to prepare</font>
        |  	Node == node() -&gt;
<font color=red>     0..|  	    mnesia2_checkpoint:tm_del_copy(Tab, Node),</font>
<font color=red>     0..|  	    mnesia2_controller:unannounce_add_table_copy(Tab, Node),</font>
<font color=red>     0..|  	    if</font>
        |  		Storage == disc_only_copies; Tab == schema -&gt;
<font color=red>     0..|  		    mnesia2_monitor:close_dets(Tab),</font>
<font color=red>     0..|  		    file:delete(mnesia2_lib:tab2dat(Tab));</font>
        |  		true -&gt;
<font color=red>     0..|  		    file:delete(mnesia2_lib:tab2dcd(Tab))</font>
        |  	    end,
<font color=red>     0..|  	    ram_delete_table(Tab, Storage),</font>
<font color=red>     0..|  	    Cs2 = new_cs(Cs, Node, Storage, del),</font>
<font color=red>     0..|  	    insert_cstruct(Tid, Cs2, true); % Don't care about the version</font>
        |  	Node /= node() -&gt;
<font color=red>     0..|  	    mnesia2_controller:unannounce_add_table_copy(Tab, Node),</font>
<font color=red>     0..|  	    Cs2 = new_cs(Cs, Node, Storage, del),</font>
<font color=red>     0..|  	    insert_cstruct(Tid, Cs2, true) % Don't care about the version</font>
        |      end;
        |  
        |  undo_prepare_op(_Tid, {op, del_table_copy, _, Node, TabDef}) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      if node() =:= Node -&gt;</font>
<font color=red>     0..|         mnesia2_lib:set({Tab, where_to_read}, Node);</font>
        |         true -&gt;
<font color=red>     0..|         case mnesia2_lib:val({Tab, where_to_read}) of</font>
        |         nowhere -&gt;
<font color=red>     0..|             mnesia2_lib:set_remote_where_to_read(Tab);</font>
        |         true -&gt;
<font color=red>     0..|             ignore</font>
        |         end
        |      end;
        |  
        |  undo_prepare_op(_Tid, {op, change_table_copy_type, N, FromS, ToS, TabDef})
        |          when N == node() -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      Tab = Cs#cstruct.name,</font>
<font color=red>     0..|      mnesia2_checkpoint:tm_change_table_copy_type(Tab, ToS, FromS),</font>
<font color=red>     0..|      Dmp = mnesia2_lib:tab2dmp(Tab),</font>
        |  
<font color=red>     0..|      case {FromS, ToS} of</font>
        |          {ram_copies, disc_copies} when Tab == schema -&gt;
<font color=red>     0..|              file:delete(Dmp),</font>
<font color=red>     0..|              mnesia2_log:purge_some_logs(),</font>
<font color=red>     0..|  	    set(use_dir, false);</font>
        |  	{ram_copies, disc_copies} -&gt;
<font color=red>     0..|  	    file:delete(Dmp);</font>
        |  	{ram_copies, disc_only_copies} -&gt;
<font color=red>     0..|  	    file:delete(Dmp);</font>
        |  	{disc_only_copies, _} -&gt;
<font color=red>     0..|  	    ram_delete_table(Tab, ram_copies);</font>
        |  	_ -&gt;
<font color=red>     0..|  	    ignore</font>
        |      end;
        |  
        |  undo_prepare_op(_Tid, {op, dump_table, _Size, TabDef}) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      case lists:member(node(), Cs#cstruct.ram_copies) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    Tab = Cs#cstruct.name,</font>
<font color=red>     0..|  	    Dmp = mnesia2_lib:tab2dmp(Tab),</font>
<font color=red>     0..|  	    file:delete(Dmp);</font>
        |  	false -&gt;
<font color=red>     0..|  	    ignore</font>
        |      end;
        |  
        |  undo_prepare_op(_Tid, {op, add_snmp, _Ustruct, TabDef}) -&gt;
<font color=red>     0..|      Cs = list2cs(TabDef),</font>
<font color=red>     0..|      case mnesia2_lib:cs_to_storage_type(node(), Cs) of</font>
        |  	unknown -&gt;
<font color=red>     0..|  	    true;</font>
        |  	_Storage -&gt;
<font color=red>     0..|  	    Tab = Cs#cstruct.name,</font>
<font color=red>     0..|  	    case ?catch_val({Tab, {index, snmp}}) of</font>
        |  		{'EXIT',_} -&gt;
<font color=red>     0..|  		    ignore;</font>
        |  		Stab -&gt;
<font color=red>     0..|  		    mnesia2_snmp_hook:delete_table(Tab, Stab),</font>
<font color=red>     0..|  		    mnesia2_lib:unset({Tab, {index, snmp}})</font>
        |  	    end
        |      end;
        |  
        |  undo_prepare_op(_Tid, _Op) -&gt;
<font color=red>     0..|      ignore.</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  ram_delete_table(Tab, Storage) -&gt;
<font color=red>     0..|      case Storage of</font>
        |  	unknown -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	disc_only_copies -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	_Else -&gt;
        |  	    %% delete possible index files and data .....
        |  	    %% Got to catch this since if no info has been set in the
        |  	    %% mnesia2_gvar it will crash
<font color=red>     0..|  	    ?CATCH(mnesia2_index:del_transient(Tab, Storage)),</font>
<font color=red>     0..|  	    case ?catch_val({Tab, {index, snmp}}) of</font>
        |  		{'EXIT', _} -&gt;
<font color=red>     0..|  		    ignore;</font>
        |  		Etab -&gt;
<font color=red>     0..|  		    ?SAFE(mnesia2_snmp_hook:delete_table(Tab, Etab))</font>
        |  	    end,
<font color=red>     0..|  	    ?SAFE(?ets_delete_table(Tab))</font>
        |      end.
        |  
        |  purge_dir(Dir, KeepFiles) -&gt;
    58..|      Suffixes = known_suffixes(),
    58..|      purge_dir(Dir, KeepFiles, Suffixes).
        |  
        |  purge_dir(Dir, KeepFiles, Suffixes) -&gt;
    58..|      case dir_exists(Dir) of
        |  	true -&gt;
    41..|  	    {ok, AllFiles} = file:list_dir(Dir),
    41..|  	    purge_known_files(AllFiles, KeepFiles, Dir, Suffixes);
        |  	false -&gt;
    17..|  	    ok
        |      end.
        |  
        |  purge_tmp_files() -&gt;
<font color=red>     0..|      case mnesia2_monitor:use_dir() of</font>
        |  	true -&gt;
<font color=red>     0..|  	    Dir = mnesia2_lib:dir(),</font>
<font color=red>     0..|  	    KeepFiles = [],</font>
<font color=red>     0..|  	    Exists = mnesia2_lib:exists(mnesia2_lib:tab2dat(schema)),</font>
<font color=red>     0..|  	    case Exists of</font>
        |  		true -&gt;
<font color=red>     0..|  		    Suffixes = tmp_suffixes(),</font>
<font color=red>     0..|  		    purge_dir(Dir, KeepFiles, Suffixes);</font>
        |  		false -&gt;
        |  		    %% Interrupted change of storage type
        |  		    %% for schema table
<font color=red>     0..|  		    Suffixes = known_suffixes(),</font>
<font color=red>     0..|  		    purge_dir(Dir, KeepFiles, Suffixes),</font>
<font color=red>     0..|  		    mnesia2_lib:set(use_dir, false)</font>
        |  		end;
        |  
        |  	false -&gt;
<font color=red>     0..|  	    ok</font>
        |      end.
        |  
        |  purge_known_files([File | Tail], KeepFiles, Dir, Suffixes) -&gt;
    41..|      case lists:member(File, KeepFiles) of
        |  	true -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	false -&gt;
    41..|  	    case has_known_suffix(File, Suffixes, false) of
        |  		false -&gt;
<font color=red>     0..|  		    ignore;</font>
        |  		true -&gt;
    41..|  		    AbsFile = filename:join([Dir, File]),
    41..|  		    file:delete(AbsFile)
        |  	    end
        |      end,
    41..|      purge_known_files(Tail, KeepFiles, Dir, Suffixes);
        |  purge_known_files([], _KeepFiles, _Dir, _Suffixes) -&gt;
    41..|      ok.
        |  
        |  has_known_suffix(_File, _Suffixes, true) -&gt;
    41..|      true;
        |  has_known_suffix(File, [Suffix | Tail], false) -&gt;
   123..|      has_known_suffix(File, Tail, lists:suffix(Suffix, File));
        |  has_known_suffix(_File, [], Bool) -&gt;
<font color=red>     0..|      Bool.</font>
        |  
    58..|  known_suffixes() -&gt; real_suffixes() ++ tmp_suffixes().
        |  
    58..|  real_suffixes() -&gt;  [".DAT", ".LOG", ".BUP", ".DCL", ".DCD"].
        |  
    58..|  tmp_suffixes() -&gt; [".TMP", ".BUPTMP", ".RET", ".DMP"].
        |  
        |  info() -&gt;
<font color=red>     0..|      Tabs = lists:sort(val({schema, tables})),</font>
<font color=red>     0..|      lists:foreach(fun(T) -&gt; info(T) end, Tabs),</font>
<font color=red>     0..|      ok.</font>
        |  
        |  info(Tab) -&gt;
<font color=red>     0..|      Props = get_table_properties(Tab),</font>
<font color=red>     0..|      io:format("-- Properties for ~w table --- ~n",[Tab]),</font>
<font color=red>     0..|      info2(Tab, Props).</font>
        |  info2(Tab, [{cstruct, _V} | Tail]) -&gt; % Ignore cstruct
<font color=red>     0..|      info2(Tab, Tail);</font>
        |  info2(Tab, [{frag_hash, _V} | Tail]) -&gt; % Ignore frag_hash
<font color=red>     0..|      info2(Tab, Tail);</font>
        |  info2(Tab, [{P, V} | Tail]) -&gt;
<font color=red>     0..|      io:format("~-20w -&gt; ~p~n",[P,V]),</font>
<font color=red>     0..|      info2(Tab, Tail);</font>
        |  info2(_, []) -&gt;
<font color=red>     0..|      io:format("~n", []).</font>
        |  
        |  get_table_properties(Tab) -&gt;
<font color=red>     0..|      try mnesia2_lib:db_match_object(ram_copies, mnesia2_gvar, {{Tab, '_'}, '_'}) of</font>
        |  	RawGvar -&gt;
<font color=red>     0..|  	    case [{Item, Val} || {{_Tab, Item}, Val} &lt;- RawGvar] of</font>
        |  		[] -&gt;
<font color=red>     0..|  		    [];</font>
        |  		Gvar -&gt;
<font color=red>     0..|  		    Size = {size, mnesia2:table_info(Tab, size)},</font>
<font color=red>     0..|  		    Memory = {memory, mnesia2:table_info(Tab, memory)},</font>
<font color=red>     0..|  		    Master = {master_nodes, mnesia2:table_info(Tab, master_nodes)},</font>
<font color=red>     0..|  		    lists:sort([Size, Memory, Master | Gvar])</font>
        |  	    end
        |      catch error:_ -&gt;
<font color=red>     0..|  	    mnesia2:abort({no_exists, Tab, all})</font>
        |      end.
        |  
        |  %%%%%%%%%%% RESTORE %%%%%%%%%%%
        |  
        |  -record(r, {iter = schema,
        |  	    module,
        |  	    table_options = [],
        |  	    default_op = clear_tables,
        |  	    tables = [],
        |  	    opaque,
        |  	    insert_op = error_fun,
        |  	    recs = error_recs
        |  	   }).
        |  
        |  restore(Opaque) -&gt;
<font color=red>     0..|      restore(Opaque, [], mnesia2_monitor:get_env(backup_module)).</font>
        |  restore(Opaque, Args) when is_list(Args) -&gt;
<font color=red>     0..|      restore(Opaque, Args, mnesia2_monitor:get_env(backup_module));</font>
        |  restore(_Opaque, BadArg) -&gt;
<font color=red>     0..|      {aborted, {badarg, BadArg}}.</font>
        |  restore(Opaque, Args, Module) when is_list(Args), is_atom(Module) -&gt;
<font color=red>     0..|      InitR = #r{opaque = Opaque, module = Module},</font>
<font color=red>     0..|      try lists:foldl(fun check_restore_arg/2, InitR, Args) of</font>
        |  	R when is_record(R, r) -&gt;
<font color=red>     0..|  	    case mnesia2_bup:read_schema(R#r.module, Opaque) of</font>
        |  		{error, Reason} -&gt;
<font color=red>     0..|  		    {aborted, Reason};</font>
        |  		BupSchema -&gt;
<font color=red>     0..|  		    schema_transaction(fun() -&gt; do_restore(R, BupSchema) end)</font>
        |  	    end
        |      catch exit:Reason -&gt;
<font color=red>     0..|  	    {aborted, Reason}</font>
        |      end;
        |  restore(_Opaque, Args, Module) -&gt;
<font color=red>     0..|      {aborted, {badarg, Args, Module}}.</font>
        |  
        |  check_restore_arg({module, Mod}, R) when is_atom(Mod) -&gt;
<font color=red>     0..|      R#r{module = Mod};</font>
        |  
        |  check_restore_arg({clear_tables, List}, R) when is_list(List) -&gt;
<font color=red>     0..|      case lists:member(schema, List) of</font>
        |  	false -&gt;
<font color=red>     0..|  	    TableList = [{Tab, clear_tables} || Tab &lt;- List],</font>
<font color=red>     0..|  	    R#r{table_options = R#r.table_options ++ TableList};</font>
        |  	true -&gt;
<font color=red>     0..|  	    exit({badarg, {clear_tables, schema}})</font>
        |      end;
        |  check_restore_arg({recreate_tables, List}, R) when is_list(List) -&gt;
<font color=red>     0..|      case lists:member(schema, List) of</font>
        |  	false -&gt;
<font color=red>     0..|  	    TableList = [{Tab, recreate_tables} || Tab &lt;- List],</font>
<font color=red>     0..|  	    R#r{table_options = R#r.table_options ++ TableList};</font>
        |  	true -&gt;
<font color=red>     0..|  	    exit({badarg, {recreate_tables, schema}})</font>
        |      end;
        |  check_restore_arg({keep_tables, List}, R) when is_list(List) -&gt;
<font color=red>     0..|      TableList = [{Tab, keep_tables} || Tab &lt;- List],</font>
<font color=red>     0..|      R#r{table_options = R#r.table_options ++ TableList};</font>
        |  check_restore_arg({skip_tables, List}, R) when is_list(List) -&gt;
<font color=red>     0..|      TableList = [{Tab, skip_tables} || Tab &lt;- List],</font>
<font color=red>     0..|      R#r{table_options = R#r.table_options ++ TableList};</font>
        |  check_restore_arg({default_op, Op}, R) -&gt;
<font color=red>     0..|      case Op of</font>
<font color=red>     0..|  	clear_tables -&gt; ok;</font>
<font color=red>     0..|  	recreate_tables -&gt; ok;</font>
<font color=red>     0..|  	keep_tables -&gt; ok;</font>
<font color=red>     0..|  	skip_tables -&gt; ok;</font>
        |  	Else -&gt;
<font color=red>     0..|  	    exit({badarg, {bad_default_op, Else}})</font>
        |      end,
<font color=red>     0..|      R#r{default_op = Op};</font>
        |  
        |  check_restore_arg(BadArg,_) -&gt;
<font color=red>     0..|      exit({badarg, BadArg}).</font>
        |  
        |  do_restore(R, BupSchema) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      R2 = restore_schema(BupSchema, R),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, [{restore_op, R2}]),</font>
<font color=red>     0..|      [element(1, TabStruct) || TabStruct &lt;- R2#r.tables].</font>
        |  
        |  arrange_restore(R, Fun, Recs) -&gt;
<font color=red>     0..|      R2 = R#r{insert_op = Fun, recs = Recs},</font>
<font color=red>     0..|      case mnesia2_bup:iterate(R#r.module, fun restore_items/4, R#r.opaque, R2) of</font>
<font color=red>     0..|  	{ok, R3} -&gt; R3#r.recs;</font>
<font color=red>     0..|  	{error, Reason} -&gt; mnesia2:abort(Reason)</font>
        |      end.
        |  
        |  restore_items([Rec | Recs], Header, Schema, R) -&gt;
<font color=red>     0..|      Tab = element(1, Rec),</font>
<font color=red>     0..|      case lists:keysearch(Tab, 1, R#r.tables) of</font>
        |  	{value, {Tab, Where0, Snmp, RecName}} -&gt;
<font color=red>     0..|  	    Where = case Where0 of</font>
        |  			undefined -&gt;
<font color=red>     0..|  			    val({Tab, where_to_commit});</font>
        |  			_ -&gt;
<font color=red>     0..|  			    Where0</font>
        |  		    end,
<font color=red>     0..|  	    {Rest, NRecs} = restore_tab_items([Rec | Recs], Tab,</font>
        |  					      RecName, Where, Snmp,
        |  					      R#r.recs, R#r.insert_op),
<font color=red>     0..|  	    restore_items(Rest, Header, Schema, R#r{recs = NRecs});</font>
        |  	false -&gt;
<font color=red>     0..|  	    Rest = skip_tab_items(Recs, Tab),</font>
<font color=red>     0..|  	    restore_items(Rest, Header, Schema, R)</font>
        |      end;
        |  
        |  restore_items([], _Header, _Schema, R) -&gt;
<font color=red>     0..|      R.</font>
        |  
        |  restore_func(Tab, R) -&gt;
<font color=red>     0..|      case lists:keysearch(Tab, 1, R#r.table_options) of</font>
        |  	{value, {Tab, OP}} -&gt;
<font color=red>     0..|  	    OP;</font>
        |  	false -&gt;
<font color=red>     0..|  	    R#r.default_op</font>
        |      end.
        |  
        |  where_to_commit(Tab, CsList) -&gt;
<font color=red>     0..|      Ram =   [{N, ram_copies} || N &lt;- pick(Tab, ram_copies, CsList, [])],</font>
<font color=red>     0..|      Disc =  [{N, disc_copies} || N &lt;- pick(Tab, disc_copies, CsList, [])],</font>
<font color=red>     0..|      DiscO = [{N, disc_only_copies} || N &lt;- pick(Tab, disc_only_copies, CsList, [])],</font>
<font color=red>     0..|      Ram ++ Disc ++ DiscO.</font>
        |  
        |  %% Changes of the Meta info of schema itself is not allowed
        |  restore_schema([{schema, schema, _List} | Schema], R) -&gt;
<font color=red>     0..|      restore_schema(Schema, R);</font>
        |  restore_schema([{schema, Tab, List} | Schema], R) -&gt;
<font color=red>     0..|      case restore_func(Tab, R) of</font>
        |  	clear_tables -&gt;
<font color=red>     0..|  	    do_clear_table(Tab),</font>
<font color=red>     0..|  	    Snmp = val({Tab, snmp}),</font>
<font color=red>     0..|  	    RecName = val({Tab, record_name}),</font>
<font color=red>     0..|  	    R2 = R#r{tables = [{Tab, undefined, Snmp, RecName} | R#r.tables]},</font>
<font color=red>     0..|  	    restore_schema(Schema, R2);</font>
        |  	recreate_tables -&gt;
<font color=red>     0..|  	    TidTs = case ?catch_val({Tab, cstruct}) of</font>
        |  			{'EXIT', _} -&gt;
<font color=red>     0..|  			    TTs = {_Mod, Tid, Ts} = get(mnesia2_activity_state),</font>
<font color=red>     0..|  			    RunningNodes = val({current, db_nodes}),</font>
<font color=red>     0..|  			    Nodes = mnesia2_lib:intersect(mnesia2_lib:cs_to_nodes(list2cs(List)),</font>
        |  							 RunningNodes),
<font color=red>     0..|  			    mnesia2_locker:wlock_no_exist(Tid, Ts#tidstore.store, Tab, Nodes),</font>
<font color=red>     0..|  			    TTs;</font>
        |  			_ -&gt;
<font color=red>     0..|  			    get_tid_ts_and_lock(Tab, write)</font>
        |  		    end,
<font color=red>     0..|  	    NC    = {cookie, ?unique_cookie},</font>
<font color=red>     0..|  	    List2 = lists:keyreplace(cookie, 1, List, NC),</font>
<font color=red>     0..|  	    Where = where_to_commit(Tab, List2),</font>
<font color=red>     0..|  	    Snmp  = pick(Tab, snmp, List2, []),</font>
<font color=red>     0..|  	    RecName = pick(Tab, record_name, List2, Tab),</font>
<font color=red>     0..|  	    insert_schema_ops(TidTs, [{op, restore_recreate, List2}]),</font>
<font color=red>     0..|  	    R2 = R#r{tables = [{Tab, Where, Snmp, RecName} | R#r.tables]},</font>
<font color=red>     0..|  	    restore_schema(Schema, R2);</font>
        |  	keep_tables -&gt;
<font color=red>     0..|  	    get_tid_ts_and_lock(Tab, write),</font>
<font color=red>     0..|  	    Snmp = val({Tab, snmp}),</font>
<font color=red>     0..|  	    RecName = val({Tab, record_name}),</font>
<font color=red>     0..|  	    R2 = R#r{tables = [{Tab, undefined, Snmp, RecName} | R#r.tables]},</font>
<font color=red>     0..|  	    restore_schema(Schema, R2);</font>
        |  	skip_tables -&gt;
<font color=red>     0..|  	    restore_schema(Schema, R)</font>
        |      end;
        |  
        |  restore_schema([{schema, Tab} | Schema], R) -&gt;
<font color=red>     0..|      do_delete_table(Tab),</font>
<font color=red>     0..|      Tabs = lists:delete(Tab,R#r.tables),</font>
<font color=red>     0..|      restore_schema(Schema, R#r{tables = Tabs});</font>
        |  restore_schema([], R) -&gt;
<font color=red>     0..|      R.</font>
        |  
        |  restore_tab_items([Rec | Rest], Tab, RecName, Where, Snmp, Recs, Op)
        |    when element(1, Rec) == Tab -&gt;
<font color=red>     0..|      NewRecs = Op(Rec, Recs, RecName, Where, Snmp),</font>
<font color=red>     0..|      restore_tab_items(Rest, Tab, RecName, Where, Snmp, NewRecs, Op);</font>
        |  
        |  restore_tab_items(Rest, _Tab, _RecName, _Where, _Snmp, Recs, _Op) -&gt;
<font color=red>     0..|      {Rest, Recs}.</font>
        |  
        |  skip_tab_items([Rec| Rest], Tab)
        |    when element(1, Rec) == Tab -&gt;
<font color=red>     0..|      skip_tab_items(Rest, Tab);</font>
        |  skip_tab_items(Recs, _) -&gt;
<font color=red>     0..|      Recs.</font>
        |  
        |  %%%%%%%%% Dump tables %%%%%%%%%%%%%
        |  dump_tables(Tabs) when is_list(Tabs) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_dump_tables(Tabs) end);</font>
        |  dump_tables(Tabs) -&gt;
<font color=red>     0..|      {aborted, {bad_type, Tabs}}.</font>
        |  
        |  do_dump_tables(Tabs) -&gt;
<font color=red>     0..|      TidTs = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      insert_schema_ops(TidTs, make_dump_tables(Tabs)).</font>
        |  
        |  make_dump_tables([schema | _Tabs]) -&gt;
<font color=red>     0..|      mnesia2:abort({bad_type, schema});</font>
        |  make_dump_tables([Tab | Tabs]) -&gt;
<font color=red>     0..|      get_tid_ts_and_lock(Tab, read),</font>
<font color=red>     0..|      TabDef = get_create_list(Tab),</font>
<font color=red>     0..|      DiscResident =  val({Tab, disc_copies}) ++ val({Tab, disc_only_copies}),</font>
<font color=red>     0..|      verify([], DiscResident,</font>
        |  	   {"Only allowed on ram_copies", Tab, DiscResident}),
<font color=red>     0..|      [{op, dump_table, unknown, TabDef} | make_dump_tables(Tabs)];</font>
        |  make_dump_tables([]) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  %% Merge the local schema with the schema on other nodes
        |  merge_schema() -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; do_merge_schema([]) end).</font>
        |  
        |  merge_schema(UserFun) -&gt;
<font color=red>     0..|      schema_transaction(fun() -&gt; UserFun(fun(Arg) -&gt; do_merge_schema(Arg) end) end).</font>
        |  
        |  do_merge_schema(LockTabs0) -&gt;
<font color=red>     0..|      {_Mod, Tid, Ts} = get_tid_ts_and_lock(schema, write),</font>
<font color=red>     0..|      LockTabs = [{T, tab_to_nodes(T)} || T &lt;- LockTabs0],</font>
<font color=red>     0..|      [get_tid_ts_and_lock(T,write) || {T,_} &lt;- LockTabs],</font>
<font color=red>     0..|      Connected = val(recover_nodes),</font>
<font color=red>     0..|      Running = val({current, db_nodes}),</font>
<font color=red>     0..|      Store = Ts#tidstore.store,</font>
        |      %% Verify that all nodes are locked that might not be the
        |      %% case, if this trans where queued when new nodes where added.
<font color=red>     0..|      case Running -- ets:lookup_element(Store, nodes, 2) of</font>
<font color=red>     0..|  	[] -&gt; ok; %% All known nodes are locked</font>
        |  	Miss -&gt; %% Abort! We don't want the sideeffects below to be executed
<font color=red>     0..|  	    mnesia2:abort({bad_commit, {missing_lock, Miss}})</font>
        |      end,
<font color=red>     0..|      case Connected -- Running of</font>
        |  	[Node | _] = OtherNodes -&gt;
        |  	    %% Time for a schema merging party!
<font color=red>     0..|  	    mnesia2_locker:wlock_no_exist(Tid, Store, schema, [Node]),</font>
<font color=red>     0..|              [mnesia2_locker:wlock_no_exist(</font>
        |                 Tid, Store, T, mnesia2_lib:intersect(Ns, OtherNodes))
<font color=red>     0..|               || {T,Ns} &lt;- LockTabs],</font>
<font color=red>     0..|  	    case fetch_cstructs(Node) of</font>
        |  		{cstructs, Cstructs, RemoteRunning1} -&gt;
<font color=red>     0..|  		    LockedAlready = Running ++ [Node],</font>
<font color=red>     0..|  		    {New, Old} = mnesia2_recover:connect_nodes(RemoteRunning1),</font>
<font color=red>     0..|  		    RemoteRunning = mnesia2_lib:intersect(New ++ Old, RemoteRunning1),</font>
<font color=red>     0..|  		    if</font>
        |  			RemoteRunning /= RemoteRunning1 -&gt;
<font color=red>     0..|  			    mnesia2_lib:error("mnesia2 on ~p could not connect to node(s) ~p~n",</font>
        |  					     [node(), RemoteRunning1 -- RemoteRunning]),
<font color=red>     0..|  			    mnesia2:abort({node_not_running, RemoteRunning1 -- RemoteRunning});</font>
<font color=red>     0..|  			true -&gt; ok</font>
        |  		    end,
<font color=red>     0..|  		    NeedsLock = RemoteRunning -- LockedAlready,</font>
<font color=red>     0..|  		    mnesia2_locker:wlock_no_exist(Tid, Store, schema, NeedsLock),</font>
<font color=red>     0..|                      [mnesia2_locker:wlock_no_exist(Tid, Store, T,</font>
        |                                                    mnesia2_lib:intersect(Ns,NeedsLock))
<font color=red>     0..|                       || {T,Ns} &lt;- LockTabs],</font>
        |  
<font color=red>     0..|  		    NeedsConversion = need_old_cstructs(NeedsLock ++ LockedAlready),</font>
<font color=red>     0..|  		    {value, SchemaCs} = lists:keysearch(schema, #cstruct.name, Cstructs),</font>
<font color=red>     0..|  		    SchemaDef = cs2list(NeedsConversion, SchemaCs),</font>
        |  		    %% Announce that Node is running
<font color=red>     0..|  		    A = [{op, announce_im_running, node(), SchemaDef, Running, RemoteRunning}],</font>
<font color=red>     0..|  		    do_insert_schema_ops(Store, A),</font>
        |  
        |  		    %% Introduce remote tables to local node
<font color=red>     0..|  		    do_insert_schema_ops(Store, make_merge_schema(Node, NeedsConversion, Cstructs)),</font>
        |  
        |  		    %% Introduce local tables to remote nodes
<font color=red>     0..|  		    Tabs = val({schema, tables}),</font>
<font color=red>     0..|  		    Ops = [{op, merge_schema, get_create_list(T)}</font>
<font color=red>     0..|  			   || T &lt;- Tabs,</font>
<font color=red>     0..|  			      not lists:keymember(T, #cstruct.name, Cstructs)],</font>
<font color=red>     0..|  		    do_insert_schema_ops(Store, Ops),</font>
        |  
        |  		    %% Ensure that the txn will be committed on all nodes
<font color=red>     0..|  		    NewNodes = RemoteRunning -- Running,</font>
<font color=red>     0..|  		    mnesia2_lib:set(prepare_op, {announce_im_running,NewNodes}),</font>
<font color=red>     0..|  		    announce_im_running(NewNodes, SchemaCs),</font>
<font color=red>     0..|  		    {merged, Running, RemoteRunning};</font>
        |  		{error, Reason} -&gt;
<font color=red>     0..|  		    {"Cannot get cstructs", Node, Reason};</font>
        |  		{badrpc, Reason} -&gt;
<font color=red>     0..|  		    {"Cannot get cstructs", Node, {badrpc, Reason}}</font>
        |  	    end;
        |  	[] -&gt;
        |  	    %% No more nodes to merge schema with
<font color=red>     0..|  	    not_merged</font>
        |      end.
        |  
        |  fetch_cstructs(Node) -&gt;
<font color=red>     0..|      case need_old_cstructs([Node]) of</font>
        |  	false -&gt;
<font color=red>     0..|  	    rpc:call(Node, mnesia2_controller, get_remote_cstructs, []);</font>
        |  	_Ver -&gt;
<font color=red>     0..|  	    case rpc:call(Node, mnesia2_controller, get_cstructs, []) of</font>
        |  		{cstructs, Cs0, RR} -&gt;
<font color=red>     0..|  		    {cstructs, [list2cs(cs2list(Cs)) || Cs &lt;- Cs0], RR};</font>
<font color=red>     0..|  		Err -&gt; Err</font>
        |  	    end
        |      end.
        |  
        |  need_old_cstructs() -&gt;
<font color=red>     0..|      need_old_cstructs(val({schema, where_to_write})).</font>
        |  
        |  need_old_cstructs(Nodes) -&gt;
<font color=red>     0..|      Filter = fun(Node) -&gt; not mnesia2_monitor:needs_protocol_conversion(Node) end,</font>
<font color=red>     0..|      case lists:dropwhile(Filter, Nodes) of</font>
<font color=red>     0..|  	[] -&gt; false;</font>
        |  	[Node|_] -&gt;
<font color=red>     0..|  	    case rpc:call(Node, mnesia2_lib, val, [{schema,cstruct}]) of</font>
        |  		#cstruct{} -&gt;
        |  		    %% mnesia2_lib:warning("Mnesia2 on ~p do not need to convert cstruct (~p)~n",
        |  		    %% 		       [node(), Node]),
<font color=red>     0..|  		    false;</font>
        |  		{badrpc, _} -&gt;
<font color=red>     0..|  		    need_old_cstructs(lists:delete(Node,Nodes));</font>
        |  		Cs when element(1, Cs) == cstruct, tuple_size(Cs) == 17 -&gt;
<font color=red>     0..|  		    ver4_4_18;			% Without majority</font>
        |  		Cs when element(1, Cs) == cstruct, tuple_size(Cs) == 18 -&gt;
<font color=red>     0..|  		    ver4_4_19;			% With majority</font>
        |  		Cs when element(1, Cs) == cstruct, tuple_size(Cs) == 19 -&gt;
<font color=red>     0..|  		    ver4_6			% With storage_properties</font>
        |  	    end
        |      end.
        |  
        |  tab_to_nodes(Tab) when is_atom(Tab) -&gt;
<font color=red>     0..|      Cs = val({Tab, cstruct}),</font>
<font color=red>     0..|      mnesia2_lib:cs_to_nodes(Cs).</font>
        |  
        |  make_merge_schema(Node, NeedsConv, [Cs | Cstructs]) -&gt;
<font color=red>     0..|      Ops = do_make_merge_schema(Node, NeedsConv, Cs),</font>
<font color=red>     0..|      Ops ++ make_merge_schema(Node, NeedsConv, Cstructs);</font>
        |  make_merge_schema(_Node, _, []) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  %% Merge definitions of schema table
        |  do_make_merge_schema(Node, NeedsConv, RemoteCs = #cstruct{name = schema}) -&gt;
<font color=red>     0..|      Cs = val({schema, cstruct}),</font>
<font color=red>     0..|      Masters = mnesia2_recover:get_master_nodes(schema),</font>
<font color=red>     0..|      HasRemoteMaster = lists:member(Node, Masters),</font>
<font color=red>     0..|      HasLocalMaster = lists:member(node(), Masters),</font>
<font color=red>     0..|      Force = HasLocalMaster or HasRemoteMaster,</font>
        |      %% What is the storage types opinions?
<font color=red>     0..|      StCsLocal   = mnesia2_lib:cs_to_storage_type(node(), Cs),</font>
<font color=red>     0..|      StRcsLocal  = mnesia2_lib:cs_to_storage_type(node(), RemoteCs),</font>
<font color=red>     0..|      StCsRemote  = mnesia2_lib:cs_to_storage_type(Node, Cs),</font>
<font color=red>     0..|      StRcsRemote = mnesia2_lib:cs_to_storage_type(Node, RemoteCs),</font>
        |  
<font color=red>     0..|      if</font>
        |  	Cs#cstruct.cookie == RemoteCs#cstruct.cookie,
        |  	Cs#cstruct.version == RemoteCs#cstruct.version -&gt;
        |  	    %% Great, we have the same cookie and version
        |  	    %% and do not need to merge cstructs
<font color=red>     0..|  	    [];</font>
        |  
        |  	Cs#cstruct.cookie /= RemoteCs#cstruct.cookie,
        |  	Cs#cstruct.disc_copies /= [],
        |  	RemoteCs#cstruct.disc_copies /= [] -&gt;
        |  	    %% Both cstructs involves disc nodes
        |  	    %% and we cannot merge them
<font color=red>     0..|  	    if</font>
        |  		HasLocalMaster == true,
        |  		HasRemoteMaster == false -&gt;
        |  		    %% Choose local cstruct,
        |  		    %% since it's the master
<font color=red>     0..|  		    [{op, merge_schema, cs2list(NeedsConv, Cs)}];</font>
        |  
        |  		HasRemoteMaster == true,
        |  		HasLocalMaster == false -&gt;
        |  		    %% Choose remote cstruct,
        |  		    %% since it's the master
<font color=red>     0..|  		    [{op, merge_schema, cs2list(NeedsConv, RemoteCs)}];</font>
        |  
        |  		true -&gt;
<font color=red>     0..|  		    Str = io_lib:format("Incompatible schema cookies. "</font>
        |  					"Please, restart from old backup."
        |  					"~w = ~w, ~w = ~w~n",
        |  					[Node, cs2list(RemoteCs), node(), cs2list(Cs)]),
<font color=red>     0..|  		    throw(Str)</font>
        |  	    end;
        |  
        |  	StCsLocal /= StRcsLocal, StRcsLocal /= unknown, StCsLocal /= ram_copies -&gt;
<font color=red>     0..|  	    Str = io_lib:format("Incompatible schema storage types (local). "</font>
        |  				"on ~w storage ~w, on ~w storage ~w~n",
        |  				[node(), StCsLocal, Node, StRcsLocal]),
<font color=red>     0..|  	    throw(Str);</font>
        |  	StCsRemote /= StRcsRemote, StCsRemote /= unknown, StRcsRemote /= ram_copies -&gt;
<font color=red>     0..|  	    Str = io_lib:format("Incompatible schema storage types (remote). "</font>
        |  				"on ~w cs ~w, on ~w rcs ~w~n",
        |  				[node(), cs2list(Cs), Node, cs2list(RemoteCs)]),
<font color=red>     0..|  	    throw(Str);</font>
        |  
        |       	Cs#cstruct.disc_copies /= [] -&gt;
        |  	    %% Choose local cstruct,
        |  	    %% since it involves disc nodes
<font color=red>     0..|  	    MergedCs = merge_cstructs(Cs, RemoteCs, Force),</font>
<font color=red>     0..|  	    [{op, merge_schema, cs2list(NeedsConv, MergedCs)}];</font>
        |  
        |  	RemoteCs#cstruct.disc_copies /= [] -&gt;
        |  	    %% Choose remote cstruct,
        |  	    %% since it involves disc nodes
<font color=red>     0..|  	    MergedCs = merge_cstructs(RemoteCs, Cs, Force),</font>
<font color=red>     0..|  	    [{op, merge_schema, cs2list(NeedsConv, MergedCs)}];</font>
        |  
        |  	Cs &gt; RemoteCs -&gt;
        |  	    %% Choose remote cstruct
<font color=red>     0..|  	    MergedCs = merge_cstructs(RemoteCs, Cs, Force),</font>
<font color=red>     0..|  	    [{op, merge_schema, cs2list(NeedsConv, MergedCs)}];</font>
        |  
        |  	true -&gt;
        |  	    %% Choose local cstruct
<font color=red>     0..|  	    MergedCs = merge_cstructs(Cs, RemoteCs, Force),</font>
<font color=red>     0..|  	    [{op, merge_schema, cs2list(NeedsConv, MergedCs)}]</font>
        |      end;
        |  
        |  %% Merge definitions of normal table
        |  do_make_merge_schema(Node, NeedsConv, RemoteCs = #cstruct{}) -&gt;
<font color=red>     0..|      Tab = RemoteCs#cstruct.name,</font>
<font color=red>     0..|      Masters = mnesia2_recover:get_master_nodes(schema),</font>
<font color=red>     0..|      HasRemoteMaster = lists:member(Node, Masters),</font>
<font color=red>     0..|      HasLocalMaster = lists:member(node(), Masters),</font>
<font color=red>     0..|      Force = HasLocalMaster or HasRemoteMaster,</font>
<font color=red>     0..|      case ?catch_val({Tab, cstruct}) of</font>
        |  	{'EXIT', _} -&gt;
        |  	    %% A completely new table, created while Node was down
<font color=red>     0..|  	    [{op, merge_schema, cs2list(NeedsConv, RemoteCs)}];</font>
        |  	Cs when Cs#cstruct.cookie == RemoteCs#cstruct.cookie -&gt;
<font color=red>     0..|  	    if</font>
        |  		Cs#cstruct.version == RemoteCs#cstruct.version -&gt;
        |  		    %% We have exactly the same version of the
        |  		    %% table def
<font color=red>     0..|  		    [];</font>
        |  
        |  		Cs#cstruct.version &gt; RemoteCs#cstruct.version -&gt;
        |  		    %% Oops, we have different versions
        |  		    %% of the table def, lets merge them.
        |  		    %% The only changes that may have occurred
        |  		    %% is that new replicas may have been added.
<font color=red>     0..|  		    MergedCs = merge_cstructs(Cs, RemoteCs, Force),</font>
<font color=red>     0..|  		    [{op, merge_schema, cs2list(NeedsConv, MergedCs)}];</font>
        |  
        |  		Cs#cstruct.version &lt; RemoteCs#cstruct.version -&gt;
        |  		    %% Oops, we have different versions
        |  		    %% of the table def, lets merge them
<font color=red>     0..|  		    MergedCs = merge_cstructs(RemoteCs, Cs, Force),</font>
<font color=red>     0..|  		    [{op, merge_schema, cs2list(NeedsConv, MergedCs)}]</font>
        |  	    end;
        |  	Cs -&gt;
        |  	    %% Different cookies, not possible to merge
<font color=red>     0..|  	    if</font>
        |  		HasLocalMaster == true,
        |  		HasRemoteMaster == false -&gt;
        |  		    %% Choose local cstruct,
        |  		    %% since it's the master
<font color=red>     0..|  		    [{op, merge_schema, cs2list(NeedsConv, Cs)}];</font>
        |  
        |  		HasRemoteMaster == true,
        |  		HasLocalMaster == false -&gt;
        |  		    %% Choose remote cstruct,
        |  		    %% since it's the master
<font color=red>     0..|  		    [{op, merge_schema, cs2list(NeedsConv, RemoteCs)}];</font>
        |  
        |  		true -&gt;
<font color=red>     0..|  		    Str = io_lib:format("Bad cookie in table definition"</font>
        |  					" ~w: ~w = ~w, ~w = ~w~n",
        |  					[Tab, node(), Cs, Node, RemoteCs]),
<font color=red>     0..|  		    throw(Str)</font>
        |  	    end
        |      end.
        |  
        |  %% Change of table definitions (cstructs) requires all replicas
        |  %% of the table to be active. New replicas, db_nodes and tables
        |  %% may however be added even if some replica is inactive. These
        |  %% invariants must be enforced in order to allow merge of cstructs.
        |  %%
        |  %% Returns a new cstruct or issues a fatal error
        |  merge_cstructs(Cs, RemoteCs, Force) -&gt;
<font color=red>     0..|      verify_cstruct(Cs),</font>
<font color=red>     0..|      try do_merge_cstructs(Cs, RemoteCs, Force) of</font>
        |  	MergedCs when is_record(MergedCs, cstruct) -&gt;
<font color=red>     0..|  	    MergedCs</font>
        |      catch exit:{aborted, _Reason} when Force == true -&gt;
<font color=red>     0..|  	    Cs;</font>
<font color=red>     0..|  	  exit:Reason -&gt; exit(Reason);</font>
<font color=red>     0..|  	  error:Reason -&gt; exit(Reason)</font>
        |      end.
        |  
        |  do_merge_cstructs(Cs, RemoteCs, Force) -&gt;
<font color=red>     0..|      verify_cstruct(RemoteCs),</font>
<font color=red>     0..|      Ns = mnesia2_lib:uniq(mnesia2_lib:cs_to_nodes(Cs) ++</font>
        |  			 mnesia2_lib:cs_to_nodes(RemoteCs)),
<font color=red>     0..|      {AnythingNew, MergedCs} =</font>
        |  	merge_storage_type(Ns, false, Cs, RemoteCs, Force),
<font color=red>     0..|      MergedCs2 = merge_versions(AnythingNew, MergedCs, RemoteCs, Force),</font>
<font color=red>     0..|      verify_cstruct(MergedCs2),</font>
<font color=red>     0..|      MergedCs2.</font>
        |  
        |  merge_storage_type([N | Ns], AnythingNew, Cs, RemoteCs, Force) -&gt;
<font color=red>     0..|      Local = mnesia2_lib:cs_to_storage_type(N, Cs),</font>
<font color=red>     0..|      Remote = mnesia2_lib:cs_to_storage_type(N, RemoteCs),</font>
<font color=red>     0..|      case compare_storage_type(true, Local, Remote) of</font>
        |  	{same, _Storage} -&gt;
<font color=red>     0..|  	    merge_storage_type(Ns, AnythingNew, Cs, RemoteCs, Force);</font>
        |  	{diff, Storage} -&gt;
<font color=red>     0..|  	    Cs2 = change_storage_type(N, Storage, Cs),</font>
<font color=red>     0..|  	    merge_storage_type(Ns, true, Cs2, RemoteCs, Force);</font>
        |  	incompatible when Force == true -&gt;
<font color=red>     0..|  	    merge_storage_type(Ns, AnythingNew, Cs, RemoteCs, Force);</font>
        |  	Other -&gt;
<font color=red>     0..|  	    Str = io_lib:format("Cannot merge storage type for node ~w "</font>
        |  				"in cstruct ~w with remote cstruct ~w (~w)~n",
        |  				[N, Cs, RemoteCs, Other]),
<font color=red>     0..|  	    throw(Str)</font>
        |      end;
        |  merge_storage_type([], AnythingNew, MergedCs, _RemoteCs, _Force) -&gt;
<font color=red>     0..|      {AnythingNew, MergedCs}.</font>
        |  
        |  compare_storage_type(_Retry, Any, Any) -&gt;
<font color=red>     0..|      {same, Any};</font>
        |  compare_storage_type(_Retry, unknown, Any) -&gt;
<font color=red>     0..|      {diff, Any};</font>
        |  compare_storage_type(_Retry, ram_copies, disc_copies) -&gt;
<font color=red>     0..|      {diff, disc_copies};</font>
        |  compare_storage_type(_Retry, disc_copies, disc_only_copies) -&gt;
<font color=red>     0..|      {diff, disc_only_copies};</font>
        |  compare_storage_type(true, One, Another) -&gt;
<font color=red>     0..|      compare_storage_type(false, Another, One);</font>
        |  compare_storage_type(false, _One, _Another) -&gt;
<font color=red>     0..|      incompatible.</font>
        |  
        |  change_storage_type(N, ram_copies, Cs) -&gt;
<font color=red>     0..|      Nodes = [N | Cs#cstruct.ram_copies],</font>
<font color=red>     0..|      Cs#cstruct{ram_copies = mnesia2_lib:uniq(Nodes)};</font>
        |  change_storage_type(N, disc_copies, Cs) -&gt;
<font color=red>     0..|      Nodes = [N | Cs#cstruct.disc_copies],</font>
<font color=red>     0..|      Cs#cstruct{disc_copies = mnesia2_lib:uniq(Nodes)};</font>
        |  change_storage_type(N, disc_only_copies, Cs) -&gt;
<font color=red>     0..|      Nodes = [N | Cs#cstruct.disc_only_copies],</font>
<font color=red>     0..|      Cs#cstruct{disc_only_copies = mnesia2_lib:uniq(Nodes)}.</font>
        |  
        |  %% BUGBUG: Verify match of frag info; equalit demanded for all but add_node
        |  
        |  merge_versions(AnythingNew, Cs, RemoteCs, Force) -&gt;
<font color=red>     0..|      if</font>
        |  	Cs#cstruct.name == schema -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	Cs#cstruct.name /= schema,
        |  	Cs#cstruct.cookie == RemoteCs#cstruct.cookie -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	Force == true -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	true -&gt;
<font color=red>     0..|  	    Str = io_lib:format("Bad cookies. Cannot merge definitions of "</font>
        |  				"table ~w. Local = ~w, Remote = ~w~n",
        |  				[Cs#cstruct.name, Cs, RemoteCs]),
<font color=red>     0..|  	    throw(Str)</font>
        |      end,
<font color=red>     0..|      if</font>
        |  	Cs#cstruct.name == RemoteCs#cstruct.name,
        |  	Cs#cstruct.type == RemoteCs#cstruct.type,
        |  	Cs#cstruct.local_content == RemoteCs#cstruct.local_content,
        |  	Cs#cstruct.attributes == RemoteCs#cstruct.attributes,
        |  	Cs#cstruct.index == RemoteCs#cstruct.index,
        |  	Cs#cstruct.snmp == RemoteCs#cstruct.snmp,
        |  	Cs#cstruct.access_mode == RemoteCs#cstruct.access_mode,
        |  	Cs#cstruct.majority == RemoteCs#cstruct.majority,
        |  	Cs#cstruct.load_order == RemoteCs#cstruct.load_order,
        |  	Cs#cstruct.user_properties == RemoteCs#cstruct.user_properties -&gt;
<font color=red>     0..|  	    do_merge_versions(AnythingNew, Cs, RemoteCs);</font>
        |  	Force == true -&gt;
<font color=red>     0..|  	    do_merge_versions(AnythingNew, Cs, RemoteCs);</font>
        |  	true -&gt;
<font color=red>     0..|  	    Str1 = io_lib:format("Cannot merge definitions of "</font>
        |  				"table ~w. Local = ~w, Remote = ~w~n",
        |  				[Cs#cstruct.name, Cs, RemoteCs]),
<font color=red>     0..|  	    throw(Str1)</font>
        |      end.
        |  
        |  do_merge_versions(AnythingNew, MergedCs, RemoteCs) -&gt;
<font color=red>     0..|      {{Major1, Minor1}, _Detail1} = MergedCs#cstruct.version,</font>
<font color=red>     0..|      {{Major2, Minor2}, _Detail2} = RemoteCs#cstruct.version,</font>
<font color=red>     0..|      if</font>
        |  	AnythingNew == false -&gt;
<font color=red>     0..|  	    MergedCs;</font>
        |  	MergedCs#cstruct.version == RemoteCs#cstruct.version -&gt;
<font color=red>     0..|  	    V = {{Major1, Minor1}, dummy},</font>
<font color=red>     0..|  	    incr_version(MergedCs#cstruct{version = V});</font>
        |  	Major1 == Major2 -&gt;
<font color=red>     0..|  	    Minor = lists:max([Minor1, Minor2]),</font>
<font color=red>     0..|  	    V = {{Major1, Minor}, dummy},</font>
<font color=red>     0..|  	    incr_version(MergedCs#cstruct{version = V});</font>
        |  	Major1 /= Major2 -&gt;
<font color=red>     0..|  	    Major = lists:max([Major1, Major2]),</font>
<font color=red>     0..|  	    V = {{Major, 0}, dummy},</font>
<font color=red>     0..|  	    incr_version(MergedCs#cstruct{version = V})</font>
        |      end.
        |  
        |  %% Verify the basics
        |  verify_merge(RemoteCs) -&gt;
<font color=red>     0..|      Tab = RemoteCs#cstruct.name,</font>
<font color=red>     0..|      Masters = mnesia2_recover:get_master_nodes(schema),</font>
<font color=red>     0..|      HasRemoteMaster = Masters /= [],</font>
<font color=red>     0..|      case ?catch_val({Tab, cstruct}) of</font>
        |  	{'EXIT', _} -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	Cs -&gt;
<font color=red>     0..|  	    StCsLocal   = mnesia2_lib:cs_to_storage_type(node(), Cs),</font>
<font color=red>     0..|  	    StRcsLocal  = mnesia2_lib:cs_to_storage_type(node(), RemoteCs),</font>
<font color=red>     0..|  	    if</font>
<font color=red>     0..|  		StCsLocal  == StRcsLocal -&gt;   ok;</font>
<font color=red>     0..|  		StCsLocal  == unknown -&gt;      ok;</font>
        |  		(StRcsLocal == unknown), (HasRemoteMaster == false) -&gt;
<font color=red>     0..|  		    {merge_error, Cs, RemoteCs};</font>
        |  		%%  Trust the merger
<font color=red>     0..|  		true  -&gt; ok</font>
        |  	    end
        |      end.
        |  
        |  announce_im_running([N | Ns], SchemaCs) -&gt;
<font color=red>     0..|      {L1, L2} = mnesia2_recover:connect_nodes([N]),</font>
<font color=red>     0..|      case lists:member(N, L1) or lists:member(N, L2) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    mnesia2_lib:add({current, db_nodes}, N),</font>
<font color=red>     0..|  	    mnesia2_controller:add_active_replica(schema, N, SchemaCs);</font>
        |  	false -&gt;
<font color=red>     0..|  	    mnesia2_lib:error("Mnesia2 on ~p could not connect to node ~p~n",</font>
        |  			     [node(), N]),
<font color=red>     0..|  	    mnesia2:abort({node_not_running, N})</font>
        |      end,
<font color=red>     0..|      announce_im_running(Ns, SchemaCs);</font>
        |  announce_im_running([], _) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  unannounce_im_running([N | Ns]) -&gt;
<font color=red>     0..|      mnesia2_lib:del({current, db_nodes}, N),</font>
<font color=red>     0..|      mnesia2_controller:del_active_replica(schema, N),</font>
<font color=red>     0..|      unannounce_im_running(Ns);</font>
        |  unannounce_im_running([]) -&gt;
<font color=red>     0..|      ok.</font>
        |  
</pre>
</body>
</html>
