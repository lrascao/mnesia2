<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>/home/travis/build/lrascao/mnesia2/logs/ct_run.test1128@testing-worker-linux-docker-26d6cbdf-3358-linux-2.2016-04-10_22.41.27/lrascao.mnesia2.mnesia2_extra_light_SUITE.logs/run.2016-04-10_22.41.50/mnesia2_registry.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/lrascao/mnesia2/ebin/mnesia2_registry.erl by COVER 2016-04-10 at 22:42:46

****************************************************************************

        |  %%
        |  %% %CopyrightBegin%
        |  %% 
        |  %% Copyright Ericsson AB 1998-2010. All Rights Reserved.
        |  %% 
        |  %% Licensed under the Apache License, Version 2.0 (the "License");
        |  %% you may not use this file except in compliance with the License.
        |  %% You may obtain a copy of the License at
        |  %%
        |  %%     http://www.apache.org/licenses/LICENSE-2.0
        |  %%
        |  %% Unless required by applicable law or agreed to in writing, software
        |  %% distributed under the License is distributed on an "AS IS" BASIS,
        |  %% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        |  %% See the License for the specific language governing permissions and
        |  %% limitations under the License.
        |  %% 
        |  %% %CopyrightEnd%
        |  %%
        |  
        |  %%
        |  -module(mnesia2_registry).
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% File    : mnesia2_registry.erl
        |  %%% Purpose : Support dump and restore of a registry on a C-node
        |  %%%           This is an OTP internal module and is not public available.
        |  %%%
        |  %%% Example : Dump some hardcoded records into the Mnesia2 table Tab
        |  %%%
        |  %%% 	  case rpc:call(Node, mnesia2_registry, start_dump, [Tab, self()]) of
        |  %%% 	     Pid when pid(Pid) -&gt;
        |  %%% 		 Pid ! {write, key1, key_size1, val_type1, val_size1, val1},
        |  %%% 		 Pid ! {delete, key3},
        |  %%% 		 Pid ! {write, key2, key_size2, val_type2, val_size2, val2},
        |  %%% 		 Pid ! {write, key4, key_size4, val_type4, val_size4, val4},
        |  %%% 		 Pid ! {commit, self()},
        |  %%% 		 receive
        |  %%% 		     {ok, Pid} -&gt;
        |  %%% 			 ok;
        |  %%% 		     {'EXIT', Pid, Reason} -&gt;
        |  %%% 			 exit(Reason)
        |  %%% 		 end;
        |  %%% 	     {badrpc, Reason} -&gt;
        |  %%% 		 exit(Reason)
        |  %%% 	 end.
        |  %%%
        |  %%% Example : Restore the corresponding Mnesia2 table Tab
        |  %%%
        |  %%% 	  case rpc:call(Node, mnesia2_registry, start_restore, [Tab, self()]) of
        |  %%% 	     {size, Pid, N, LargestKey, LargestVal} -&gt;
        |  %%% 		 Pid ! {send_records, self()},
        |  %%%              Fun = fun() -&gt;
        |  %%%                        receive
        |  %%%                            {restore, KeySize, ValSize, ValType, Key, Val} -&gt; 
        |  %%%                                {Key, Val};
        |  %%% 		               {'EXIT', Pid, Reason} -&gt;
        |  %%% 			           exit(Reason)
        |  %%%                        end
        |  %%% 		       end,
        |  %%%              lists:map(Fun, lists:seq(1, N));
        |  %%% 	     {badrpc, Reason} -&gt;
        |  %%% 		 exit(Reason)
        |  %%% 	 end.
        |  %%%
        |  %%%----------------------------------------------------------------------
        |  
        |  %% External exports
        |  %% Avoid warning for local function max/2 clashing with autoimported BIF.
        |  -compile({no_auto_import,[max/2]}).
        |  -export([start_dump/2, start_restore/2]).
        |  -export([create_table/1, create_table/2]).
        |  
        |  %% Internal exports 
        |  -export([init/4]).
        |  
        |  -record(state, {table, ops = [], link_to}).
        |  
        |  -record(registry_entry, {key, key_size, val_type, val_size, val}).
        |  
        |  -record(size, {pid = self(), n_values = 0, largest_key = 0, largest_val = 0}).
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% Client
        |  %%%----------------------------------------------------------------------
        |  
        |  start(Type, Tab, LinkTo) -&gt;
<font color=red>     0..|      Starter = self(),</font>
<font color=red>     0..|      Args = [Type, Starter, LinkTo, Tab],</font>
<font color=red>     0..|      Pid = spawn_link(?MODULE, init, Args),</font>
        |      %% The receiver process may unlink the current process
<font color=red>     0..|      receive</font>
        |  	{ok, Res} -&gt;
<font color=red>     0..|  	    Res;</font>
        |  	{'EXIT', Pid, Reason} when LinkTo == Starter -&gt;
<font color=red>     0..|  	    exit(Reason)</font>
        |      end.
        |  
        |  %% Starts a receiver process and optionally creates a Mnesia2 table
        |  %% with suitable default values. Returns the Pid of the receiver process
        |  %% 
        |  %% The receiver process accumulates Mnesia2 operations and performs
        |  %% all operations or none at commit. The understood messages are:
        |  %% 
        |  %%    {write, Key, KeySize, ValType, ValSize, Val} -&gt;
        |  %%        accumulates mnesia2:write({Tab, Key, KeySize, ValType, ValSize, Val})
        |  %%                                                    (no reply)
        |  %%    {delete, Key}     -&gt;
        |  %%        accumulates mnesia2:delete({Tab, Key})       (no reply)
        |  %%    {commit, ReplyTo} -&gt;
        |  %%        commits all accumulated operations
        |  %%        and stops the process                       (replies {ok, Pid})
        |  %%    abort             -&gt;
        |  %%        stops the process                           (no reply)
        |  %%    
        |  %% The receiver process is linked to the process with the process identifier
        |  %% LinkTo. If some error occurs the receiver process will invoke exit(Reason)
        |  %% and it is up to he LinkTo process to act properly when it receives an exit
        |  %% signal.
        |  
        |  start_dump(Tab, LinkTo) -&gt;
<font color=red>     0..|      start(dump, Tab, LinkTo).</font>
        |  
        |  %% Starts a sender process which sends restore messages back to the
        |  %% LinkTo process. But first are some statistics about the table
        |  %% determined and returned as a 5-tuple:
        |  %% 
        |  %%    {size, SenderPid, N, LargestKeySize, LargestValSize}
        |  %%
        |  %% where N is the number of records in the table. Then the sender process
        |  %% waits for a 2-tuple message:
        |  %% 
        |  %%    {send_records, ReplyTo}
        |  %%
        |  %% At last N 6-tuple messages is sent to the ReplyTo process:
        |  %% 
        |  %%    ReplyTo !  {restore, KeySize, ValSize, ValType, Key, Val}
        |  %%
        |  %% If some error occurs the receiver process will invoke exit(Reason)
        |  %% and it is up to he LinkTo process to act properly when it receives an
        |  %% exit signal.
        |  
        |  start_restore(Tab, LinkTo) -&gt;
<font color=red>     0..|      start(restore, Tab, LinkTo).</font>
        |  
        |  
        |  %% Optionally creates the Mnesia2 table Tab with suitable default values.
        |  %% Returns ok or EXIT's
        |  create_table(Tab) -&gt;
<font color=red>     0..|      Storage = mnesia2:table_info(schema, storage_type),</font>
<font color=red>     0..|      create_table(Tab, [{Storage, [node()]}]).</font>
        |  
        |  create_table(Tab, TabDef) -&gt;
<font color=red>     0..|      Attrs = record_info(fields, registry_entry),</font>
<font color=red>     0..|      case mnesia2:create_table(Tab, [{attributes, Attrs} | TabDef]) of</font>
        |  	{atomic, ok} -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	{aborted, {already_exists, Tab}} -&gt;
<font color=red>     0..|  	    ok;</font>
        |  	{aborted, Reason} -&gt;
<font color=red>     0..|  	    exit(Reason)</font>
        |      end.
        |      
        |  %%%----------------------------------------------------------------------
        |  %%% Server
        |  %%%----------------------------------------------------------------------
        |  
        |  init(Type, Starter, LinkTo, Tab) -&gt;
<font color=red>     0..|      if</font>
        |  	LinkTo /= Starter -&gt;
<font color=red>     0..|  	    link(LinkTo),</font>
<font color=red>     0..|  	    unlink(Starter);</font>
        |  	true -&gt;
<font color=red>     0..|  	    ignore</font>
        |      end,
<font color=red>     0..|      case Type of</font>
        |  	dump -&gt;
<font color=red>     0..|  	    Starter ! {ok, self()},</font>
<font color=red>     0..|  	    dump_loop(#state{table = Tab, link_to = LinkTo});</font>
        |  	restore -&gt;
<font color=red>     0..|  	    restore_table(Tab, Starter, LinkTo)</font>
        |      end.
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% Dump loop    
        |  %%%----------------------------------------------------------------------
        |  
        |  dump_loop(S) -&gt;
<font color=red>     0..|      Tab = S#state.table,</font>
<font color=red>     0..|      Ops = S#state.ops,</font>
<font color=red>     0..|      receive</font>
        |  	{write, Key, KeySize, ValType, ValSize, Val} -&gt;
<font color=red>     0..|  	    RE = #registry_entry{key = Key,</font>
        |  				 key_size = KeySize,
        |  				 val_type = ValType,
        |  				 val_size = ValSize,
        |  				 val = Val},
<font color=red>     0..|  	    dump_loop(S#state{ops = [{write, RE} | Ops]});</font>
        |  	{delete, Key} -&gt;
<font color=red>     0..|  	    dump_loop(S#state{ops = [{delete, Key} | Ops]});</font>
        |  	{commit, ReplyTo} -&gt;
<font color=red>     0..|  	    create_table(Tab),</font>
<font color=red>     0..|  	    RecName = mnesia2:table_info(Tab, record_name),</font>
        |  	    %% The Ops are in reverse order, but there is no need
        |  	    %% for reversing the list of accumulated operations
<font color=red>     0..|  	    case mnesia2:transaction(fun handle_ops/3, [Tab, RecName, Ops]) of</font>
        |                  {atomic, ok} -&gt;
<font color=red>     0..|                      ReplyTo ! {ok, self()},</font>
<font color=red>     0..|                      stop(S#state.link_to);</font>
        |                  {aborted, Reason} -&gt;
<font color=red>     0..|                      exit({aborted, Reason})</font>
        |              end;
        |  	abort -&gt;
<font color=red>     0..|  	    stop(S#state.link_to);</font>
        |          BadMsg -&gt;
<font color=red>     0..|              exit({bad_message, BadMsg})					   </font>
        |      end.
        |  
        |  stop(LinkTo) -&gt;
<font color=red>     0..|      unlink(LinkTo),</font>
<font color=red>     0..|      exit(normal).</font>
        |  
        |  %% Grab a write lock for the entire table
        |  %% and iterate over all accumulated operations
        |  handle_ops(Tab, RecName, Ops) -&gt;
<font color=red>     0..|      mnesia2:write_lock_table(Tab),</font>
<font color=red>     0..|      do_handle_ops(Tab, RecName, Ops).</font>
        |  
        |  do_handle_ops(Tab, RecName, [{write, RegEntry} | Ops]) -&gt;
<font color=red>     0..|      Record = setelement(1, RegEntry, RecName),</font>
<font color=red>     0..|      mnesia2:write(Tab, Record, write),</font>
<font color=red>     0..|      do_handle_ops(Tab, RecName, Ops);</font>
        |  do_handle_ops(Tab, RecName, [{delete, Key} | Ops]) -&gt;
<font color=red>     0..|      mnesia2:delete(Tab, Key, write),</font>
<font color=red>     0..|      do_handle_ops(Tab, RecName, Ops);</font>
        |  do_handle_ops(_Tab, _RecName, []) -&gt;
<font color=red>     0..|      ok.</font>
        |      
        |  %%%----------------------------------------------------------------------
        |  %%% Restore table
        |  %%%----------------------------------------------------------------------
        |  
        |  restore_table(Tab, Starter, LinkTo) -&gt;
<font color=red>     0..|      Pat = mnesia2:table_info(Tab, wild_pattern),</font>
<font color=red>     0..|      Fun = fun() -&gt; mnesia2:match_object(Tab, Pat, read) end,</font>
<font color=red>     0..|      case mnesia2:transaction(Fun) of</font>
        |  	{atomic, AllRecords} -&gt;
<font color=red>     0..|  	    Size = calc_size(AllRecords, #size{}),</font>
<font color=red>     0..|  	    Starter ! {ok, Size},</font>
<font color=red>     0..|  	    receive</font>
        |  		{send_records, ReplyTo} -&gt; 
<font color=red>     0..|  		    send_records(AllRecords, ReplyTo),</font>
<font color=red>     0..|  		    unlink(LinkTo),</font>
<font color=red>     0..|  		    exit(normal);</font>
        |  		BadMsg -&gt;
<font color=red>     0..|  		    exit({bad_message, BadMsg})</font>
        |  	    end;
        |  	{aborted, Reason} -&gt;
<font color=red>     0..|              exit(Reason)</font>
        |      end.
        |  
        |  calc_size([H | T], S) -&gt;
<font color=red>     0..|      KeySize = max(element(#registry_entry.key_size, H), S#size.largest_key),</font>
<font color=red>     0..|      ValSize = max(element(#registry_entry.val_size, H), S#size.largest_val),</font>
<font color=red>     0..|      N = S#size.n_values + 1,</font>
<font color=red>     0..|      calc_size(T, S#size{n_values = N, largest_key = KeySize, largest_val = ValSize});</font>
        |  calc_size([], Size) -&gt;
<font color=red>     0..|      Size.</font>
        |  
<font color=red>     0..|  max(New, Old) when New &gt; Old -&gt; New;</font>
<font color=red>     0..|  max(_New, Old) -&gt; Old.</font>
        |  
        |  send_records([H | T], ReplyTo) -&gt;
<font color=red>     0..|      KeySize = element(#registry_entry.key_size, H),</font>
<font color=red>     0..|      ValSize = element(#registry_entry.val_size, H),</font>
<font color=red>     0..|      ValType = element(#registry_entry.val_type, H),</font>
<font color=red>     0..|      Key = element(#registry_entry.key, H),</font>
<font color=red>     0..|      Val = element(#registry_entry.val, H),</font>
<font color=red>     0..|      ReplyTo ! {restore, KeySize, ValSize, ValType, Key, Val},</font>
<font color=red>     0..|      send_records(T, ReplyTo);</font>
        |  send_records([], _ReplyTo) -&gt;
<font color=red>     0..|      ok.</font>
        |  
</pre>
</body>
</html>
