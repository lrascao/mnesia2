<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>/home/travis/build/lrascao/mnesia2/logs/ct_run.test5245@testing-worker-linux-docker-00d9c4f9-3359-linux-2.2016-04-10_22.52.44/lrascao.mnesia2.mnesia2_extra_light_SUITE.logs/run.2016-04-10_22.53.10/mnesia2_loader.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/lrascao/mnesia2/ebin/mnesia2_loader.erl by COVER 2016-04-10 at 22:54:07

****************************************************************************

        |  %%
        |  %% %CopyrightBegin%
        |  %%
        |  %% Copyright Ericsson AB 1998-2014. All Rights Reserved.
        |  %%
        |  %% Licensed under the Apache License, Version 2.0 (the "License");
        |  %% you may not use this file except in compliance with the License.
        |  %% You may obtain a copy of the License at
        |  %%
        |  %%     http://www.apache.org/licenses/LICENSE-2.0
        |  %%
        |  %% Unless required by applicable law or agreed to in writing, software
        |  %% distributed under the License is distributed on an "AS IS" BASIS,
        |  %% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        |  %% See the License for the specific language governing permissions and
        |  %% limitations under the License.
        |  %%
        |  %% %CopyrightEnd%
        |  %%
        |  
        |  %%
        |  %%% Purpose : Loads tables from local disc or from remote node
        |  
        |  -module(mnesia2_loader).
        |  
        |  %% Mnesia2 internal stuff
        |  -export([disc_load_table/2,
        |  	 net_load_table/4,
        |  	 send_table/3]).
        |  
        |  -export([spawned_receiver/8]).    %% Spawned lock taking process
        |  
        |  -import(mnesia2_lib, [set/2, fatal/2, verbose/2, dbg_out/2]).
        |  
        |  -include("mnesia2.hrl").
        |  
        |  val(Var) -&gt;
<font color=red>     0..|      case ?catch_val(Var) of</font>
<font color=red>     0..|  	{'EXIT', _} -&gt; mnesia2_lib:other_val(Var);</font>
<font color=red>     0..|  	Value -&gt; Value</font>
        |      end.
        |  
        |  val(Var, Default) -&gt;
<font color=red>     0..|      case ?catch_val(Var) of</font>
<font color=red>     0..|     {'EXIT', _Reason} -&gt; Default;</font>
<font color=red>     0..|     Value -&gt; Value</font>
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Load a table from local disc
        |  
        |  disc_load_table(Tab, Reason) -&gt;
<font color=red>     0..|      Storage =  val({Tab, storage_type}),</font>
<font color=red>     0..|      Type = val({Tab, setorbag}),</font>
<font color=red>     0..|      dbg_out("Getting table ~p (~p) from disc: ~p~n",</font>
        |  	    [Tab, Storage, Reason]),
<font color=red>     0..|      ?eval_debug_fun({?MODULE, do_get_disc_copy},</font>
        |  		    [{tab, Tab},
        |  		     {reason, Reason},
        |  		     {storage, Storage},
        |  		     {type, Type}]),
<font color=red>     0..|      do_get_disc_copy2(Tab, Reason, Storage, Type).</font>
        |  
        |  do_get_disc_copy2(Tab, _Reason, Storage, _Type) when Storage == unknown -&gt;
<font color=red>     0..|      verbose("Local table copy of ~p has recently been deleted, ignored.~n",</font>
        |  	    [Tab]),
<font color=red>     0..|      {not_loaded, storage_unknown};</font>
        |  do_get_disc_copy2(Tab, Reason, Storage, Type) when Storage == disc_copies -&gt;
        |      %% NOW we create the actual table
<font color=red>     0..|      Repair = mnesia2_monitor:get_env(auto_repair),</font>
<font color=red>     0..|      StorageProps = val({Tab, storage_properties}),</font>
<font color=red>     0..|      EtsOpts = proplists:get_value(ets, StorageProps, []),</font>
<font color=red>     0..|      Args = [{keypos, 2}, public, named_table, Type | EtsOpts],</font>
<font color=red>     0..|      case Reason of</font>
        |  	{dumper, _} -&gt; %% Resources already allocated
<font color=red>     0..|  	    ignore;</font>
        |  	_ -&gt;
<font color=red>     0..|  	    mnesia2_monitor:mktab(Tab, Args),</font>
<font color=red>     0..|  	    _Count = mnesia2_log:dcd2ets(Tab, Repair),</font>
<font color=red>     0..|  	    case mnesia2_monitor:get_env(dump_disc_copies_at_startup)</font>
<font color=red>     0..|  		andalso mnesia2_dumper:needs_dump_ets(Tab) of</font>
        |  		true -&gt;
<font color=red>     0..|  		    ok = mnesia2_log:ets2dcd(Tab);</font>
        |  		_ -&gt;
<font color=red>     0..|  		    ignore</font>
        |  	    end
        |      end,
<font color=red>     0..|      mnesia2_index:init_index(Tab, Storage),</font>
<font color=red>     0..|      snmpify(Tab, Storage),</font>
<font color=red>     0..|      set({Tab, load_node}, node()),</font>
<font color=red>     0..|      set({Tab, load_reason}, Reason),</font>
<font color=red>     0..|      {loaded, ok};</font>
        |  
        |  do_get_disc_copy2(Tab, Reason, Storage, Type) when Storage == ram_copies -&gt;
<font color=red>     0..|      StorageProps = val({Tab, storage_properties}),</font>
<font color=red>     0..|      EtsOpts = proplists:get_value(ets, StorageProps, []),</font>
<font color=red>     0..|      Args = [{keypos, 2}, public, named_table, Type | EtsOpts],</font>
<font color=red>     0..|      case Reason of</font>
        |  	{dumper, _} -&gt; %% Resources allready allocated
<font color=red>     0..|  	    ignore;</font>
        |  	_ -&gt;
<font color=red>     0..|  	    mnesia2_monitor:mktab(Tab, Args),</font>
<font color=red>     0..|  	    Fname = mnesia2_lib:tab2dcd(Tab),</font>
<font color=red>     0..|  	    Datname = mnesia2_lib:tab2dat(Tab),</font>
<font color=red>     0..|  	    Repair = mnesia2_monitor:get_env(auto_repair),</font>
<font color=red>     0..|  	    case mnesia2_monitor:use_dir() of</font>
        |  		true -&gt;
<font color=red>     0..|  		    case mnesia2_lib:exists(Fname) of</font>
<font color=red>     0..|  			true -&gt; mnesia2_log:dcd2ets(Tab, Repair);</font>
        |  			false -&gt;
<font color=red>     0..|  			    case mnesia2_lib:exists(Datname) of</font>
        |  				true -&gt;
<font color=red>     0..|  				    mnesia2_lib:dets_to_ets(Tab, Tab, Datname,</font>
        |  							   Type, Repair, no);
        |  				false -&gt;
<font color=red>     0..|  				    false</font>
        |  			    end
        |  		    end;
        |  		false -&gt;
<font color=red>     0..|  		    false</font>
        |  	    end
        |      end,
<font color=red>     0..|      mnesia2_index:init_index(Tab, Storage),</font>
<font color=red>     0..|      snmpify(Tab, Storage),</font>
<font color=red>     0..|      set({Tab, load_node}, node()),</font>
<font color=red>     0..|      set({Tab, load_reason}, Reason),</font>
<font color=red>     0..|      {loaded, ok};</font>
        |  
        |  do_get_disc_copy2(Tab, Reason, Storage, Type) when Storage == disc_only_copies -&gt;
<font color=red>     0..|      StorageProps = val({Tab, storage_properties}),</font>
<font color=red>     0..|      DetsOpts = proplists:get_value(dets, StorageProps, []),</font>
        |  
<font color=red>     0..|      Args = [{file, mnesia2_lib:tab2dat(Tab)},</font>
        |  	    {type, mnesia2_lib:disk_type(Tab, Type)},
        |  	    {keypos, 2},
        |  	    {repair, mnesia2_monitor:get_env(auto_repair)} 
        |  	    | DetsOpts],
<font color=red>     0..|      case Reason of</font>
        |  	{dumper, _} -&gt;
<font color=red>     0..|  	    mnesia2_index:init_index(Tab, Storage),</font>
<font color=red>     0..|  	    snmpify(Tab, Storage),</font>
<font color=red>     0..|  	    set({Tab, load_node}, node()),</font>
<font color=red>     0..|  	    set({Tab, load_reason}, Reason),</font>
<font color=red>     0..|  	    {loaded, ok};</font>
        |  	_ -&gt;
<font color=red>     0..|  	    case mnesia2_monitor:open_dets(Tab, Args) of</font>
        |  		{ok, _} -&gt;
<font color=red>     0..|  		    mnesia2_index:init_index(Tab, Storage),</font>
<font color=red>     0..|  		    snmpify(Tab, Storage),</font>
<font color=red>     0..|  		    set({Tab, load_node}, node()),</font>
<font color=red>     0..|  		    set({Tab, load_reason}, Reason),</font>
<font color=red>     0..|  		    {loaded, ok};</font>
        |  		{error, Error} -&gt;
<font color=red>     0..|  		    {not_loaded, {"Failed to create dets table", Error}}</font>
        |  	    end
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Load a table from a remote node
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%
        |  %% Receiver                             Sender
        |  %% --------                             ------
        |  %% Grab schema lock on table
        |  %%                                      Determine table size
        |  %% Create empty pre-grown table
        |  %%                                      Grab read lock on table
        |  %%                                      Let receiver subscribe on updates done on sender node
        |  %%                                      Disable rehashing of table
        |  %%                                      Release read lock on table
        |  %%                                      Send table to receiver in chunks
        |  %%
        |  %%                                      Grab read lock on table
        |  %% Block dirty updates
        |  %%                                      Update wherabouts
        |  %%
        |  %%                                      Cancel the update subscription
        |  %% Process the subscription events
        |  %% Optionally dump to disc
        |  %% Unblock dirty updates
        |  %%                                      Release read lock on table
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  -define(MAX_TRANSFER_SIZE, 7500).
        |  -define(MAX_RAM_FILE_SIZE, 1000000).
        |  -define(MAX_RAM_TRANSFERS, (?MAX_RAM_FILE_SIZE div ?MAX_TRANSFER_SIZE) + 1).
        |  -define(MAX_NOPACKETS, 20).
        |  
        |  net_load_table(Tab, Reason, Ns, Cs)
        |          when Reason == {dumper,add_table_copy} -&gt;
<font color=red>     0..|      try_net_load_table(Tab, Reason, Ns, Cs);</font>
        |  net_load_table(Tab, Reason, Ns, _Cs) -&gt;
<font color=red>     0..|      try_net_load_table(Tab, Reason, Ns, val({Tab, cstruct})).</font>
        |  
        |  try_net_load_table(Tab, _Reason, [], _Cs) -&gt;
<font color=red>     0..|      verbose("Copy failed. No active replicas of ~p are available.~n", [Tab]),</font>
<font color=red>     0..|      {not_loaded, none_active};</font>
        |  try_net_load_table(Tab, Reason, Ns, Cs) -&gt;
<font color=red>     0..|      Storage = mnesia2_lib:cs_to_storage_type(node(), Cs),</font>
<font color=red>     0..|      SortedNs = sort_by_distance(Ns),</font>
<font color=red>     0..|      verbose("Loading ~p from ~1000p~n", [Tab, SortedNs]),</font>
<font color=red>     0..|      do_get_network_copy(Tab, Reason, SortedNs, Storage, Cs).</font>
        |  
        |  sort_by_distance (Ns) -&gt;
<font color=red>     0..|      TNs = lists:map(fun (N) -&gt;</font>
<font color=red>     0..|                  [_App, Hostname] = string:tokens(atom_to_list(N), "@"),</font>
<font color=red>     0..|                  {Rtt, _Result} = timer:tc(erl_epmd, names, [Hostname]),</font>
<font color=red>     0..|                  {Rtt div 10000, N}</font>
        |             end,
        |             Ns),
<font color=red>     0..|      SortedTNs = lists:sort(fun ({T1, _N1}, {T2, _N2}) -&gt; T1 &lt; T2 end, TNs),</font>
<font color=red>     0..|      [ N || {_T, N} &lt;- SortedTNs ].</font>
        |  
        |  do_get_network_copy(Tab, _Reason, _Ns, unknown, _Cs) -&gt;
<font color=red>     0..|      verbose("Local table copy of ~p has recently been deleted, ignored.~n", [Tab]),</font>
<font color=red>     0..|      {not_loaded, storage_unknown};</font>
        |  do_get_network_copy(Tab, Reason, Ns, Storage, Cs) -&gt;
<font color=red>     0..|      [Node | Tail] = Ns,</font>
<font color=red>     0..|      case lists:member(Node,val({current, db_nodes})) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    dbg_out("Getting table ~p (~p) from node ~p: ~p~n",</font>
        |  		    [Tab, Storage, Node, Reason]),
<font color=red>     0..|  	    ?eval_debug_fun({?MODULE, do_get_network_copy},</font>
        |  			    [{tab, Tab}, {reason, Reason},
        |  			     {nodes, Ns}, {storage, Storage}]),
<font color=red>     0..|  	    case init_receiver(Node, Tab, Storage, Cs, Reason) of</font>
        |  		ok -&gt;
<font color=red>     0..|  		    set({Tab, load_node}, Node),</font>
<font color=red>     0..|  		    set({Tab, load_reason}, Reason),</font>
<font color=red>     0..|  		    mnesia2_controller:i_have_tab(Tab),</font>
<font color=red>     0..|  		    dbg_out("Table ~p copied from ~p to ~p~n", [Tab, Node, node()]),</font>
<font color=red>     0..|  		    {loaded, ok};</font>
        |  		Err = {error, _} when element(1, Reason) == dumper -&gt;
<font color=red>     0..|  		    {not_loaded,Err};</font>
        |  		restart -&gt;
<font color=red>     0..|  		    try_net_load_table(Tab, Reason, Tail ++ [Node], Cs);</font>
        |  		down -&gt;
<font color=red>     0..|  		    try_net_load_table(Tab, Reason, Tail, Cs)</font>
        |  	    end;
        |  	false -&gt;
<font color=red>     0..|  	    try_net_load_table(Tab, Reason, Tail, Cs)</font>
        |      end.
        |  
        |  snmpify(Tab, Storage) -&gt;
<font color=red>     0..|      do_snmpify(Tab, val({Tab, snmp}), Storage).</font>
        |  
        |  do_snmpify(_Tab, [], _Storage) -&gt;
<font color=red>     0..|      ignore;</font>
        |  do_snmpify(Tab, Us, Storage) -&gt;
<font color=red>     0..|      Snmp = mnesia2_snmp_hook:create_table(Us, Tab, Storage),</font>
<font color=red>     0..|      set({Tab, {index, snmp}}, Snmp).</font>
        |  
        |  %% Start the recieiver
        |  init_receiver(Node, Tab, Storage, Cs, Reas={dumper,add_table_copy}) -&gt;
<font color=red>     0..|      case start_remote_sender(Node, Tab, Storage) of</font>
        |  	{SenderPid, TabSize, DetsData} -&gt;
<font color=red>     0..|  	    start_receiver(Tab,Storage,Cs,SenderPid,TabSize,DetsData,Reas);</font>
        |  	Else -&gt;
<font color=red>     0..|  	    Else</font>
        |      end;
        |  init_receiver(Node, Tab,Storage,Cs,Reason) -&gt;
        |      %% Grab a schema lock to avoid deadlock between table_loader and schema_commit dumping.
        |      %% Both may grab tables-locks in different order.
<font color=red>     0..|      Load =</font>
        |  	fun() -&gt;
<font color=red>     0..|  		{_,Tid,Ts} = get(mnesia2_activity_state),</font>
<font color=red>     0..|  		mnesia2_locker:rlock(Tid, Ts#tidstore.store, {schema, Tab}),</font>
        |  		%% Check that table still exists
<font color=red>     0..|  		Active = val({Tab, active_replicas}),</font>
        |  		%% Check that we havn't loaded it already
<font color=red>     0..|  		case val({Tab,where_to_read}) == node() of</font>
<font color=red>     0..|  		    true -&gt; ok;</font>
        |  		    _ -&gt;
        |  			%% And that sender still got a copy
        |  			%% (something might have happend while
        |  			%% we where waiting for the lock)
<font color=red>     0..|  			true = lists:member(Node, Active),</font>
<font color=red>     0..|  			{SenderPid, TabSize, DetsData} =</font>
        |  			    start_remote_sender(Node,Tab,Storage),
<font color=red>     0..|  			Init = table_init_fun(SenderPid),</font>
<font color=red>     0..|  			Args = [self(),Tab,Storage,Cs,SenderPid,</font>
        |  				TabSize,DetsData,Init],
<font color=red>     0..|  			Pid = spawn_link(?MODULE, spawned_receiver, Args),</font>
<font color=red>     0..|  			put(mnesia2_real_loader, Pid),</font>
<font color=red>     0..|  			wait_on_load_complete(Pid)</font>
        |  		end
        |  	end,
<font color=red>     0..|      Res =</font>
        |  	case mnesia2:transaction(Load, 20) of
        |  	    {atomic, {error,Result}} when
        |  		  element(1,Reason) == dumper -&gt;
<font color=red>     0..|  		{error,Result};</font>
        |  	    {atomic, {error,Result}} -&gt;
<font color=red>     0..|  		fatal("Cannot create table ~p: ~p~n",</font>
        |  		      [[Tab, Storage], Result]);
<font color=red>     0..|  	    {atomic,  Result} -&gt; Result;</font>
<font color=red>     0..|  	    {aborted, nomore} -&gt; restart;</font>
        |  	    {aborted, _Reas} -&gt;
<font color=red>     0..|  		verbose("Receiver failed on ~p from ~p:~nReason: ~p~n",</font>
        |  			[Tab,Node,_Reas]),
<font color=red>     0..|  		down  %% either this node or sender is dying</font>
        |  	end,
<font color=red>     0..|      unlink(whereis(mnesia2_tm)),  %% Avoid late unlink from tm</font>
<font color=red>     0..|      Res.</font>
        |  
        |  start_remote_sender(Node,Tab,Storage) -&gt;
<font color=red>     0..|      mnesia2_controller:start_remote_sender(Node, Tab, self(), Storage),</font>
<font color=red>     0..|      put(mnesia2_table_sender_node, {Tab, Node}),</font>
<font color=red>     0..|      receive</font>
        |  	{SenderPid, {first, TabSize}} -&gt;
<font color=red>     0..|  	    {SenderPid, TabSize, false};</font>
        |  	{SenderPid, {first, TabSize, DetsData}} -&gt;
<font color=red>     0..|  	    {SenderPid, TabSize, DetsData};</font>
        |  	%% Protocol conversion hack
        |  	{copier_done, Node} -&gt;
<font color=red>     0..|  	    verbose("Sender of table ~p crashed on node ~p ~n", [Tab, Node]),</font>
<font color=red>     0..|  	    down(Tab, Storage)</font>
        |      end.
        |  
        |  table_init_fun(SenderPid) -&gt;
<font color=red>     0..|      fun(read) -&gt;</font>
<font color=red>     0..|  	    Receiver = self(),</font>
<font color=red>     0..|  	    SenderPid ! {Receiver, more},</font>
<font color=red>     0..|  	    get_data(SenderPid, Receiver)</font>
        |      end.
        |  
        |  %% Add_table_copy get's it's own locks.
        |  start_receiver(Tab,Storage,Cs,SenderPid,TabSize,DetsData,{dumper,add_table_copy}) -&gt;
<font color=red>     0..|      Init = table_init_fun(SenderPid),</font>
<font color=red>     0..|      case do_init_table(Tab,Storage,Cs,SenderPid,TabSize,DetsData,self(), Init) of</font>
        |  	Err = {error, _} -&gt;
<font color=red>     0..|  	    SenderPid ! {copier_done, node()},</font>
<font color=red>     0..|  	    Err;</font>
        |  	Else -&gt;
<font color=red>     0..|  	    Else</font>
        |      end.
        |  
        |  spawned_receiver(ReplyTo,Tab,Storage,Cs, SenderPid,TabSize,DetsData, Init) -&gt;
<font color=red>     0..|      process_flag(trap_exit, true),</font>
<font color=red>     0..|      Done = do_init_table(Tab,Storage,Cs,</font>
        |  			 SenderPid,TabSize,DetsData,
        |  			 ReplyTo, Init),
<font color=red>     0..|      ReplyTo ! {self(),Done},</font>
<font color=red>     0..|      unlink(ReplyTo),</font>
<font color=red>     0..|      unlink(whereis(mnesia2_controller)),</font>
<font color=red>     0..|      exit(normal).</font>
        |  
        |  wait_on_load_complete(Pid) -&gt;
<font color=red>     0..|      receive</font>
        |  	{Pid, Res} -&gt;
<font color=red>     0..|  	    Res;</font>
        |  	{'EXIT', Pid, Reason} -&gt;
<font color=red>     0..|  	    error(Reason);</font>
        |  	Else -&gt;
<font color=red>     0..|  	    Pid ! Else,</font>
<font color=red>     0..|  	    wait_on_load_complete(Pid)</font>
        |      end.
        |  
        |  do_init_table(Tab,Storage,Cs,SenderPid,
        |  	      TabSize,DetsInfo,OrigTabRec,Init) -&gt;
<font color=red>     0..|      case create_table(Tab, TabSize, Storage, Cs) of</font>
        |  	{Storage,Tab} -&gt;
        |  	    %% Debug info
<font color=red>     0..|  	    Node = node(SenderPid),</font>
<font color=red>     0..|  	    put(mnesia2_table_receiver, {Tab, Node, SenderPid}),</font>
<font color=red>     0..|  	    mnesia2_tm:block_tab(Tab),</font>
<font color=red>     0..|  	    case init_table(Tab,Storage,Init,DetsInfo,SenderPid) of</font>
        |  		ok -&gt;
<font color=red>     0..|  		    tab_receiver(Node,Tab,Storage,Cs,OrigTabRec);</font>
        |  		Reason -&gt;
<font color=red>     0..|  		    Msg = "[d]ets:init table failed",</font>
<font color=red>     0..|  		    verbose("~s: ~p: ~p~n", [Msg, Tab, Reason]),</font>
<font color=red>     0..|  		    down(Tab, Storage)</font>
        |  	    end;
        |  	Error -&gt;
<font color=red>     0..|  	    Error</font>
        |      end.
        |  
        |  create_table(Tab, TabSize, Storage, Cs) -&gt;
<font color=red>     0..|      StorageProps = val({Tab, storage_properties}),</font>
<font color=red>     0..|      if</font>
        |  	Storage == disc_only_copies -&gt;
<font color=red>     0..|  	    mnesia2_lib:lock_table(Tab),</font>
<font color=red>     0..|  	    Tmp = mnesia2_lib:tab2tmp(Tab),</font>
<font color=red>     0..|  	    Size = lists:max([TabSize, 256]),</font>
<font color=red>     0..|  	    DetsOpts = lists:keydelete(estimated_no_objects, 1,</font>
        |  				       proplists:get_value(dets, StorageProps, [])),
<font color=red>     0..|  	    Args = [{file, Tmp},</font>
        |  		    {keypos, 2},
        |  %%		    {ram_file, true},
        |  		    {estimated_no_objects, Size},
        |  		    {repair, mnesia2_monitor:get_env(auto_repair)},
        |  		    {type, mnesia2_lib:disk_type(Tab, Cs#cstruct.type)}
        |  		    | DetsOpts],
<font color=red>     0..|  	    file:delete(Tmp),</font>
<font color=red>     0..|  	    case mnesia2_lib:dets_sync_open(Tab, Args) of</font>
        |  		{ok, _} -&gt;
<font color=red>     0..|  		    mnesia2_lib:unlock_table(Tab),</font>
<font color=red>     0..|  		    {Storage, Tab};</font>
        |  		Else -&gt;
<font color=red>     0..|  		    mnesia2_lib:unlock_table(Tab),</font>
<font color=red>     0..|  		    Else</font>
        |  	    end;
        |  	(Storage == ram_copies) or (Storage == disc_copies) -&gt;
<font color=red>     0..|  	    EtsOpts = proplists:get_value(ets, StorageProps, []),</font>
<font color=red>     0..|  	    Args = [{keypos, 2}, public, named_table, Cs#cstruct.type | EtsOpts],</font>
<font color=red>     0..|  	    case mnesia2_monitor:unsafe_mktab(Tab, Args) of</font>
        |  		Tab -&gt;
<font color=red>     0..|  		    {Storage, Tab};</font>
        |  		Else -&gt;
<font color=red>     0..|  		    Else</font>
        |  	    end
        |      end.
        |  
        |  tab_receiver(Node, Tab, Storage, Cs, OrigTabRec) -&gt;
<font color=red>     0..|      receive</font>
        |  	{SenderPid, {no_more, DatBin}} -&gt;
<font color=red>     0..|  	    finish_copy(Storage,Tab,Cs,SenderPid,DatBin,OrigTabRec);</font>
        |  
        |  	%% Protocol conversion hack
        |  	{copier_done, Node} -&gt;
<font color=red>     0..|  	    verbose("Sender of table ~p crashed on node ~p ~n", [Tab, Node]),</font>
<font color=red>     0..|  	    down(Tab, Storage);</font>
        |  
        |  	{'EXIT', Pid, Reason} -&gt;
<font color=red>     0..|  	    handle_exit(Pid, Reason),</font>
<font color=red>     0..|  	    tab_receiver(Node, Tab, Storage, Cs, OrigTabRec)</font>
        |      end.
        |  
        |  make_table_fun(Pid, TabRec) -&gt;
<font color=red>     0..|      fun(close) -&gt;</font>
<font color=red>     0..|  	    ok;</font>
        |         (read) -&gt;
<font color=red>     0..|  	    get_data(Pid, TabRec)</font>
        |      end.
        |  
        |  get_data(Pid, TabRec) -&gt;
<font color=red>     0..|      receive</font>
        |  	{Pid, {more_z, CompressedRecs}} when is_binary(CompressedRecs) -&gt;
<font color=red>     0..|  	    Pid ! {TabRec, more},</font>
<font color=red>     0..|  	    {zlib_uncompress(CompressedRecs), make_table_fun(Pid,TabRec)};</font>
        |  	{Pid, {more, Recs}} -&gt;
<font color=red>     0..|  	    Pid ! {TabRec, more},</font>
<font color=red>     0..|  	    {Recs, make_table_fun(Pid,TabRec)};</font>
        |  	{Pid, no_more} -&gt;
<font color=red>     0..|  	    end_of_input;</font>
        |  	{copier_done, Node} -&gt;
<font color=red>     0..|  	    case node(Pid) of</font>
        |  		Node -&gt;
<font color=red>     0..|  		    {copier_done, Node};</font>
        |  		_ -&gt;
<font color=red>     0..|  		    get_data(Pid, TabRec)</font>
        |  	    end;
        |  	{'EXIT', Pid, Reason} -&gt;
<font color=red>     0..|  	    handle_exit(Pid, Reason),</font>
<font color=red>     0..|  	    get_data(Pid, TabRec)</font>
        |      end.
        |  
        |  init_table(Tab, disc_only_copies, Fun, DetsInfo,Sender) -&gt;
<font color=red>     0..|      ErtsVer = erlang:system_info(version),</font>
<font color=red>     0..|      case DetsInfo of</font>
        |  	{ErtsVer, DetsData}  -&gt;
<font color=red>     0..|  	    try dets:is_compatible_bchunk_format(Tab, DetsData) of</font>
        |  		false -&gt;
<font color=red>     0..|  		    Sender ! {self(), {old_protocol, Tab}},</font>
<font color=red>     0..|  		    dets:init_table(Tab, Fun);  %% Old dets version</font>
        |  		true -&gt;
<font color=red>     0..|  		    dets:init_table(Tab, Fun, [{format, bchunk}])</font>
        |  	    catch
        |  		error:{undef,[{dets,_,_,_}|_]} -&gt;
<font color=red>     0..|  		    Sender ! {self(), {old_protocol, Tab}},</font>
<font color=red>     0..|  		    dets:init_table(Tab, Fun);  %% Old dets version</font>
        |  		error:What -&gt;
<font color=red>     0..|  		    What</font>
        |  	    end;
        |  	Old when Old /= false -&gt;
<font color=red>     0..|  	    Sender ! {self(), {old_protocol, Tab}},</font>
<font color=red>     0..|  	    dets:init_table(Tab, Fun);  %% Old dets version</font>
        |  	_ -&gt;
<font color=red>     0..|  	    dets:init_table(Tab, Fun)</font>
        |      end;
        |  init_table(Tab, _, Fun, _DetsInfo,_) -&gt;
<font color=red>     0..|      try</font>
<font color=red>     0..|  	true = ets:init_table(Tab, Fun),</font>
<font color=red>     0..|  	ok</font>
<font color=red>     0..|      catch _:Else -&gt; {Else, erlang:get_stacktrace()}</font>
        |      end.
        |  
        |  
        |  finish_copy(Storage,Tab,Cs,SenderPid,DatBin,OrigTabRec) -&gt;
<font color=red>     0..|      TabRef = {Storage, Tab},</font>
<font color=red>     0..|      subscr_receiver(TabRef, Cs#cstruct.record_name),</font>
<font color=red>     0..|      case handle_last(TabRef, Cs#cstruct.type, DatBin) of</font>
        |  	ok -&gt;
<font color=red>     0..|  	    mnesia2_index:init_index(Tab, Storage),</font>
<font color=red>     0..|  	    snmpify(Tab, Storage),</font>
        |  	    %% OrigTabRec must not be the spawned tab-receiver
        |  	    %% due to old protocol.
<font color=red>     0..|  	    SenderPid ! {OrigTabRec, no_more},</font>
<font color=red>     0..|  	    mnesia2_tm:unblock_tab(Tab),</font>
<font color=red>     0..|  	    ok;</font>
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    Msg = "Failed to handle last",</font>
<font color=red>     0..|  	    verbose("~s: ~p: ~p~n", [Msg, Tab, Reason]),</font>
<font color=red>     0..|  	    down(Tab, Storage)</font>
        |      end.
        |  
        |  subscr_receiver(TabRef = {_, Tab}, RecName) -&gt;
<font color=red>     0..|      receive</font>
        |  	{mnesia2_table_event, {Op, Val, _Tid}}
        |  	  when element(1, Val) =:= Tab -&gt;
<font color=red>     0..|  	    if</font>
        |  		Tab == RecName -&gt;
<font color=red>     0..|  		    handle_event(TabRef, Op, Val);</font>
        |  		true -&gt;
<font color=red>     0..|  		    handle_event(TabRef, Op, setelement(1, Val, RecName))</font>
        |  	    end,
<font color=red>     0..|  	    subscr_receiver(TabRef, RecName);</font>
        |  
        |  	{mnesia2_table_event, {Op, Val, _Tid}} when element(1, Val) =:= schema -&gt;
        |  	    %% clear_table is faked via two schema events
        |  	    %% a schema record delete and a write
<font color=red>     0..|  	    case Op of</font>
<font color=red>     0..|  		delete -&gt; handle_event(TabRef, clear_table, {Tab, all});</font>
<font color=red>     0..|  		_ -&gt; ok</font>
        |  	    end,
<font color=red>     0..|  	    subscr_receiver(TabRef, RecName);</font>
        |  
        |  	{'EXIT', Pid, Reason} -&gt;
<font color=red>     0..|  	    handle_exit(Pid, Reason),</font>
<font color=red>     0..|  	    subscr_receiver(TabRef, RecName)</font>
        |      after 0 -&gt;
<font color=red>     0..|  	    ok</font>
        |      end.
        |  
        |  handle_event(TabRef, write, Rec) -&gt;
<font color=red>     0..|      db_put(TabRef, Rec);</font>
        |  handle_event(TabRef, delete, {_Tab, Key}) -&gt;
<font color=red>     0..|      db_erase(TabRef, Key);</font>
        |  handle_event(TabRef, delete_object, OldRec) -&gt;
<font color=red>     0..|      db_match_erase(TabRef, OldRec);</font>
        |  handle_event(TabRef, clear_table, {_Tab, _Key}) -&gt;
<font color=red>     0..|      db_match_erase(TabRef, '_').</font>
        |  
        |  handle_last({disc_copies, Tab}, _Type, nobin) -&gt;
<font color=red>     0..|      Ret = mnesia2_log:ets2dcd(Tab),</font>
<font color=red>     0..|      Fname = mnesia2_lib:tab2dat(Tab),</font>
<font color=red>     0..|      case mnesia2_lib:exists(Fname) of</font>
        |  	true -&gt;  %% Remove old .DAT files.
<font color=red>     0..|  	    file:delete(Fname);</font>
        |  	false -&gt;
<font color=red>     0..|  	    ok</font>
        |      end,
<font color=red>     0..|      Ret;</font>
        |  
        |  handle_last({disc_only_copies, Tab}, Type, nobin) -&gt;
<font color=red>     0..|      mnesia2_lib:dets_sync_close(Tab),</font>
<font color=red>     0..|      Tmp = mnesia2_lib:tab2tmp(Tab),</font>
<font color=red>     0..|      Dat = mnesia2_lib:tab2dat(Tab),</font>
<font color=red>     0..|      case file:rename(Tmp, Dat) of</font>
        |  	ok -&gt;
<font color=red>     0..|  	    StorageProps = val({Tab, storage_properties}),</font>
<font color=red>     0..|  	    DetsOpts = proplists:get_value(dets, StorageProps, []),</font>
        |  
<font color=red>     0..|  	    Args = [{file, mnesia2_lib:tab2dat(Tab)},</font>
        |  		    {type, mnesia2_lib:disk_type(Tab, Type)},
        |  		    {keypos, 2},
        |  		    {repair, mnesia2_monitor:get_env(auto_repair)} | DetsOpts],
<font color=red>     0..|  	    mnesia2_monitor:open_dets(Tab, Args),</font>
<font color=red>     0..|  	    ok;</font>
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    {error, {"Cannot swap tmp files", Tab, Reason}}</font>
        |      end;
        |  
        |  handle_last({ram_copies, _Tab}, _Type, nobin) -&gt;
<font color=red>     0..|      ok;</font>
        |  handle_last({ram_copies, Tab}, _Type, DatBin) -&gt;
<font color=red>     0..|      case mnesia2_monitor:use_dir() of</font>
        |  	true -&gt;
<font color=red>     0..|  	    mnesia2_lib:lock_table(Tab),</font>
<font color=red>     0..|  	    Tmp = mnesia2_lib:tab2tmp(Tab),</font>
<font color=red>     0..|  	    ok = file:write_file(Tmp, DatBin),</font>
<font color=red>     0..|  	    ok = file:rename(Tmp, mnesia2_lib:tab2dcd(Tab)),</font>
<font color=red>     0..|  	    mnesia2_lib:unlock_table(Tab),</font>
<font color=red>     0..|  	    ok;</font>
        |  	false -&gt;
<font color=red>     0..|  	    ok</font>
        |      end.
        |  
        |  down(Tab, Storage) -&gt;
<font color=red>     0..|      case Storage of</font>
        |  	ram_copies -&gt;
<font color=red>     0..|  	    ?SAFE(?ets_delete_table(Tab));</font>
        |  	disc_copies -&gt;
<font color=red>     0..|  	    ?SAFE(?ets_delete_table(Tab));</font>
        |  	disc_only_copies -&gt;
<font color=red>     0..|  	    TmpFile = mnesia2_lib:tab2tmp(Tab),</font>
<font color=red>     0..|  	    mnesia2_lib:dets_sync_close(Tab),</font>
<font color=red>     0..|  	    file:delete(TmpFile)</font>
        |      end,
<font color=red>     0..|      mnesia2_checkpoint:tm_del_copy(Tab, node()),</font>
<font color=red>     0..|      mnesia2_controller:sync_del_table_copy_whereabouts(Tab, node()),</font>
<font color=red>     0..|      mnesia2_tm:unblock_tab(Tab),</font>
<font color=red>     0..|      flush_subcrs(),</font>
<font color=red>     0..|      down.</font>
        |  
        |  flush_subcrs() -&gt;
<font color=red>     0..|      receive</font>
        |  	{mnesia2_table_event, _} -&gt;
<font color=red>     0..|  	    flush_subcrs();</font>
        |  
        |  	{'EXIT', Pid, Reason} -&gt;
<font color=red>     0..|  	    handle_exit(Pid, Reason),</font>
<font color=red>     0..|  	    flush_subcrs()</font>
        |      after 0 -&gt;
<font color=red>     0..|  	    done</font>
        |      end.
        |  
        |  db_erase({ram_copies, Tab}, Key) -&gt;
<font color=red>     0..|      true = ?ets_delete(Tab, Key);</font>
        |  db_erase({disc_copies, Tab}, Key) -&gt;
<font color=red>     0..|      true = ?ets_delete(Tab, Key);</font>
        |  db_erase({disc_only_copies, Tab}, Key) -&gt;
<font color=red>     0..|      ok = dets:delete(Tab, Key).</font>
        |  
        |  db_match_erase({ram_copies, Tab} , Pat) -&gt;
<font color=red>     0..|      true = ?ets_match_delete(Tab, Pat);</font>
        |  db_match_erase({disc_copies, Tab} , Pat) -&gt;
<font color=red>     0..|      true = ?ets_match_delete(Tab, Pat);</font>
        |  db_match_erase({disc_only_copies, Tab}, Pat) -&gt;
<font color=red>     0..|      ok = dets:match_delete(Tab, Pat).</font>
        |  
        |  db_put({ram_copies, Tab}, Val) -&gt;
<font color=red>     0..|      true = ?ets_insert(Tab, Val);</font>
        |  db_put({disc_copies, Tab}, Val) -&gt;
<font color=red>     0..|      true = ?ets_insert(Tab, Val);</font>
        |  db_put({disc_only_copies, Tab}, Val) -&gt;
<font color=red>     0..|      ok = dets:insert(Tab, Val).</font>
        |  
        |  %% This code executes at the remote site where the data is
        |  %% executes in a special copier process.
        |  
        |  calc_nokeys(Storage, Tab) -&gt;
        |      %% Calculate #keys per transfer
<font color=red>     0..|      Key = mnesia2_lib:db_first(Storage, Tab),</font>
<font color=red>     0..|      Recs = mnesia2_lib:db_get(Storage, Tab, Key),</font>
<font color=red>     0..|      BinSize = size(term_to_binary(Recs)),</font>
<font color=red>     0..|      (val(send_max_transfer_size, ?MAX_TRANSFER_SIZE) div BinSize) + 1.</font>
        |  
        |  send_table(Pid, Tab, RemoteS) -&gt;
<font color=red>     0..|      case ?catch_val({Tab, storage_type}) of</font>
        |  	{'EXIT', _} -&gt;
<font color=red>     0..|  	    {error, {no_exists, Tab}};</font>
        |  	unknown -&gt;
<font color=red>     0..|  	    {error, {no_exists, Tab}};</font>
        |  	Storage -&gt;
        |  	    %% Send first
<font color=red>     0..|  	    TabSize = mnesia2:table_info(Tab, size),</font>
<font color=red>     0..|  	    KeysPerTransfer = calc_nokeys(Storage, Tab),</font>
<font color=red>     0..|  	    ChunkData = dets:info(Tab, bchunk_format),</font>
        |  
<font color=red>     0..|  	    UseDetsChunk =</font>
<font color=red>     0..|  		Storage == RemoteS andalso</font>
<font color=red>     0..|  		Storage == disc_only_copies andalso</font>
<font color=red>     0..|  		ChunkData /= undefined,</font>
<font color=red>     0..|  	    if</font>
        |  		UseDetsChunk == true -&gt;
<font color=red>     0..|  		    DetsInfo = erlang:system_info(version),</font>
<font color=red>     0..|  		    Pid ! {self(), {first, TabSize, {DetsInfo, ChunkData}}};</font>
        |  		true  -&gt;
<font color=red>     0..|  		    Pid ! {self(), {first, TabSize}}</font>
        |  	    end,
        |  
        |  	    %% Debug info
<font color=red>     0..|  	    put(mnesia2_table_sender, {Tab, node(Pid), Pid}),</font>
<font color=red>     0..|  	    {Init, Chunk} = reader_funcs(UseDetsChunk, Tab, Storage, KeysPerTransfer),</font>
        |  
<font color=red>     0..|  	    SendIt = fun() -&gt;</font>
<font color=red>     0..|  			     {atomic, ok} = prepare_copy(Pid, Tab, Storage),</font>
<font color=red>     0..|  			     send_more(Pid, 1, Chunk, Init(), Tab),</font>
<font color=red>     0..|  			     finish_copy(Pid, Tab, Storage, RemoteS)</font>
        |  		     end,
        |  
<font color=red>     0..|  	    try SendIt() of</font>
<font color=red>     0..|  		{_, receiver_died} -&gt; ok;</font>
<font color=red>     0..|  		{atomic, no_more} -&gt;  ok</font>
        |  	    catch
        |  		throw:receiver_died -&gt;
<font color=red>     0..|  		    cleanup_tab_copier(Pid, Storage, Tab),</font>
<font color=red>     0..|  		    ok;</font>
        |  		error:Reason -&gt; %% Prepare failed
<font color=red>     0..|  		    cleanup_tab_copier(Pid, Storage, Tab),</font>
<font color=red>     0..|  		    {error, {tab_copier, Tab, {Reason, erlang:get_stacktrace()}}}</font>
        |  	    after
<font color=red>     0..|  		unlink(whereis(mnesia2_tm))</font>
        |  	    end
        |      end.
        |  
        |  prepare_copy(Pid, Tab, Storage) -&gt;
<font color=red>     0..|      Trans =</font>
        |  	fun() -&gt;
<font color=red>     0..|  		mnesia2:lock_table(Tab, load),</font>
<font color=red>     0..|  		mnesia2_subscr:subscribe(Pid, {table, Tab}),</font>
<font color=red>     0..|  		update_where_to_write(Tab, node(Pid)),</font>
<font color=red>     0..|  		mnesia2_lib:db_fixtable(Storage, Tab, true),</font>
<font color=red>     0..|  		ok</font>
        |  	end,
<font color=red>     0..|      mnesia2:transaction(Trans).</font>
        |  
        |  update_where_to_write(Tab, Node) -&gt;
<font color=red>     0..|      case val({Tab, access_mode}) of</font>
        |  	read_only -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	read_write -&gt;
<font color=red>     0..|  	    Current = val({current, db_nodes}),</font>
<font color=red>     0..|  	    Ns =</font>
        |  		case lists:member(Node, Current) of
<font color=red>     0..|  		    true -&gt; Current;</font>
<font color=red>     0..|  		    false -&gt; [Node | Current]</font>
        |  		end,
<font color=red>     0..|  	    update_where_to_write(Ns, Tab, Node)</font>
        |      end.
        |  
        |  update_where_to_write([], _, _) -&gt;
<font color=red>     0..|      ok;</font>
        |  update_where_to_write([H|T], Tab, AddNode) -&gt;
<font color=red>     0..|      rpc:call(H,  mnesia2_controller, call,</font>
        |  	     [{update_where_to_write, [add, Tab, AddNode], self()}]),
<font color=red>     0..|      update_where_to_write(T, Tab, AddNode).</font>
        |  
        |  send_more(Pid, N, Chunk, DataState, Tab) -&gt;
<font color=red>     0..|      receive</font>
        |  	{NewPid, more} -&gt;
<font color=red>     0..|         MaxPackets = val(send_max_packets, ?MAX_NOPACKETS),</font>
<font color=red>     0..|         case send_packet(N - 1, MaxPackets, NewPid, Chunk, DataState) of</font>
        |  		New when is_integer(New) -&gt;
<font color=red>     0..|  		    New - 1;</font>
        |  		NewData -&gt;
<font color=red>     0..|             send_more(NewPid, MaxPackets, Chunk, NewData, Tab)</font>
        |  	    end;
        |  	{_NewPid, {old_protocol, Tab}} -&gt;
<font color=red>     0..|  	    Storage =  val({Tab, storage_type}),</font>
<font color=red>     0..|  	    {Init, NewChunk} =</font>
        |  		reader_funcs(false, Tab, Storage, calc_nokeys(Storage, Tab)),
<font color=red>     0..|  	    send_more(Pid, 1, NewChunk, Init(), Tab);</font>
        |  
        |  	{copier_done, Node} when Node == node(Pid)-&gt;
<font color=red>     0..|  	    verbose("Receiver of table ~p crashed on ~p (more)~n", [Tab, Node]),</font>
<font color=red>     0..|  	    throw(receiver_died)</font>
        |      end.
        |  
        |  reader_funcs(UseDetsChunk, Tab, Storage, KeysPerTransfer) -&gt;
<font color=red>     0..|      case UseDetsChunk of</font>
        |  	false -&gt;
<font color=red>     0..|  	    {fun() -&gt; mnesia2_lib:db_init_chunk(Storage, Tab, KeysPerTransfer) end,</font>
<font color=red>     0..|  	     fun(Cont) -&gt; mnesia2_lib:db_chunk(Storage, Cont) end};</font>
        |  	true -&gt;
<font color=red>     0..|  	    {fun() -&gt; dets_bchunk(Tab, start) end,</font>
<font color=red>     0..|  	     fun(Cont) -&gt; dets_bchunk(Tab, Cont) end}</font>
        |      end.
        |  
        |  dets_bchunk(Tab, Chunk) -&gt; %% Arrg
<font color=red>     0..|      case dets:bchunk(Tab, Chunk) of</font>
<font color=red>     0..|  	{Cont, Data} -&gt; {Data, Cont};</font>
<font color=red>     0..|  	Else -&gt; Else</font>
        |      end.
        |  
        |  zlib_compress(Data, Level) -&gt;
<font color=red>     0..|      BinData = term_to_binary(Data),</font>
<font color=red>     0..|      Z = zlib:open(),</font>
<font color=red>     0..|      zlib:deflateInit(Z, Level),</font>
<font color=red>     0..|      Bs = zlib:deflate(Z, BinData, finish),</font>
<font color=red>     0..|      zlib:deflateEnd(Z),</font>
<font color=red>     0..|      zlib:close(Z),</font>
<font color=red>     0..|      list_to_binary(Bs).</font>
        |  
        |  zlib_uncompress(Data) when is_binary(Data) -&gt;
<font color=red>     0..|      binary_to_term(zlib:uncompress(Data)).</font>
        |  
        |  compression_level() -&gt;
<font color=red>     0..|      NoCompression = 0,</font>
<font color=red>     0..|      case ?catch_val(send_compressed) of</font>
        |  	{'EXIT', _} -&gt;
<font color=red>     0..|  	    mnesia2_lib:set(send_compressed, NoCompression),</font>
<font color=red>     0..|  	    NoCompression;</font>
<font color=red>     0..|  	Val -&gt; Val</font>
        |      end.
        |  
        |  send_packet(N, _Max, Pid, _Chunk, '$end_of_table') -&gt;
<font color=red>     0..|      Pid ! {self(), no_more},</font>
<font color=red>     0..|      N;</font>
        |  send_packet(N, Max, Pid, Chunk, {[], Cont}) -&gt;
<font color=red>     0..|      send_packet(N, Max, Pid, Chunk, Chunk(Cont));</font>
        |  send_packet(N, Max, Pid, Chunk, {Recs, Cont}) when N &lt; Max -&gt;
<font color=red>     0..|      case compression_level() of</font>
        |  	0 -&gt;
<font color=red>     0..|  	    Pid ! {self(), {more, Recs}};</font>
        |  	Level -&gt;
<font color=red>     0..|  	    Pid ! {self(), {more_z, zlib_compress(Recs, Level)}}</font>
        |      end,
<font color=red>     0..|      send_packet(N+1, Max, Pid, Chunk, Chunk(Cont));</font>
        |  send_packet(_N, _Max, _Pid, _Chunk, DataState) -&gt;
<font color=red>     0..|      DataState.</font>
        |  
        |  finish_copy(Pid, Tab, Storage, RemoteS) -&gt;
<font color=red>     0..|      RecNode = node(Pid),</font>
<font color=red>     0..|      DatBin = dat2bin(Tab, Storage, RemoteS),</font>
<font color=red>     0..|      Trans =</font>
        |  	fun() -&gt;
<font color=red>     0..|  		mnesia2:read_lock_table(Tab),</font>
<font color=red>     0..|  		A = val({Tab, access_mode}),</font>
<font color=red>     0..|  		mnesia2_controller:sync_and_block_table_whereabouts(Tab, RecNode, RemoteS, A),</font>
<font color=red>     0..|  		cleanup_tab_copier(Pid, Storage, Tab),</font>
<font color=red>     0..|  		mnesia2_checkpoint:tm_add_copy(Tab, RecNode),</font>
<font color=red>     0..|  		Pid ! {self(), {no_more, DatBin}},</font>
<font color=red>     0..|  		receive</font>
        |  		    {Pid, no_more} -&gt; % Dont bother about the spurious 'more' message
<font color=red>     0..|  			no_more;</font>
        |  		    {copier_done, Node} when Node == node(Pid)-&gt;
<font color=red>     0..|  			verbose("Tab receiver ~p crashed (more): ~p~n", [Tab, Node]),</font>
<font color=red>     0..|  			receiver_died</font>
        |  		end
        |  	end,
<font color=red>     0..|      mnesia2:transaction(Trans).</font>
        |  
        |  cleanup_tab_copier(Pid, Storage, Tab) -&gt;
<font color=red>     0..|      mnesia2_lib:db_fixtable(Storage, Tab, false),</font>
<font color=red>     0..|      mnesia2_subscr:unsubscribe(Pid, {table, Tab}).</font>
        |  
        |  dat2bin(Tab, ram_copies, ram_copies) -&gt;
<font color=red>     0..|      mnesia2_lib:lock_table(Tab),</font>
<font color=red>     0..|      Res = file:read_file(mnesia2_lib:tab2dcd(Tab)),</font>
<font color=red>     0..|      mnesia2_lib:unlock_table(Tab),</font>
<font color=red>     0..|      case Res of</font>
<font color=red>     0..|  	{ok, DatBin} -&gt; DatBin;</font>
<font color=red>     0..|  	_ -&gt; nobin</font>
        |      end;
        |  dat2bin(_Tab, _LocalS, _RemoteS) -&gt;
<font color=red>     0..|      nobin.</font>
        |  
        |  handle_exit(Pid, Reason) when node(Pid) == node() -&gt;
<font color=red>     0..|      error(Reason);</font>
        |  handle_exit(_Pid, _Reason) -&gt;  %% Not from our node, this will be handled by
<font color=red>     0..|      ignore.                  %% mnesia2_down soon.</font>
</pre>
</body>
</html>
