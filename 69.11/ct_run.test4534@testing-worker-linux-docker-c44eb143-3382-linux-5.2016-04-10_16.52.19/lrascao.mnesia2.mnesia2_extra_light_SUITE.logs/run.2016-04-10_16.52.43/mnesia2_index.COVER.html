<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>/home/travis/build/lrascao/mnesia2/logs/ct_run.test4534@testing-worker-linux-docker-c44eb143-3382-linux-5.2016-04-10_16.52.19/lrascao.mnesia2.mnesia2_extra_light_SUITE.logs/run.2016-04-10_16.52.43/mnesia2_index.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/lrascao/mnesia2/ebin/mnesia2_index.erl by COVER 2016-04-10 at 16:53:41

****************************************************************************

        |  %%
        |  %% %CopyrightBegin%
        |  %% 
        |  %% Copyright Ericsson AB 1996-2014. All Rights Reserved.
        |  %% 
        |  %% Licensed under the Apache License, Version 2.0 (the "License");
        |  %% you may not use this file except in compliance with the License.
        |  %% You may obtain a copy of the License at
        |  %%
        |  %%     http://www.apache.org/licenses/LICENSE-2.0
        |  %%
        |  %% Unless required by applicable law or agreed to in writing, software
        |  %% distributed under the License is distributed on an "AS IS" BASIS,
        |  %% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        |  %% See the License for the specific language governing permissions and
        |  %% limitations under the License.
        |  %% 
        |  %% %CopyrightEnd%
        |  %%
        |  
        |  %%
        |  %% Purpose: Handles index functionality in mnesia2
        |  
        |  -module(mnesia2_index).
        |  -export([read/5,
        |  	 add_index/5,
        |  	 delete_index/3,
        |  	 del_object_index/5,
        |  	 clear_index/4,
        |  	 dirty_match_object/3,
        |  	 dirty_select/3,
        |  	 dirty_read/3,
        |  	 dirty_read2/3,
        |  
        |  	 db_put/2,
        |  	 db_get/2,
        |  	 db_match_erase/2,
        |  	 get_index_table/2,
        |  	 get_index_table/3,
        |  	 
        |  	 tab2filename/2,
        |  	 tab2tmp_filename/2,
        |  	 init_index/2,
        |  	 init_indecies/3,
        |  	 del_transient/2,
        |  	 del_transient/3,
        |  	 del_index_table/3]).
        |  
        |  -import(mnesia2_lib, [val/1, verbose/2]).
        |  -include("mnesia2.hrl").
        |  
        |  -record(index, {setorbag, pos_list}).
        |  
        |  %% read an object list throuh its index table
        |  %% we assume that table Tab has index on attribute number Pos
        |  
        |  read(Tid, Store, Tab, IxKey, Pos) -&gt;
<font color=red>     0..|      ResList = mnesia2_locker:ixrlock(Tid, Store, Tab, IxKey, Pos),</font>
        |      %% Remove all tuples which don't include Ixkey, happens when Tab is a bag
<font color=red>     0..|      case val({Tab, setorbag}) of</font>
        |  	bag -&gt; 
<font color=red>     0..|  	    mnesia2_lib:key_search_all(IxKey, Pos, ResList);</font>
        |  	_ -&gt; 
<font color=red>     0..|  	    ResList</font>
        |      end.
        |  
        |  add_index(Index, Tab, Key, Obj, Old) -&gt;    
<font color=red>     0..|      add_index2(Index#index.pos_list, Index#index.setorbag, Tab, Key, Obj, Old).</font>
        |  
        |  add_index2([{Pos, Ixt} |Tail], bag, Tab, K, Obj, OldRecs) -&gt;
<font color=red>     0..|      db_put(Ixt, {element(Pos, Obj), K}),</font>
<font color=red>     0..|      add_index2(Tail, bag, Tab, K, Obj, OldRecs);</font>
        |  add_index2([{Pos, Ixt} |Tail], Type, Tab, K, Obj, OldRecs0) -&gt;
        |      %% Remove old tuples in index if Tab is updated
<font color=red>     0..|      OldRecs1 = case OldRecs0 of</font>
<font color=red>     0..|  		   undefined -&gt; mnesia2_lib:db_get(Tab, K);</font>
<font color=red>     0..|  		   _ -&gt; OldRecs0</font>
        |  	       end,
<font color=red>     0..|      IdxVal = element(Pos, Obj),</font>
<font color=red>     0..|      case [Old || Old &lt;- OldRecs1, element(Pos, Old) =/= IdxVal] of</font>
        |  	[] when OldRecs1 =:= [] -&gt;  %% Write
<font color=red>     0..|  	    db_put(Ixt, {element(Pos, Obj), K}),</font>
<font color=red>     0..|  	    add_index2(Tail, Type, Tab, K, Obj, OldRecs0);</font>
        |  	[] -&gt; %% when OldRecs1 =/= [] Update without modifying index field
<font color=red>     0..|  	    add_index2(Tail, Type, Tab, K, Obj, OldRecs0);</font>
        |  	OldRecs -&gt; %% Update
<font color=red>     0..|  	    db_put(Ixt, {element(Pos, Obj), K}),</font>
<font color=red>     0..|  	    del_ixes(Ixt, OldRecs, Pos, K),</font>
<font color=red>     0..|  	    add_index2(Tail, Type, Tab, K, Obj, OldRecs0)</font>
        |      end;
<font color=red>     0..|  add_index2([], _, _Tab, _K, _Obj, _) -&gt; ok.</font>
        |  
        |  delete_index(Index, Tab, K) -&gt;
<font color=red>     0..|      delete_index2(Index#index.pos_list, Tab, K).</font>
        |  
        |  delete_index2([{Pos, Ixt} | Tail], Tab, K) -&gt;
<font color=red>     0..|      DelObjs = mnesia2_lib:db_get(Tab, K), </font>
<font color=red>     0..|      del_ixes(Ixt, DelObjs, Pos, K),</font>
<font color=red>     0..|      delete_index2(Tail, Tab, K);</font>
<font color=red>     0..|  delete_index2([], _Tab, _K) -&gt; ok.</font>
        |  
        |  
<font color=red>     0..|  del_ixes(_Ixt, [], _Pos, _L) -&gt; ok;</font>
        |  del_ixes(Ixt, [Obj | Tail], Pos, Key) -&gt;
<font color=red>     0..|      db_match_erase(Ixt, {element(Pos, Obj), Key}),</font>
<font color=red>     0..|      del_ixes(Ixt, Tail, Pos, Key).</font>
        |  
        |  del_object_index(Index, Tab, K, Obj, Old) -&gt;
<font color=red>     0..|      del_object_index2(Index#index.pos_list, Index#index.setorbag, Tab, K, Obj, Old).</font>
        |  
<font color=red>     0..|  del_object_index2([], _, _Tab, _K, _Obj, _Old) -&gt; ok;</font>
        |  del_object_index2([{Pos, Ixt} | Tail], SoB, Tab, K, Obj, Old) -&gt;
<font color=red>     0..|      case SoB of</font>
        |  	bag -&gt; 
<font color=red>     0..|  	    del_object_bag(Tab, K, Obj, Pos, Ixt, Old);</font>
        |  	_ -&gt; %% If set remove the tuple in index table
<font color=red>     0..|  	    del_ixes(Ixt, [Obj], Pos, K)	</font>
        |      end,
<font color=red>     0..|      del_object_index2(Tail, SoB, Tab, K, Obj, Old).</font>
        |  
        |  del_object_bag(Tab, Key, Obj, Pos, Ixt, undefined) -&gt; 
<font color=red>     0..|      IxKey = element(Pos, Obj),</font>
<font color=red>     0..|      Old = [X || X &lt;-  mnesia2_lib:db_get(Tab, Key), element(Pos, X) =:= IxKey],</font>
<font color=red>     0..|      del_object_bag(Tab, Key, Obj, Pos, Ixt, Old);</font>
        |  %% If Tab type is bag we need remove index identifier if the object being
        |  %% deleted was the last one
        |  del_object_bag(_Tab, Key, Obj, Pos, Ixt, Old) when Old =:= [Obj] -&gt;
<font color=red>     0..|      del_ixes(Ixt, [Obj], Pos, Key);</font>
<font color=red>     0..|  del_object_bag(_Tab, _Key, _Obj, _Pos, _Ixt, _Old) -&gt; ok.</font>
        |  
        |  clear_index(Index, Tab, K, Obj) -&gt;
<font color=red>     0..|      clear_index2(Index#index.pos_list, Tab, K, Obj).</font>
        |  
<font color=red>     0..|  clear_index2([], _Tab, _K, _Obj) -&gt; ok;</font>
        |  clear_index2([{_Pos, Ixt} | Tail], Tab, K, Obj) -&gt;
<font color=red>     0..|      db_match_erase(Ixt, Obj),</font>
<font color=red>     0..|      clear_index2(Tail, Tab, K, Obj).</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  dirty_match_object(Tab, Pat, Pos) -&gt;
        |      %% Assume that we are on the node where the replica is
<font color=red>     0..|      case element(2, Pat) of</font>
        |  	'_' -&gt;
<font color=red>     0..|  	    IxKey = element(Pos, Pat),</font>
<font color=red>     0..|  	    RealKeys = realkeys(Tab, Pos, IxKey),</font>
<font color=red>     0..|  	    merge(RealKeys, Tab, Pat, []);</font>
        |  	_Else -&gt;
<font color=red>     0..|  	    mnesia2_lib:db_match_object(Tab, Pat)</font>
        |      end.
        |  
        |  merge([{_IxKey, RealKey} | Tail], Tab, Pat, Ack) -&gt;
        |      %% Assume that we are on the node where the replica is
<font color=red>     0..|      Pat2 = setelement(2, Pat, RealKey),</font>
<font color=red>     0..|      Recs = mnesia2_lib:db_match_object(Tab, Pat2),</font>
<font color=red>     0..|      merge(Tail, Tab, Pat, Recs ++ Ack);</font>
        |  merge([], _, _, Ack) -&gt;
<font color=red>     0..|      Ack.</font>
        |  
        |  realkeys(Tab, Pos, IxKey) -&gt;
<font color=red>     0..|      Index = get_index_table(Tab, Pos),</font>
<font color=red>     0..|      db_get(Index, IxKey). % a list on the form [{IxKey, RealKey1} , ....</font>
        |      
        |  dirty_select(Tab, Spec, Pos) -&gt;
        |      %% Assume that we are on the node where the replica is
        |      %% Returns the records without applying the match spec
        |      %% The actual filtering is handled by the caller
<font color=red>     0..|      IxKey = element(Pos, Spec),</font>
<font color=red>     0..|      RealKeys = realkeys(Tab, Pos, IxKey),</font>
<font color=red>     0..|      StorageType = val({Tab, storage_type}),</font>
<font color=red>     0..|      lists:append([mnesia2_lib:db_get(StorageType, Tab, Key) || {_,Key} &lt;- RealKeys]).</font>
        |  
        |  dirty_read(Tab, IxKey, Pos) -&gt;
<font color=red>     0..|      ResList = mnesia2:dirty_rpc(Tab, ?MODULE, dirty_read2,</font>
        |  			       [Tab, IxKey, Pos]),
<font color=red>     0..|      case val({Tab, setorbag}) of</font>
        |  	bag -&gt;
        |  	    %% Remove all tuples which don't include Ixkey
<font color=red>     0..|  	    mnesia2_lib:key_search_all(IxKey, Pos, ResList);</font>
        |  	_ -&gt; 
<font color=red>     0..|  	    ResList</font>
        |      end.
        |  
        |  dirty_read2(Tab, IxKey, Pos) -&gt;
<font color=red>     0..|      Ix = get_index_table(Tab, Pos),</font>
<font color=red>     0..|      Keys = db_match(Ix, {IxKey, '$1'}),</font>
<font color=red>     0..|      r_keys(Keys, Tab, []).</font>
        |  
        |  r_keys([[H]|T],Tab,Ack) -&gt; 
<font color=red>     0..|      V = mnesia2_lib:db_get(Tab, H),</font>
<font color=red>     0..|      r_keys(T, Tab, V ++ Ack);</font>
        |  r_keys([], _, Ack) -&gt;
<font color=red>     0..|      Ack.</font>
        |  	    
        |  
        |  %%%%%%% Creation, Init and deletion routines for index tables
        |  %% We can have several indexes on the same table
        |  %% this can be a fairly costly operation if table is *very* large
        |  
        |  tab2filename(Tab, Pos) -&gt;
<font color=red>     0..|      mnesia2_lib:dir(Tab) ++ "_" ++ integer_to_list(Pos) ++ ".DAT".</font>
        |  
        |  tab2tmp_filename(Tab, Pos) -&gt;
<font color=red>     0..|      mnesia2_lib:dir(Tab) ++ "_" ++ integer_to_list(Pos) ++ ".TMP".</font>
        |          
        |  init_index(Tab, Storage) -&gt;
<font color=red>     0..|      PosList = val({Tab, index}),</font>
<font color=red>     0..|      init_indecies(Tab, Storage, PosList).</font>
        |  
        |  init_indecies(Tab, Storage, PosList) -&gt;
<font color=red>     0..|      case Storage of</font>
        |  	unknown -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	disc_only_copies -&gt;
<font color=red>     0..|  	    init_disc_index(Tab, PosList);</font>
        |  	ram_copies -&gt;
<font color=red>     0..|  	    make_ram_index(Tab, PosList);</font>
        |  	disc_copies -&gt;
<font color=red>     0..|  	    make_ram_index(Tab, PosList)</font>
        |      end.
        |  
        |  %% works for both ram and disc indexes
        |  
        |  del_index_table(_, unknown, _) -&gt;
<font color=red>     0..|      ignore;</font>
        |  del_index_table(Tab, Storage, Pos) -&gt;
<font color=red>     0..|      delete_transient_index(Tab, Pos, Storage),</font>
<font color=red>     0..|      mnesia2_lib:del({Tab, index}, Pos).</font>
        |  
        |  del_transient(Tab, Storage) -&gt;
<font color=red>     0..|      PosList = val({Tab, index}),</font>
<font color=red>     0..|      del_transient(Tab, PosList, Storage).</font>
        |  
<font color=red>     0..|  del_transient(_, [], _) -&gt; ok;</font>
        |  del_transient(Tab, [Pos | Tail], Storage) -&gt;
<font color=red>     0..|      delete_transient_index(Tab, Pos, Storage),</font>
<font color=red>     0..|      del_transient(Tab, Tail, Storage).</font>
        |  
        |  delete_transient_index(Tab, Pos, disc_only_copies) -&gt;
<font color=red>     0..|      Tag = {Tab, index, Pos},</font>
<font color=red>     0..|      mnesia2_monitor:unsafe_close_dets(Tag),</font>
<font color=red>     0..|      _ = file:delete(tab2filename(Tab, Pos)),</font>
<font color=red>     0..|      del_index_info(Tab, Pos), %% Uses val(..)</font>
<font color=red>     0..|      mnesia2_lib:unset({Tab, {index, Pos}});</font>
        |  
        |  delete_transient_index(Tab, Pos, _Storage) -&gt;
<font color=red>     0..|      Ixt = val({Tab, {index, Pos}}),</font>
<font color=red>     0..|      ?ets_delete_table(Ixt),</font>
<font color=red>     0..|      del_index_info(Tab, Pos),</font>
<font color=red>     0..|      mnesia2_lib:unset({Tab, {index, Pos}}).</font>
        |  
        |  %%%%% misc functions for the index create/init/delete functions above
        |  
        |  %% assuming that the file exists.
        |  init_disc_index(_Tab, []) -&gt;
<font color=red>     0..|      done;</font>
        |  init_disc_index(Tab, [Pos | Tail]) when is_integer(Pos) -&gt;
<font color=red>     0..|      Fn = tab2filename(Tab, Pos),</font>
<font color=red>     0..|      IxTag = {Tab, index, Pos},</font>
<font color=red>     0..|      _ = file:delete(Fn),</font>
<font color=red>     0..|      Args = [{file, Fn}, {keypos, 1}, {type, bag}],</font>
<font color=red>     0..|      mnesia2_monitor:open_dets(IxTag, Args),</font>
<font color=red>     0..|      Storage = disc_only_copies,</font>
<font color=red>     0..|      Key = mnesia2_lib:db_first(Storage, Tab),</font>
<font color=red>     0..|      Recs = mnesia2_lib:db_get(Storage, Tab, Key),</font>
<font color=red>     0..|      BinSize = size(term_to_binary(Recs)),</font>
<font color=red>     0..|      KeysPerChunk = (4000 div BinSize) + 1,</font>
<font color=red>     0..|      Init = {start, KeysPerChunk},</font>
<font color=red>     0..|      mnesia2_lib:db_fixtable(Storage, Tab, true),</font>
<font color=red>     0..|      ok = dets:init_table(IxTag, create_fun(Init, Tab, Pos)),</font>
<font color=red>     0..|      mnesia2_lib:db_fixtable(Storage, Tab, false),</font>
<font color=red>     0..|      mnesia2_lib:set({Tab, {index, Pos}}, IxTag),</font>
<font color=red>     0..|      add_index_info(Tab, val({Tab, setorbag}), {Pos, {dets, IxTag}}),</font>
<font color=red>     0..|      init_disc_index(Tab, Tail).</font>
        |  
        |  create_fun(Cont, Tab, Pos) -&gt;
<font color=red>     0..|      fun(read) -&gt;</font>
<font color=red>     0..|  	    Data = </font>
        |  		case Cont of
        |  		    {start, KeysPerChunk} -&gt;
<font color=red>     0..|  			mnesia2_lib:db_init_chunk(disc_only_copies, Tab, KeysPerChunk);</font>
        |  		    '$end_of_table' -&gt; 
<font color=red>     0..|  			'$end_of_table';</font>
        |  		    _Else -&gt;
<font color=red>     0..|  			mnesia2_lib:db_chunk(disc_only_copies, Cont)</font>
        |  		end,
<font color=red>     0..|  	    case Data of</font>
        |  		'$end_of_table' -&gt;
<font color=red>     0..|  		    end_of_input;</font>
        |  		{Recs, Next} -&gt;
<font color=red>     0..|  		    IdxElems = [{element(Pos, Obj), element(2, Obj)} || Obj &lt;- Recs],</font>
<font color=red>     0..|  		    {IdxElems, create_fun(Next, Tab, Pos)}</font>
        |  	    end;
        |         (close) -&gt;
<font color=red>     0..|  	    ok</font>
        |      end.
        |  
        |  make_ram_index(_, []) -&gt; 
<font color=red>     0..|      done;</font>
        |  make_ram_index(Tab, [Pos | Tail]) -&gt;
<font color=red>     0..|      add_ram_index(Tab, Pos),</font>
<font color=red>     0..|      make_ram_index(Tab, Tail).</font>
        |  
        |  add_ram_index(Tab, Pos) when is_integer(Pos) -&gt;
<font color=red>     0..|      verbose("Creating index for ~w ~n", [Tab]),</font>
<font color=red>     0..|      SetOrBag = val({Tab, setorbag}),</font>
<font color=red>     0..|      IndexType = case SetOrBag of</font>
<font color=red>     0..|          set -&gt; duplicate_bag;</font>
<font color=red>     0..|          ordered_set -&gt; duplicate_bag;</font>
<font color=red>     0..|          bag -&gt; bag</font>
        |      end,
<font color=red>     0..|      Index = mnesia2_monitor:mktab(mnesia2_index, [IndexType, public]),</font>
<font color=red>     0..|      Insert = fun(Rec, _Acc) -&gt;</font>
<font color=red>     0..|  		     true = ?ets_insert(Index, {element(Pos, Rec), element(2, Rec)})</font>
        |  	     end,
<font color=red>     0..|      mnesia2_lib:db_fixtable(ram_copies, Tab, true),</font>
<font color=red>     0..|      true = ets:foldl(Insert, true, Tab),</font>
<font color=red>     0..|      mnesia2_lib:db_fixtable(ram_copies, Tab, false),</font>
<font color=red>     0..|      mnesia2_lib:set({Tab, {index, Pos}}, Index),</font>
<font color=red>     0..|      add_index_info(Tab, SetOrBag, {Pos, {ram, Index}});</font>
        |  add_ram_index(_Tab, snmp) -&gt;
<font color=red>     0..|      ok.</font>
        |  
        |  add_index_info(Tab, Type, IxElem) -&gt;
<font color=red>     0..|      Commit = val({Tab, commit_work}),</font>
<font color=red>     0..|      case lists:keysearch(index, 1, Commit) of</font>
        |  	false -&gt;
<font color=red>     0..|  	    Index = #index{setorbag = Type, </font>
        |  			   pos_list = [IxElem]},
        |  	    %% Check later if mnesia2_tm is sensative about the order 
<font color=red>     0..|  	    mnesia2_lib:set({Tab, commit_work}, </font>
        |  			   mnesia2_lib:sort_commit([Index | Commit]));
        |  	{value, Old} -&gt;
        |  	    %% We could check for consistency here
<font color=red>     0..|  	    Index = Old#index{pos_list = [IxElem | Old#index.pos_list]},</font>
<font color=red>     0..|  	    NewC = lists:keyreplace(index, 1, Commit, Index),</font>
<font color=red>     0..|  	    mnesia2_lib:set({Tab, commit_work}, </font>
        |  			   mnesia2_lib:sort_commit(NewC))
        |      end.
        |  
        |  del_index_info(Tab, Pos) -&gt;
<font color=red>     0..|      Commit = val({Tab, commit_work}),</font>
<font color=red>     0..|      case lists:keysearch(index, 1, Commit) of</font>
        |  	false -&gt;
        |  	    %% Something is wrong ignore
<font color=red>     0..|  	    skip;</font>
        |  	{value, Old} -&gt;
<font color=red>     0..|  	    case lists:keydelete(Pos, 1, Old#index.pos_list) of</font>
        |  		[] -&gt; 
<font color=red>     0..|  		    NewC = lists:keydelete(index, 1, Commit),</font>
<font color=red>     0..|  		    mnesia2_lib:set({Tab, commit_work}, </font>
        |  				   mnesia2_lib:sort_commit(NewC));
        |  		New -&gt;
<font color=red>     0..|  		    Index = Old#index{pos_list = New},</font>
<font color=red>     0..|  		    NewC = lists:keyreplace(index, 1, Commit, Index),</font>
<font color=red>     0..|  		    mnesia2_lib:set({Tab, commit_work}, </font>
        |  				   mnesia2_lib:sort_commit(NewC))
        |  	    end
        |      end.
        |  
        |  db_put({ram, Ixt}, V) -&gt;
<font color=red>     0..|      true = ?ets_insert(Ixt, V);</font>
        |  db_put({dets, Ixt}, V) -&gt;
<font color=red>     0..|      ok = dets:insert(Ixt, V).</font>
        |  
        |  db_get({ram, Ixt}, K) -&gt;
<font color=red>     0..|      ?ets_lookup(Ixt, K);</font>
        |  db_get({dets, Ixt}, K) -&gt;
<font color=red>     0..|      dets:lookup(Ixt, K).</font>
        |  
        |  db_match_erase({ram, Ixt}, Pat) -&gt;
<font color=red>     0..|      true = ?ets_match_delete(Ixt, Pat);</font>
        |  db_match_erase({dets, Ixt}, Pat) -&gt;
<font color=red>     0..|      ok = dets:match_delete(Ixt, Pat).</font>
        |      
        |  db_match({ram, Ixt}, Pat) -&gt;
<font color=red>     0..|      ?ets_match(Ixt, Pat);</font>
        |  db_match({dets, Ixt}, Pat) -&gt;
<font color=red>     0..|      dets:match(Ixt, Pat).</font>
        |      
        |  get_index_table(Tab, Pos) -&gt;
<font color=red>     0..|      get_index_table(Tab,  val({Tab, storage_type}), Pos).</font>
        |  
        |  get_index_table(Tab, ram_copies, Pos) -&gt;
<font color=red>     0..|      {ram,  val({Tab, {index, Pos}})};</font>
        |  get_index_table(Tab, disc_copies, Pos) -&gt;
<font color=red>     0..|      {ram,  val({Tab, {index, Pos}})};</font>
        |  get_index_table(Tab, disc_only_copies, Pos) -&gt;
<font color=red>     0..|      {dets, val({Tab, {index, Pos}})};</font>
        |  get_index_table(_Tab, unknown, _Pos) -&gt;
<font color=red>     0..|      unknown.</font>
        |  
</pre>
</body>
</html>
