<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>/home/travis/build/lrascao/mnesia2/logs/ct_run.test9478@testing-worker-linux-docker-9239c715-3363-linux-12.2016-04-10_22.39.14/lrascao.mnesia2.mnesia2_extra_light_SUITE.logs/run.2016-04-10_22.39.43/mnesia2_backup.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/lrascao/mnesia2/ebin/mnesia2_backup.erl by COVER 2016-04-10 at 22:43:03

****************************************************************************

        |  %%
        |  %% %CopyrightBegin%
        |  %%
        |  %% Copyright Ericsson AB 1996-2011. All Rights Reserved.
        |  %%
        |  %% Licensed under the Apache License, Version 2.0 (the "License");
        |  %% you may not use this file except in compliance with the License.
        |  %% You may obtain a copy of the License at
        |  %%
        |  %%     http://www.apache.org/licenses/LICENSE-2.0
        |  %%
        |  %% Unless required by applicable law or agreed to in writing, software
        |  %% distributed under the License is distributed on an "AS IS" BASIS,
        |  %% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        |  %% See the License for the specific language governing permissions and
        |  %% limitations under the License.
        |  %%
        |  %% %CopyrightEnd%
        |  %%
        |  
        |  %%
        |  
        |  %%-behaviour(mnesia2_backup).
        |  %0
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%
        |  %% This module contains one implementation of callback functions
        |  %% used by Mnesia2 at backup and restore. The user may however
        |  %% write an own module the same interface as mnesia2_backup and
        |  %% configure Mnesia2 so the alternate module performs the actual
        |  %% accesses to the backup media. This means that the user may put
        |  %% the backup on medias that Mnesia2 does not know about, possibly
        |  %% on hosts where Erlang is not running.
        |  %%
        |  %% The OpaqueData argument is never interpreted by other parts of
        |  %% Mnesia2. It is the property of this module. Alternate implementations
        |  %% of this module may have different interpretations of OpaqueData.
        |  %% The OpaqueData argument given to open_write/1 and open_read/1
        |  %% are forwarded directly from the user.
        |  %%
        |  %% All functions must return {ok, NewOpaqueData} or {error, Reason}.
        |  %%
        |  %% The NewOpaqueData arguments returned by backup callback functions will
        |  %% be given as input when the next backup callback function is invoked.
        |  %% If any return value does not match {ok, _} the backup will be aborted.
        |  %%
        |  %% The NewOpaqueData arguments returned by restore callback functions will
        |  %% be given as input when the next restore callback function is invoked
        |  %% If any return value does not match {ok, _} the restore will be aborted.
        |  %%
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  -module(mnesia2_backup).
        |  
        |  -include_lib("kernel/include/file.hrl").
        |  
        |  -export([
        |  	 %% Write access
        |           open_write/1,
        |  	 write/2,
        |  	 commit_write/1,
        |  	 abort_write/1,
        |  
        |  	 %% Read access
        |           open_read/1,
        |  	 read/1,
        |  	 close_read/1
        |          ]).
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Backup callback interface
        |  -record(backup, {tmp_file, file, file_desc}).
        |  
        |  %% Opens backup media for write
        |  %%
        |  %% Returns {ok, OpaqueData} or {error, Reason}
        |  open_write(OpaqueData) -&gt;
    98..|      File = OpaqueData,
    98..|      Tmp = lists:concat([File,".BUPTMP"]),
    98..|      file:delete(Tmp),
    98..|      file:delete(File),
    98..|      case disk_log:open([{name, make_ref()},
        |  			{file, Tmp},
        |  			{repair, false},
        |  			{linkto, self()}]) of
        |  	{ok, Fd} -&gt;
    98..|  	    {ok, #backup{tmp_file = Tmp, file = File, file_desc = Fd}};
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    {error, Reason}</font>
        |      end.
        |  
        |  %% Writes BackupItems to the backup media
        |  %%
        |  %% Returns {ok, OpaqueData} or {error, Reason}
        |  write(OpaqueData, BackupItems) -&gt;
   206..|      B = OpaqueData,
   206..|      case disk_log:log_terms(B#backup.file_desc, BackupItems) of
        |          ok -&gt;
   206..|              {ok, B};
        |          {error, Reason} -&gt;
<font color=red>     0..|              {ok, _} = abort_write(B),</font>
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %% Closes the backup media after a successful backup
        |  %%
        |  %% Returns {ok, ReturnValueToUser} or {error, Reason}
        |  commit_write(OpaqueData) -&gt;
    98..|      B = OpaqueData,
    98..|      case disk_log:sync(B#backup.file_desc) of
        |          ok -&gt;
    98..|              case disk_log:close(B#backup.file_desc) of
        |                  ok -&gt;
    98..|  		    case file:rename(B#backup.tmp_file, B#backup.file) of
        |  		       ok -&gt;
    98..|  			    {ok, B#backup.file};
        |  		       {error, Reason} -&gt;
<font color=red>     0..|  			    {error, Reason}</font>
        |  		    end;
        |                  {error, Reason} -&gt;
<font color=red>     0..|  		    {error, Reason}</font>
        |              end;
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %% Closes the backup media after an interrupted backup
        |  %%
        |  %% Returns {ok, ReturnValueToUser} or {error, Reason}
        |  abort_write(BackupRef) -&gt;
<font color=red>     0..|      Res = disk_log:close(BackupRef#backup.file_desc),</font>
<font color=red>     0..|      file:delete(BackupRef#backup.tmp_file),</font>
<font color=red>     0..|      case Res of</font>
        |          ok -&gt;
<font color=red>     0..|              {ok, BackupRef#backup.file};</font>
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Restore callback interface
        |  
        |  -record(restore, {file, file_desc, cont}).
        |  
        |  %% Opens backup media for read
        |  %%
        |  %% Returns {ok, OpaqueData} or {error, Reason}
        |  open_read(OpaqueData) -&gt;
    96..|      File = OpaqueData,
    96..|      case file:read_file_info(File) of
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    {error, Reason};</font>
        |  	_FileInfo -&gt; %% file exists
    96..|  	    case disk_log:open([{file, File},
        |  				{name, make_ref()},
        |  				{repair, false},
        |  				{mode, read_only},
        |  				{linkto, self()}]) of
        |  		{ok, Fd} -&gt;
    96..|  		    {ok, #restore{file = File, file_desc = Fd, cont = start}};
        |  		{repaired, Fd, _, {badbytes, 0}} -&gt;
<font color=red>     0..|  		    {ok, #restore{file = File, file_desc = Fd, cont = start}};</font>
        |  		{repaired, Fd, _, _} -&gt;
<font color=red>     0..|  		    {ok, #restore{file = File, file_desc = Fd, cont = start}};</font>
        |  		{error, Reason} -&gt;
<font color=red>     0..|  		    {error, Reason}</font>
        |  	    end
        |      end.
        |  
        |  %% Reads BackupItems from the backup media
        |  %%
        |  %% Returns {ok, OpaqueData, BackupItems} or {error, Reason}
        |  %%
        |  %% BackupItems == [] is interpreted as eof
        |  read(OpaqueData) -&gt;
   282..|      R = OpaqueData,
   282..|      Fd = R#restore.file_desc,
   282..|      case disk_log:chunk(Fd, R#restore.cont) of
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, {"Possibly truncated", Reason}};</font>
        |          eof -&gt;
   186..|              {ok, R, []};
        |          {Cont, []} -&gt;
<font color=red>     0..|              read(R#restore{cont = Cont});</font>
        |          {Cont, BackupItems, _BadBytes} -&gt;
<font color=red>     0..|              {ok, R#restore{cont = Cont}, BackupItems};</font>
        |          {Cont, BackupItems} -&gt;
    96..|              {ok, R#restore{cont = Cont}, BackupItems}
        |      end.
        |  
        |  %% Closes the backup media after restore
        |  %%
        |  %% Returns {ok, ReturnValueToUser} or {error, Reason}
        |  close_read(OpaqueData) -&gt;
    96..|      R = OpaqueData,
    96..|      case disk_log:close(R#restore.file_desc) of
    96..|          ok -&gt; {ok, R#restore.file};
<font color=red>     0..|          {error, Reason} -&gt; {error, Reason}</font>
        |      end.
        |  %0
        |  
</pre>
</body>
</html>
