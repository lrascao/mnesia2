<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>/home/travis/build/lrascao/mnesia2/test/mnesia2_qlc_test.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2004-2011. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <i>%%</i>
<a name="22"/>   22: <b>-module</b>(mnesia2_qlc_test).
<a name="23"/>   23: 
<a name="24"/>   24: <b>-compile</b>(export_all).
<a name="25"/>   25: 
<a name="26"/>   26: <b>-export</b>([all/0,groups/0,init_per_group/2,end_per_group/2]).
<a name="27"/>   27: 
<a name="28"/>   28: <b>-include</b>(&quot;mnesia2_test_lib.hrl&quot;).
<a name="29"/>   29: <b>-include_lib</b>(&quot;stdlib/include/qlc.hrl&quot;). 
<a name="30"/>   30: 
<a name="init_per_testcase-2"/><a name="31"/>   31: <b>init_per_testcase</b>(Func, Conf) -&gt;
<a name="32"/>   32:     setup(Conf),
<a name="33"/>   33:     mnesia2_test_lib:init_per_testcase(Func, Conf).
<a name="34"/>   34: 
<a name="end_per_testcase-2"/><a name="35"/>   35: <b>end_per_testcase</b>(Func, Conf) -&gt;
<a name="36"/>   36:     mnesia2_test_lib:end_per_testcase(Func, Conf).
<a name="37"/>   37: 
<a name="all-0"/><a name="38"/>   38: <b>all</b>() -&gt; 
<a name="39"/>   39:     case code:which(qlc) of
<a name="40"/>   40: 	non_existing -&gt; [];
<a name="41"/>   41: 	_ -&gt; all_qlc()
<a name="42"/>   42:     end.
<a name="43"/>   43: 
<a name="groups-0"/><a name="44"/>   44: <b>groups</b>() -&gt; 
<a name="45"/>   45:     [{dirty, [],
<a name="46"/>   46:       [dirty_nice_ram_copies, dirty_nice_disc_copies,
<a name="47"/>   47:        dirty_nice_disc_only_copies]},
<a name="48"/>   48:      {trans, [],
<a name="49"/>   49:       [trans_nice_ram_copies, trans_nice_disc_copies,
<a name="50"/>   50:        trans_nice_disc_only_copies, {group, atomic}]},
<a name="51"/>   51:      {atomic, [], [atomic_eval]}].
<a name="52"/>   52: 
<a name="init_per_group-2"/><a name="53"/>   53: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="54"/>   54:     Config.
<a name="55"/>   55: 
<a name="end_per_group-2"/><a name="56"/>   56: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="57"/>   57:     Config.
<a name="58"/>   58: 
<a name="59"/>   59: 
<a name="all_qlc-0"/><a name="60"/>   60: <b>all_qlc</b>() -&gt; 
<a name="61"/>   61:     [{group, dirty}, {group, trans}, frag, info,
<a name="62"/>   62:      mnesia2_down].
<a name="63"/>   63: 
<a name="init_testcases-2"/><a name="64"/>   64: <b>init_testcases</b>(Type,Config) -&gt;
<a name="65"/>   65:     Nodes = [N1,N2] = ?acquire_nodes(2, Config),
<a name="66"/>   66:     ?match({atomic, ok}, mnesia2:create_table(a, [{Type,[N1]}, {index,[3]}])),
<a name="67"/>   67:     ?match({atomic, ok}, mnesia2:create_table(b, [{Type,[N2]}])),
<a name="68"/>   68:     Write = fun(Id) -&gt; 
<a name="69"/>   69: 		    ok = mnesia2:write({a, {a,Id}, 100 - Id}),
<a name="70"/>   70: 		    ok = mnesia2:write({b, {b,100-Id}, Id})
<a name="71"/>   71: 	    end,
<a name="72"/>   72:     All = fun() -&gt; [Write(Id) || Id &lt;- lists:seq(1,10)], ok end,
<a name="73"/>   73:     ?match({atomic, ok}, mnesia2:sync_transaction(All)),
<a name="74"/>   74:     ?match({atomic, [{b, {b,100-1}, 1}]}, mnesia2:transaction(fun() -&gt; mnesia2:read({b, {b, 99}}) end)),
<a name="75"/>   75:     Nodes.
<a name="76"/>   76: 
<a name="77"/>   77: <i>%% Test cases       </i>
<a name="78"/>   78: 
<a name="dirty_nice_ram_copies-1"/><a name="79"/>   79: <b>dirty_nice_ram_copies</b>(Setup) -&gt; dirty_nice(Setup,ram_copies).
<a name="dirty_nice_disc_copies-1"/><a name="80"/>   80: <b>dirty_nice_disc_copies</b>(Setup) -&gt; dirty_nice(Setup,disc_copies).
<a name="dirty_nice_disc_only_copies-1"/><a name="81"/>   81: <b>dirty_nice_disc_only_copies</b>(Setup) -&gt; dirty_nice(Setup,disc_only_copies).
<a name="82"/>   82: 
<a name="dirty_nice-2"/><a name="83"/>   83: <b>dirty_nice</b>(suite, _) -&gt; [];
<a name="84"/>   84: <b>dirty_nice</b>(doc, _) -&gt; [];
<a name="85"/>   85: <b>dirty_nice</b>(Config, Type) when is_list(Config) -&gt;
<a name="86"/>   86:     Ns = init_testcases(Type,Config),
<a name="87"/>   87:     QA = handle(&lt;&lt;&quot;[Q || Q = {_,{_,Key},Val} &lt;- mnesia2:table(a),&quot;
<a name="88"/>   88: 		 &quot;     Val == 90 + Key]&quot;&gt;&gt;),
<a name="89"/>   89:     QB = handle(&lt;&lt;&quot;[Q || Q = {_,{_,Key},Val} &lt;- mnesia2:table(b),&quot;
<a name="90"/>   90: 		 &quot;     Key == 90 + Val]&quot;&gt;&gt;),
<a name="91"/>   91:     QC = qlc:sort(mnesia2:table(a, [{n_objects,1}, {lock,write}, {traverse, select}])),
<a name="92"/>   92:     QD = qlc:sort(mnesia2:table(a, [{n_objects,1}, {traverse,{select,[{'$1',[],['$1']}]}}])),
<a name="93"/>   93: 
<a name="94"/>   94:     FA = fun() -&gt; qlc:e(QA) end,
<a name="95"/>   95:     FB = fun() -&gt; qlc:e(QB) end,
<a name="96"/>   96:     FC = fun() -&gt; qlc:e(QC) end,
<a name="97"/>   97:     FD = fun() -&gt; qlc:e(QD) end,
<a name="98"/>   98: 
<a name="99"/>   99:     %% Currently unsupported
<a name="100"/>  100:     ?match({'EXIT',{aborted,no_transaction}}, FA()),
<a name="101"/>  101:     ?match({'EXIT',{aborted,no_transaction}}, FB()),
<a name="102"/>  102:     %%
<a name="103"/>  103:     CRes = lists:sort(mnesia2:dirty_match_object(a, {'_','_','_'})),
<a name="104"/>  104:     ?match([{a,{a,5},95}], mnesia2:async_dirty(FA)),
<a name="105"/>  105:     ?match([{b,{b,95},5}], mnesia2:async_dirty(FB)),
<a name="106"/>  106:     ?match(CRes, mnesia2:async_dirty(FC)),
<a name="107"/>  107:     ?match(CRes, mnesia2:async_dirty(FD)),
<a name="108"/>  108:     ?match([{a,{a,5},95}], mnesia2:sync_dirty(FA)),
<a name="109"/>  109:     ?match([{b,{b,95},5}], mnesia2:sync_dirty(FB)),
<a name="110"/>  110:     ?match(CRes, mnesia2:sync_dirty(FC)),
<a name="111"/>  111:     ?match([{a,{a,5},95}], mnesia2:activity(async_dirty, FA)),
<a name="112"/>  112:     ?match([{b,{b,95},5}], mnesia2:activity(async_dirty, FB)),
<a name="113"/>  113:     ?match([{a,{a,5},95}], mnesia2:activity(sync_dirty, FA)),
<a name="114"/>  114:     ?match([{b,{b,95},5}], mnesia2:activity(sync_dirty, FB)),
<a name="115"/>  115:     ?match(CRes, mnesia2:activity(async_dirty,FC)),
<a name="116"/>  116:     case Type of
<a name="117"/>  117: 	disc_only_copies -&gt; skip;
<a name="118"/>  118: 	_ -&gt; 
<a name="119"/>  119: 	    ?match([{a,{a,5},95}], mnesia2:ets(FA)),
<a name="120"/>  120: 	    ?match([{a,{a,5},95}], mnesia2:activity(ets, FA))
<a name="121"/>  121:     end,
<a name="122"/>  122:     ?verify_mnesia2(Ns, []).
<a name="123"/>  123: 
<a name="124"/>  124: 
<a name="trans_nice_ram_copies-1"/><a name="125"/>  125: <b>trans_nice_ram_copies</b>(Setup) -&gt; trans_nice(Setup,ram_copies).
<a name="trans_nice_disc_copies-1"/><a name="126"/>  126: <b>trans_nice_disc_copies</b>(Setup) -&gt; trans_nice(Setup,disc_copies).
<a name="trans_nice_disc_only_copies-1"/><a name="127"/>  127: <b>trans_nice_disc_only_copies</b>(Setup) -&gt; trans_nice(Setup,disc_only_copies).
<a name="128"/>  128: 
<a name="trans_nice-2"/><a name="129"/>  129: <b>trans_nice</b>(suite, _) -&gt; [];
<a name="130"/>  130: <b>trans_nice</b>(doc, _) -&gt; [];
<a name="131"/>  131: <b>trans_nice</b>(Config, Type) when is_list(Config) -&gt;
<a name="132"/>  132:     Ns = init_testcases(Type,Config),
<a name="133"/>  133:     QA = handle(&lt;&lt;&quot;[Q || Q = {_,{_,Key},Val} &lt;- mnesia2:table(a),&quot;
<a name="134"/>  134: 		 &quot;     Val == 90 + Key]&quot;&gt;&gt;),
<a name="135"/>  135:     QB = handle(&lt;&lt;&quot;[Q || Q = {_,{_,Key},Val} &lt;- mnesia2:table(b),&quot;
<a name="136"/>  136: 		 &quot;     Key == 90 + Val]&quot;&gt;&gt;),
<a name="137"/>  137:     QC = handle(recs(), 
<a name="138"/>  138:  		&lt;&lt;&quot;[Q || Q = #a{v=91} &lt;- mnesia2:table(a)]&quot;
<a name="139"/>  139:  		 &gt;&gt;),
<a name="140"/>  140: 
<a name="141"/>  141:     QD = qlc:sort(mnesia2:table(a, [{n_objects,1}, {lock,write}, {traverse, select}])),
<a name="142"/>  142:     QE = qlc:sort(mnesia2:table(a, [{n_objects,1}, {traverse,{select,[{'$1',[],['$1']}]}}])),
<a name="143"/>  143: 
<a name="144"/>  144:     DRes = lists:sort(mnesia2:dirty_match_object(a, {'_','_','_'})),
<a name="145"/>  145: 
<a name="146"/>  146:     FA = fun() -&gt; qlc:e(QA) end,
<a name="147"/>  147:     FB = fun() -&gt; qlc:e(QB) end,
<a name="148"/>  148:     FC = fun() -&gt; qlc:e(QC) end,
<a name="149"/>  149:     FD = fun() -&gt; qlc:e(QD) end,
<a name="150"/>  150:     FE = fun() -&gt; qlc:e(QE) end,
<a name="151"/>  151: 		  
<a name="152"/>  152:     ?match({atomic,[{a,{a,5},95}]}, mnesia2:transaction(FA)),
<a name="153"/>  153:     ?match({atomic,[{b,{b,95},5}]}, mnesia2:transaction(FB)),
<a name="154"/>  154:     ?match({atomic,[{a,{a,9},91}]}, mnesia2:transaction(FC)),
<a name="155"/>  155:     ?match({atomic,[{a,{a,5},95}]}, mnesia2:sync_transaction(FA)),
<a name="156"/>  156:     ?match({atomic,[{b,{b,95},5}]}, mnesia2:sync_transaction(FB)),
<a name="157"/>  157:     ?match({atomic,[{a,{a,9},91}]}, mnesia2:sync_transaction(FC)),
<a name="158"/>  158:     ?match([{a,{a,5},95}], mnesia2:activity(transaction,FA)),
<a name="159"/>  159:     ?match([{b,{b,95},5}], mnesia2:activity(transaction,FB)),
<a name="160"/>  160:     ?match([{a,{a,9},91}], mnesia2:activity(transaction,FC)),
<a name="161"/>  161:     ?match([{a,{a,5},95}], mnesia2:activity(sync_transaction,FA)),
<a name="162"/>  162:     ?match([{b,{b,95},5}], mnesia2:activity(sync_transaction,FB)),
<a name="163"/>  163:     ?match([{a,{a,9},91}], mnesia2:activity(sync_transaction,FC)),
<a name="164"/>  164: 
<a name="165"/>  165:     ?match({atomic, DRes}, mnesia2:transaction(FD)),
<a name="166"/>  166:     ?match({atomic, DRes}, mnesia2:transaction(FE)),
<a name="167"/>  167: 
<a name="168"/>  168:     Rest = fun(Cursor,Loop) -&gt; 
<a name="169"/>  169: 		   case qlc:next_answers(Cursor, 1) of
<a name="170"/>  170: 		       [] -&gt; [];
<a name="171"/>  171: 		       [A]-&gt; [A|Loop(Cursor,Loop)] 
<a name="172"/>  172: 		   end
<a name="173"/>  173: 	   end,
<a name="174"/>  174:     Loop = fun() -&gt; 
<a name="175"/>  175: 		   Cursor = qlc:cursor(QD),
<a name="176"/>  176: 		   Rest(Cursor,Rest)
<a name="177"/>  177: 	   end,
<a name="178"/>  178:     ?match({atomic, DRes}, mnesia2:transaction(Loop)),
<a name="179"/>  179: 
<a name="180"/>  180:     ?verify_mnesia2(Ns, []).
<a name="181"/>  181: 
<a name="182"/>  182: <i>%% -record(a, {k,v}).</i>
<a name="183"/>  183: <i>%% -record(b, {k,v}).</i>
<a name="184"/>  184: <i>%% -record(k, {t,v}).</i>
<a name="185"/>  185: 
<a name="recs-0"/><a name="186"/>  186: <b>recs</b>() -&gt;
<a name="187"/>  187:     &lt;&lt;&quot;-record(a, {k,v}). &quot;
<a name="188"/>  188:       &quot;-record(b, {k,v}). &quot;
<a name="189"/>  189:       &quot;-record(k, {t,v}). &quot;
<a name="190"/>  190:      &gt;&gt;.
<a name="191"/>  191:  
<a name="192"/>  192: 
<a name="atomic_eval-1"/><a name="193"/>  193: <b>atomic_eval</b>(suite) -&gt; [];
<a name="194"/>  194: <b>atomic_eval</b>(doc) -&gt; []; 
<a name="195"/>  195: <b>atomic_eval</b>(Config) -&gt;
<a name="196"/>  196:     Ns = init_testcases(ram_copies, Config),    
<a name="197"/>  197:     Q1 = handle(recs(), 
<a name="198"/>  198: 		&lt;&lt;&quot;[Q || Q = #a{k={_,9}} &lt;- mnesia2:table(a)]&quot;
<a name="199"/>  199: 		 &gt;&gt;),
<a name="200"/>  200:     Eval = fun(Q) -&gt; 
<a name="201"/>  201: 		   {qlc:e(Q),
<a name="202"/>  202: 		    mnesia2:system_info(held_locks)}
<a name="203"/>  203: 	   end,
<a name="204"/>  204:     Self = self(),
<a name="205"/>  205:     ?match({[{a,{a,9},91}], [{{a,'______WHOLETABLE_____'},read,{tid,_,Self}}]},
<a name="206"/>  206: 	   ok(Eval,[Q1])),
<a name="207"/>  207:     
<a name="208"/>  208:     Q2 = handle(recs(), 
<a name="209"/>  209: 		&lt;&lt;&quot;[Q || Q = #a{k={a,9}} &lt;- mnesia2:table(a)]&quot;
<a name="210"/>  210: 		 &gt;&gt;),
<a name="211"/>  211:     
<a name="212"/>  212:     ?match({[{a,{a,9},91}],[{{a,{a,9}},read,{tid,_,Self}}]},
<a name="213"/>  213: 	   ok(Eval,[Q2])),
<a name="214"/>  214: 
<a name="215"/>  215:     Flush = fun(Loop) -&gt; %% Clean queue
<a name="216"/>  216: 		    receive _ -&gt; Loop(Loop) 
<a name="217"/>  217: 		    after 0 -&gt; ok end
<a name="218"/>  218: 	    end,
<a name="219"/>  219:     
<a name="220"/>  220:     Flush(Flush),
<a name="221"/>  221: 
<a name="222"/>  222:     GrabLock = fun(Father) -&gt;  
<a name="223"/>  223: 		       mnesia2:read(a, {a,9}, write),
<a name="224"/>  224: 		       Father ! locked,
<a name="225"/>  225: 		       receive cont -&gt; ok end end,
<a name="226"/>  226: 
<a name="227"/>  227:     Pid1 = spawn(fun() -&gt; ?match(ok, ok(GrabLock, [Self])) end),    
<a name="228"/>  228:     ?match(locked,receive locked -&gt; locked after 5000 -&gt; timeout end), %% Wait
<a name="229"/>  229: 
<a name="230"/>  230:     put(count,0),
<a name="231"/>  231:     Restart = fun(Locker,Fun) -&gt;
<a name="232"/>  232: 		      Count = get(count),
<a name="233"/>  233: 		      case {Count,(catch Fun())}  of
<a name="234"/>  234: 			  {0, {'EXIT', R}} -&gt;
<a name="235"/>  235: 			      Locker ! cont,
<a name="236"/>  236: 			      put(count, Count+1),
<a name="237"/>  237: 			      erlang:yield(),
<a name="238"/>  238: 			      exit(R);
<a name="239"/>  239: 			  Else -&gt;
<a name="240"/>  240: 			      Else
<a name="241"/>  241: 		      end
<a name="242"/>  242: 	      end,
<a name="243"/>  243:     
<a name="244"/>  244:     ?match({1,{[{a,{a,9},91}], [{{a,'______WHOLETABLE_____'},read,{tid,_,Self}}]}},
<a name="245"/>  245: 	   ok(Restart,[Pid1,fun() -&gt; Eval(Q1) end])),
<a name="246"/>  246:     
<a name="247"/>  247:     Pid2 = spawn(fun() -&gt; ?match(ok, ok(GrabLock, [Self])) end),
<a name="248"/>  248:     ?match(locked,receive locked -&gt; locked after 5000 -&gt; timeout end), %% Wait
<a name="249"/>  249:     put(count,0),
<a name="250"/>  250:     ?match({1,{[{a,{a,9},91}],[{{a,{a,9}},read,{tid,_,Self}}]}},
<a name="251"/>  251: 	   ok(Restart,[Pid2, fun() -&gt; Eval(Q2) end])),
<a name="252"/>  252: 
<a name="253"/>  253: <i>%% Basic test     </i>
<a name="254"/>  254:     Cursor = fun() -&gt;
<a name="255"/>  255: 		     QC = qlc:cursor(Q1),
<a name="256"/>  256: 		     qlc:next_answers(QC) 
<a name="257"/>  257: 	     end,
<a name="258"/>  258: 
<a name="259"/>  259:     ?match([{a,{a,9},91}], ok(Cursor, [])),
<a name="260"/>  260:     %% Lock 
<a name="261"/>  261: 
<a name="262"/>  262:     Pid3 = spawn(fun() -&gt; ?match(ok, ok(GrabLock, [Self])) end),    
<a name="263"/>  263:     ?match(locked,receive locked -&gt; locked after 5000 -&gt; timeout end), %% Wait
<a name="264"/>  264:     put(count,0),
<a name="265"/>  265:     
<a name="266"/>  266:     ?match({1,[{a,{a,9},91}]}, ok(Restart,[Pid3, Cursor])),
<a name="267"/>  267:     QC1 = ok(fun() -&gt; qlc:cursor(Q1) end, []),
<a name="268"/>  268:     ?match({'EXIT', _},  (catch qlc:next_answers(QC1))),
<a name="269"/>  269:     ?match({aborted,_},  ok(fun()-&gt;qlc:next_answers(QC1)end,[])),
<a name="270"/>  270:     ?verify_mnesia2(Ns, []).
<a name="271"/>  271: 
<a name="272"/>  272: 
<a name="frag-1"/><a name="273"/>  273: <b>frag</b>(suite) -&gt; [];
<a name="274"/>  274: <b>frag</b>(doc) -&gt; [];
<a name="275"/>  275: <b>frag</b>(Config) -&gt;
<a name="276"/>  276:     Ns = init_testcases(ram_copies,Config),
<a name="277"/>  277:     QA = handle(&lt;&lt;&quot;[Q || Q = {_,{_,Key},Val} &lt;- mnesia2:table(a),&quot;
<a name="278"/>  278: 		 &quot;     Val == 90 + Key]&quot;&gt;&gt;),
<a name="279"/>  279:     QB = handle(&lt;&lt;&quot;[Q || Q = {_,{_,Key},Val} &lt;- mnesia2:table(b),&quot;
<a name="280"/>  280: 		 &quot;     Key == 90 + Val]&quot;&gt;&gt;),
<a name="281"/>  281:     
<a name="282"/>  282:     Activate = 
<a name="283"/>  283: 	fun(Tab) -&gt;
<a name="284"/>  284: 		?match({atomic,ok},mnesia2:change_table_frag(Tab, {activate, []})),
<a name="285"/>  285: 		Dist = mnesia2_frag_test:frag_dist(Tab),
<a name="286"/>  286: 		?match({atomic,ok},mnesia2:change_table_frag(Tab,{add_frag,Dist}))
<a name="287"/>  287: 	end,
<a name="288"/>  288:     Activate(a),
<a name="289"/>  289:     Activate(b),
<a name="290"/>  290: 
<a name="291"/>  291:     Fun = fun(Tab) -&gt; mnesia2:table_info(Tab, frag_names) end,
<a name="292"/>  292:     FTs = mnesia2:activity(sync_dirty, Fun, [a], mnesia2_frag) ++
<a name="293"/>  293: 	mnesia2:activity(sync_dirty, Fun, [b], mnesia2_frag),
<a name="294"/>  294:     Size = fun(Tab) -&gt; mnesia2:dirty_rpc(Tab, mnesia2, table_info, [Tab,size]) end,
<a name="295"/>  295: 
<a name="296"/>  296:     %% Verify that all data doesn't belong to the same frag.
<a name="297"/>  297:     ?match([], [{Tab,Size(Tab)} || Tab &lt;- FTs,
<a name="298"/>  298: 				   Size(Tab) =&lt; 0]),
<a name="299"/>  299:     
<a name="300"/>  300:     FA = fun() -&gt; qlc:e(QA) end,
<a name="301"/>  301:     FB = fun() -&gt; qlc:e(QB) end,
<a name="302"/>  302:     ?match([{a,{a,5},95}], mnesia2:activity(transaction,FA,[],mnesia2_frag)),
<a name="303"/>  303:     ?match([{b,{b,95},5}], mnesia2:activity(transaction,FB,[],mnesia2_frag)),
<a name="304"/>  304:     
<a name="305"/>  305:     ?verify_mnesia2(Ns, []).
<a name="306"/>  306: 
<a name="info-1"/><a name="307"/>  307: <b>info</b>(suite) -&gt; [];
<a name="308"/>  308: <b>info</b>(doc) -&gt; [];
<a name="309"/>  309: <b>info</b>(Config) -&gt;
<a name="310"/>  310:     Ns = init_testcases(ram_copies, Config),
<a name="311"/>  311:     Q1 = handle(recs(), 
<a name="312"/>  312: 		&lt;&lt;&quot;[Q || Q = #a{k={_,9}} &lt;- mnesia2:table(a)]&quot;
<a name="313"/>  313: 		 &gt;&gt;),
<a name="314"/>  314:     
<a name="315"/>  315:     Q2 = handle(recs(), 
<a name="316"/>  316: 		&lt;&lt;&quot;[Q || Q = #a{k={a,9}} &lt;- mnesia2:table(a)]&quot;
<a name="317"/>  317: 		 &gt;&gt;),
<a name="318"/>  318:     
<a name="319"/>  319:     Q3 = handle(recs(), 
<a name="320"/>  320: 		&lt;&lt;&quot;[Q || Q = #a{v=91} &lt;- mnesia2:table(a)]&quot;
<a name="321"/>  321: 		 &gt;&gt;),
<a name="322"/>  322:     
<a name="323"/>  323:     %% FIXME compile and check results!
<a name="324"/>  324:     
<a name="325"/>  325:     ?match(ok,io:format(&quot;~s~n&quot;,[qlc:info(Q1)])),
<a name="326"/>  326:     ?match(ok,io:format(&quot;~s~n&quot;,[qlc:info(Q2)])),
<a name="327"/>  327:     ?match(ok,io:format(&quot;~s~n&quot;,[qlc:info(Q3)])),
<a name="328"/>  328:  
<a name="329"/>  329:     ?verify_mnesia2(Ns, []).
<a name="330"/>  330: 
<a name="ok-2"/><a name="331"/>  331: <b>ok</b>(Fun,A) -&gt;
<a name="332"/>  332:     case mnesia2:transaction(Fun,A) of
<a name="333"/>  333: 	{atomic, R} -&gt; R;
<a name="334"/>  334: 	E -&gt; E
<a name="335"/>  335:     end.
<a name="336"/>  336: 
<a name="337"/>  337: 
<a name="mnesia2_down-1"/><a name="338"/>  338: <b>mnesia2_down</b>(suite) -&gt; [];
<a name="339"/>  339: <b>mnesia2_down</b>(doc) -&gt;
<a name="340"/>  340:     [&quot;Test bug OTP-7968, which crashed mnesia2 when a&quot;
<a name="341"/>  341:      &quot;mnesia2_down came after qlc had been invoked&quot;];
<a name="342"/>  342: <b>mnesia2_down</b>(Config) when is_list(Config) -&gt;
<a name="343"/>  343:     [N1,N2] = init_testcases(ram_copies,Config),
<a name="344"/>  344:     QB = handle(&lt;&lt;&quot;[Q || Q = {_,{_,Key},Val} &lt;- mnesia2:table(b),&quot;
<a name="345"/>  345: 		 &quot;     Val == Key - 90]&quot;&gt;&gt;),
<a name="346"/>  346: 
<a name="347"/>  347:     Tester = self(),    
<a name="348"/>  348:     
<a name="349"/>  349:     Eval = fun() -&gt; 
<a name="350"/>  350: 		   Cursor = qlc:cursor(QB), %% Forces another process
<a name="351"/>  351: 		   Res = qlc:next_answers(Cursor),
<a name="352"/>  352: 		   Tester ! {qlc, self(), Res},
<a name="353"/>  353: 		   {Mod, Tid, Ts} = get(mnesia2_activity_state),
<a name="354"/>  354: 		   receive
<a name="355"/>  355: 		       continue -&gt;
<a name="356"/>  356: 			   io:format(&quot;Continuing ~p ~p ~n&quot;,[self(), {Mod, Tid, Ts}]),
<a name="357"/>  357: 			   io:format(&quot;ETS ~p~n&quot;,[ets:tab2list(element(2,Ts))]),
<a name="358"/>  358: 			   io:format(&quot;~p~n&quot;,[process_info(self(),messages)]),
<a name="359"/>  359: 			   Res
<a name="360"/>  360: 		   end
<a name="361"/>  361: 	   end,
<a name="362"/>  362:     spawn(fun() -&gt; TransRes = mnesia2:transaction(Eval), Tester ! {test,TransRes} end),
<a name="363"/>  363: 
<a name="364"/>  364:     TMInfo = fun() -&gt;
<a name="365"/>  365: 		     TmInfo = mnesia2_tm:get_info(5000),
<a name="366"/>  366: 		     mnesia2_tm:display_info(user, TmInfo)
<a name="367"/>  367: 	     end,
<a name="368"/>  368:     receive
<a name="369"/>  369: 	{qlc, QPid, QRes} -&gt;
<a name="370"/>  370: 	    ?match([{b,{b,95},5}], QRes),
<a name="371"/>  371: 	    TMInfo(),
<a name="372"/>  372: 	    mnesia2_test_lib:kill_mnesia2([N2]),
<a name="373"/>  373: 	    %%timer:sleep(1000),
<a name="374"/>  374: 	    QPid ! continue
<a name="375"/>  375:     after 2000 -&gt;
<a name="376"/>  376: 	    exit(timeout1)
<a name="377"/>  377:     end,
<a name="378"/>  378: 
<a name="379"/>  379:     receive
<a name="380"/>  380: 	{test, QRes2} -&gt;
<a name="381"/>  381: 	    ?match({atomic, [{b,{b,95},5}]}, QRes2)
<a name="382"/>  382:     after 2000 -&gt;
<a name="383"/>  383: 	    exit(timeout2)
<a name="384"/>  384:     end,
<a name="385"/>  385:     
<a name="386"/>  386:     ?verify_mnesia2([N1], [N2]).
<a name="387"/>  387: 
<a name="388"/>  388: 
<a name="nested_qlc-1"/><a name="389"/>  389: <b>nested_qlc</b>(suite) -&gt; [];
<a name="390"/>  390: <b>nested_qlc</b>(doc) -&gt;
<a name="391"/>  391:     [&quot;Test bug in OTP-7968 (the second problem) where nested&quot;
<a name="392"/>  392:      &quot;transaction don't work as expected&quot;];
<a name="393"/>  393: <b>nested_qlc</b>(Config) when is_list(Config) -&gt;
<a name="394"/>  394:     Ns = init_testcases(ram_copies,Config),    
<a name="395"/>  395:     Res = as_with_bs(),
<a name="396"/>  396:     ?match([_|_], Res),
<a name="397"/>  397:     top_as_with_some_bs(10),
<a name="398"/>  398:     
<a name="399"/>  399:     ?verify_mnesia2(Ns, []).
<a name="400"/>  400: 
<a name="401"/>  401: 
<a name="402"/>  402: <i>%% Code from Daniel </i>
<a name="bs_by_a_id-1"/><a name="403"/>  403: <b>bs_by_a_id</b>(A_id) -&gt;
<a name="404"/>  404:     find(qlc:q([ B || B={_,_,F_id} &lt;- mnesia2:table(b), F_id == A_id])).
<a name="405"/>  405: 
<a name="as_with_bs-0"/><a name="406"/>  406: <b>as_with_bs</b>() -&gt;
<a name="407"/>  407:     find(qlc:q([ {A,bs_by_a_id(Id)} ||
<a name="408"/>  408: 		   A = {_, {a,Id}, _} &lt;- mnesia2:table(a)])).
<a name="409"/>  409: 
<a name="top_as_with_some_bs-1"/><a name="410"/>  410: <b>top_as_with_some_bs</b>(Limit) -&gt;
<a name="411"/>  411:     top(
<a name="412"/>  412:       qlc:q([ {A,bs_by_a_id(Id)} ||
<a name="413"/>  413: 		A = {_, {a,Id}, _} &lt;- mnesia2:table(a)]),
<a name="414"/>  414:       Limit,
<a name="415"/>  415:       fun(A1,A2) -&gt; A1 &lt; A2  end
<a name="416"/>  416:      ).
<a name="417"/>  417: 
<a name="418"/>  418: <i>% --- utils</i>
<a name="419"/>  419: 
<a name="find-1"/><a name="420"/>  420: <b>find</b>(Q) -&gt;
<a name="421"/>  421:     F = fun() -&gt; qlc:e(Q) end,
<a name="422"/>  422:     {atomic, Res} = mnesia2:transaction(F),
<a name="423"/>  423:     Res.
<a name="424"/>  424: 
<a name="425"/>  425: <i>% --- it returns top Limit results from query Q ordered by Order sort function</i>
<a name="top-3"/><a name="426"/>  426: <b>top</b>(Q, Limit, Order) -&gt;
<a name="427"/>  427:     Do = fun() -&gt;
<a name="428"/>  428: 		 OQ = qlc:sort(Q, [{order,Order}]),
<a name="429"/>  429: 		 QC = qlc:cursor(OQ),
<a name="430"/>  430: 		 Res = qlc:next_answers(QC, Limit),
<a name="431"/>  431: 		 qlc:delete_cursor(QC),
<a name="432"/>  432: 		 Res
<a name="433"/>  433: 	 end,
<a name="434"/>  434:     {atomic, Res} = mnesia2:transaction(Do),
<a name="435"/>  435:     Res.
<a name="436"/>  436: 
<a name="437"/>  437: <i>%% To keep mnesia2 suite backward compatible,</i>
<a name="438"/>  438: <i>%% we compile the queries in runtime when qlc is available</i>
<a name="439"/>  439: <i>%% Compiles and returns a handle to a qlc</i>
<a name="handle-1"/><a name="440"/>  440: <b>handle</b>(Expr) -&gt;
<a name="441"/>  441:     handle(&lt;&lt;&gt;&gt;,Expr).
<a name="handle-2"/><a name="442"/>  442: <b>handle</b>(Records,Expr) -&gt;
<a name="443"/>  443:     case catch handle2(Records,Expr) of
<a name="444"/>  444: 	{ok, Handle} -&gt;
<a name="445"/>  445: 	    Handle;
<a name="446"/>  446: 	Else -&gt;
<a name="447"/>  447: 	    ?match(ok, Else)
<a name="448"/>  448:     end.
<a name="449"/>  449: 
<a name="handle2-2"/><a name="450"/>  450: <b>handle2</b>(Records,Expr) -&gt;
<a name="451"/>  451:     {FN,Mod} = temp_name(),
<a name="452"/>  452:     ModStr = list_to_binary(&quot;-module(&quot; ++ atom_to_list(Mod) ++ &quot;).\n&quot;),
<a name="453"/>  453:     Prog = &lt;&lt;
<a name="454"/>  454: 	    ModStr/binary,
<a name="455"/>  455: 	    &quot;-include_lib(\&quot;stdlib/include/qlc.hrl\&quot;).\n&quot;,
<a name="456"/>  456: 	    &quot;-export([tmp/0]).\n&quot;,
<a name="457"/>  457: 	    Records/binary,&quot;\n&quot;,
<a name="458"/>  458: 	    &quot;tmp() -&gt;\n&quot;,
<a name="459"/>  459: <i>%%	    &quot;   _ = (catch throw(fvalue_not_reset)),&quot;</i>
<a name="460"/>  460: 	    &quot;   qlc:q( &quot;,
<a name="461"/>  461: 	    Expr/binary,&quot;).\n&quot;&gt;&gt;,
<a name="462"/>  462: 
<a name="463"/>  463:     ?match(ok,file:write_file(FN,Prog)),
<a name="464"/>  464:     {ok,Forms} = epp:parse_file(FN,&quot;&quot;,&quot;&quot;),
<a name="465"/>  465:     {ok,Mod,Bin} = compile:forms(Forms),
<a name="466"/>  466:     code:load_binary(Mod,FN,Bin),
<a name="467"/>  467:     {ok, Mod:tmp()}.
<a name="468"/>  468: 
<a name="setup-1"/><a name="469"/>  469: <b>setup</b>(Config) -&gt;
<a name="470"/>  470:     put(mts_config,Config),
<a name="471"/>  471:     put(mts_tf_counter,0).
<a name="472"/>  472: 
<a name="temp_name-0"/><a name="473"/>  473: <b>temp_name</b>() -&gt;
<a name="474"/>  474:     Conf = get(mts_config),
<a name="475"/>  475:     C = get(mts_tf_counter),
<a name="476"/>  476:     put(mts_tf_counter,C+1),
<a name="477"/>  477:     {filename:join([proplists:get_value(priv_dir,Conf, &quot;.&quot;),
<a name="478"/>  478: 		    &quot;tempfile&quot;++integer_to_list(C)++&quot;.tmp&quot;]),
<a name="479"/>  479:      list_to_atom(&quot;tmp&quot; ++ integer_to_list(C))}.
</pre>
</body>
</html>
